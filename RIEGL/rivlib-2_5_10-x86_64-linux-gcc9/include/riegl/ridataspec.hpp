// This file was auto-generated from:
// scanlib/src/ridataspec.psp
// with pkgspec (x86_64_linux_gcc9) 2.27.10_g662e7a70e

#ifndef RIDATASPEC_HPP
#define RIDATASPEC_HPP

//! The version of ridataspec
//
//! The version macro evaluates to "2,99991,9999" for this version of the library.
//! The three fields are: major,minor and build numbers.
//! A change in major number typically will indicate changes in
//! the API or kind of packages.
#define RIDATASPEC_VERSION "2.99991.9999"

#ifndef DOXYGEN
#ifndef __cplusplus
#error This file cannot be used in C mode.
#endif /* __cplusplus */
#endif /* DOXYGEN */

#if defined(__cplusplus) || defined(DOXYGEN)
#include <riegl/detail/package.hpp>

#include <bitset>
#include <map>
#include <string>

namespace scanlib {

//-----------------------------------------------------------------------------
//!\brief class selector
//!\details A selector is a bitset, indexed by the package id.
//! The package id to use for indexing is one of the enum values 
//! defined in struct package_id. A couple of predefined
//! sets are available. Selectors can be understood as sets whose elements
//! are package (id's). Selector can be combined using set operations.
//! Please look for bitset in your documentation of the C++ standard library
//! to find out more.
//! Please note, that while it is possible to create arbitrary
//! selector combinations, care should be taken to always include the mandatory
//! header packet.
//! Selectors are used with the basic_packets class.
typedef std::bitset<256> selector_type;
//!\brief select all packets
//!\details <para>This selector selects all documented packets.</para>
extern const selector_type select_all;
//!\brief select no packets
//!\details <para>This selector selects no packets.</para>
extern const selector_type select_none;
//!\brief select packets of protocol class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>frame_start_dn, frame_start_up, frame_stop, header, header_ext, line_start_dn, line_start_segment_1, line_start_segment_2, line_start_segment_3, line_start_up, line_stop, meas_start, meas_stop, void_data</para>
extern const selector_type select_protocol;
//!\brief select packets of attribute class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>S10DOF_calib, S10DOF_calib_1, S10DOF_units, atmosphere, atmosphere_1, atmosphere_2, atmosphere_3, atmosphere_4, beam_geometry, biaxial_geometry, device_mounting, extents, extents_1, monitoring_info, mta_settings, mta_settings_1, mta_settings_2, mta_settings_3, receiver_geometry, scan_rect_fov, scan_rect_fov_1, scan_segments_fov, scan_trail_fov, scanner_pose, scanner_pose_hr, scanner_pose_hr_1, scanner_pose_ucs, scanner_pose_ucs_1, units, units_1, units_2, units_3, units_4, units_IMU</para>
extern const selector_type select_attribute;
//!\brief select packets of instrument class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>S10DOF_calib, S10DOF_calib_1, S10DOF_units, beam_geometry, biaxial_geometry, device_mounting, extents, extents_1, gravity_socs, mta_settings, mta_settings_1, mta_settings_2, mta_settings_3, receiver_geometry, units, units_1, units_2, units_3, units_4, units_IMU</para>
extern const selector_type select_instrument;
//!\brief select packets of data class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>IMU_data, S10DOF_data, S10DOF_data_1, counter_sync, counter_sync_2angles_hr, gravity_socs, inclination_static, pps_sync, pps_sync_ext, pps_sync_hr, pps_sync_hr_ext</para>
extern const selector_type select_data;
//!\brief select packets of scan class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>S10DOF_data, S10DOF_data_1, atmosphere, atmosphere_1, atmosphere_2, atmosphere_3, atmosphere_4, counter_sync, counter_sync_2angles_hr, frame_start_dn, frame_start_up, frame_stop, inclination_static, line_start_dn, line_start_segment_1, line_start_segment_2, line_start_segment_3, line_start_up, line_stop, meas_start, meas_stop, monitoring_info, mta_settings, mta_settings_1, mta_settings_2, mta_settings_3, pps_sync, pps_sync_ext, pps_sync_hr, pps_sync_hr_ext, scan_rect_fov, scan_rect_fov_1, scan_segments_fov, scan_trail_fov, scanner_pose, scanner_pose_hr, scanner_pose_hr_1, scanner_pose_ucs, scanner_pose_ucs_1</para>
extern const selector_type select_scan;
//! INTERNAL ONLY
extern const selector_type select_debug;
//! INTERNAL ONLY
extern const selector_type select_wave;
//!\brief select packets of startcond class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>line_start_dn, line_start_segment_1, line_start_segment_2, line_start_segment_3, line_start_up, meas_start</para>
extern const selector_type select_startcond;
//!\brief select packets of deprecated class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>hk_bat, hk_pwr</para>
extern const selector_type select_deprecated;
//! INTERNAL ONLY
extern const selector_type select_lidar;
//! INTERNAL ONLY
extern const selector_type select_internal;
//!\brief select packets of status class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>hk_bat, hk_bat_1, hk_bat_2, hk_ctr, hk_ctr_1, hk_gps, hk_gps_hr, hk_gps_ts, hk_gps_ts_status, hk_gps_ts_status_dop, hk_gps_ts_status_dop_ucs, hk_incl, hk_incl_4axes, hk_ph_data, hk_ph_data_1, hk_ph_units, hk_ph_units_1, hk_pwr, hk_pwr_1, hk_rtc, hk_rtc_sys, pwm_sync</para>
extern const selector_type select_status;
//! INTERNAL ONLY
extern const selector_type select_ttip;
//! INTERNAL ONLY
extern const selector_type select_packed;
//!\brief select packets of notify class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>unsolicited_message, unsolicited_message_1, unsolicited_message_2</para>
extern const selector_type select_notify;
//!\brief select packets of legacy class
//!\details <para>This selector selects the following documented packets:</para>
//! <para>hk_rtc, hk_rtc_sys</para>
extern const selector_type select_legacy;

//! Get class selector by string name
//
//! Returns a selector by giving a string representaion of its name.
//! If the name is not a valid class name, the select_none selector will
//! be returned.
//!\param name any valid class name string
selector_type get_class_selector(const char* name);
//! Get class selector by string name
//
//! Returns a selector by giving a string representaion of its name.
//! If the name is not a valid class name, the select_none selector will
//! be returned.
//!\param name any valid class name string
selector_type get_class_selector(const std::string& name);
//-----------------------------------------------------------------------------
//! enumerated package identifiers
//
//! Packets can be refered by string name, by major and minor numbers,
//! and by an C++ enumeration. This class ties together these
//! various identifiers. While the string names and major, minor numbers
//! are unique outside the RiVLib context, the enumerations are only
//! valid in the context of a particular library version. Consequently
//! if you want to externally store a packet id, either string name or
//! major and minor numbers should be used. The enumerated values on the
//! other hand consist of a contiguous range and therefore can be used
//! as an index into an array. Please note however, that the documentation does not
//! list the entire set of values, the internal packets are omitted.
//! This means, that you cannot infer the numerical value of the enumeration
//! from its listed position in the documentation.
//! The enumerations are used as the index into the selector bitset
//! that can be set for packet dispatching.
struct package_id
{
    enum type {
        unknown = 0
        , IMU_data = 1
        , S10DOF_calib = 2
        , S10DOF_calib_1 = 3
        , S10DOF_data = 4
        , S10DOF_data_1 = 5
        , S10DOF_units = 6
        , atmosphere = 9
        , atmosphere_1 = 10
        , atmosphere_2 = 11
        , atmosphere_3 = 12
        , atmosphere_4 = 13
        , beam_geometry = 15
        , biaxial_geometry = 16
        , counter_sync = 29
        , counter_sync_2angles_hr = 30
        , device_mounting = 46
        , extents = 50
        , extents_1 = 51
        , frame_start_dn = 63
        , frame_start_up = 64
        , frame_stop = 65
        , gravity_socs = 67
        , header = 68
        , header_ext = 70
        , hk_bat = 71
        , hk_bat_1 = 72
        , hk_bat_2 = 73
        , hk_ctr = 75
        , hk_ctr_1 = 76
        , hk_gps = 81
        , hk_gps_hr = 82
        , hk_gps_ts = 83
        , hk_gps_ts_status = 84
        , hk_gps_ts_status_dop = 85
        , hk_gps_ts_status_dop_ucs = 86
        , hk_incl = 88
        , hk_incl_4axes = 89
        , hk_ph_data = 93
        , hk_ph_data_1 = 94
        , hk_ph_units = 95
        , hk_ph_units_1 = 96
        , hk_pwr = 97
        , hk_pwr_1 = 98
        , hk_rtc = 111
        , hk_rtc_sys = 112
        , inclination_static = 125
        , line_start_dn = 140
        , line_start_segment_1 = 141
        , line_start_segment_2 = 142
        , line_start_segment_3 = 143
        , line_start_up = 144
        , line_stop = 145
        , meas_start = 148
        , meas_stop = 149
        , monitoring_info = 150
        , mta_settings = 151
        , mta_settings_1 = 152
        , mta_settings_2 = 153
        , mta_settings_3 = 154
        , pps_sync = 175
        , pps_sync_ext = 176
        , pps_sync_hr = 177
        , pps_sync_hr_ext = 178
        , pwm_sync = 182
        , receiver_geometry = 195
        , scan_rect_fov = 218
        , scan_rect_fov_1 = 219
        , scan_segments_fov = 220
        , scan_trail_fov = 221
        , scanner_pose = 222
        , scanner_pose_hr = 223
        , scanner_pose_hr_1 = 224
        , scanner_pose_ucs = 225
        , scanner_pose_ucs_1 = 226
        , units = 242
        , units_1 = 243
        , units_2 = 244
        , units_3 = 245
        , units_4 = 246
        , units_IMU = 247
        , unsolicited_message = 248
        , unsolicited_message_1 = 249
        , unsolicited_message_2 = 250
        , void_data = 252
        #ifndef DOXYGEN
        , alert = 7
        , arange_table = 8
        , avg_fine_ref_dg = 14
        , blob_uint32 = 17
        , blob_uint8 = 18
        , calib_2D_table = 19
        , calib_table = 20
        , calib_waveform = 21
        , calib_waveform_1 = 22
        , calib_waveform_L2 = 23
        , calib_waveform_L2_1 = 24
        , calib_wfm_sbl_header = 25
        , cc_slice = 26
        , channel_combination_table = 27
        , context_end = 28
        , crc32_check = 31
        , crc32_header = 32
        , cs_trans = 33
        , datagram_separator = 34
        , debug_hw_dg = 35
        , debug_sw_dg = 36
        , device_geometry = 37
        , device_geometry_1 = 38
        , device_geometry_2 = 39
        , device_geometry_3 = 40
        , device_geometry_4 = 41
        , device_geometry_5 = 42
        , device_geometry_6 = 43
        , device_geometry_7 = 44
        , device_geometry_passive_channel = 45
        , dyntrig = 47
        , echo = 48
        , echo_1 = 49
        , external_gnss_cfg = 52
        , external_gnss_cfg_ext = 53
        , firmware = 54
        , firmware_1 = 55
        , firmware_2 = 56
        , firmware_3 = 57
        , fp_samples = 58
        , fp_table = 59
        , fp_trace2ampl = 60
        , fp_wghts = 61
        , frame_start = 62
        , generic_end = 66
        , header_device = 69
        , hk_cam = 74
        , hk_extended_external = 77
        , hk_extended_internal = 78
        , hk_float64_param = 79
        , hk_float_param = 80
        , hk_group_header = 87
        , hk_monitor = 90
        , hk_param_header = 91
        , hk_param_header_1 = 92
        , hk_rad = 99
        , hk_rng = 100
        , hk_rng_1 = 101
        , hk_rng_2 = 102
        , hk_rng_3 = 103
        , hk_rng_4 = 104
        , hk_rng_5 = 105
        , hk_rng_6 = 106
        , hk_rng_7 = 107
        , hk_rng_8 = 108
        , hk_rng_9 = 109
        , hk_rngx = 110
        , hk_scn = 113
        , hk_scn_1 = 114
        , hk_scn_2 = 115
        , hk_string_param = 116
        , hk_time = 117
        , hk_uint64_param = 118
        , ht_dbg_data = 119
        , inclination = 120
        , inclination_4axes = 121
        , inclination_device = 122
        , inclination_device_4axes = 123
        , inclination_device_4axes_offset = 124
        , laser_echo = 126
        , laser_echo_qual = 127
        , laser_echo_sw = 128
        , laser_shot = 129
        , laser_shot_1angle = 130
        , laser_shot_2angles = 131
        , laser_shot_2angles_hr = 132
        , laser_shot_2angles_rad = 133
        , laser_shot_3angles = 134
        , laser_shot_6angles = 135
        , laser_shot_6angles_hr = 136
        , laser_shot_rad = 137
        , laser_shot_utctime_origin_direction = 138
        , line_start = 139
        , m_sequence_mta = 146
        , magnetic_field = 147
        , notch_filter = 155
        , notch_filter_modification_parameters = 156
        , nrange_table = 157
        , operating_time = 158
        , packed_frame_echo = 159
        , packed_frame_echo_hr = 160
        , packed_frame_echo_hr_1 = 161
        , packed_frame_laser_shot_2angles = 162
        , packed_frame_laser_shot_2angles_hr = 163
        , packed_frame_laser_shot_2angles_rad = 164
        , packed_key_echo = 165
        , packed_key_echo_hr = 166
        , packed_key_echo_hr_1 = 167
        , packed_key_laser_shot_2angles = 168
        , packed_key_laser_shot_2angles_hr = 169
        , packed_key_laser_shot_2angles_hr_mta = 170
        , packed_key_laser_shot_2angles_rad = 171
        , packed_sdf = 172
        , packed_shot_echos_hr = 173
        , packed_shot_echos_sbl_hr = 174
        , pulse_model_expsum = 179
        , pulse_position_modulation = 180
        , pulse_position_modulation_1 = 181
        , range_calc = 183
        , range_finder_debug_acq = 184
        , range_finder_debug_acq_1 = 185
        , range_finder_debug_calc = 186
        , range_finder_debug_calc_1 = 187
        , range_finder_debug_laser = 188
        , range_finder_debug_laser_1 = 189
        , range_finder_debug_rcv = 190
        , range_finder_program = 191
        , range_finder_program_1 = 192
        , range_finder_program_2 = 193
        , range_finder_settings = 194
        , reftab_table = 196
        , rel_refl_table = 197
        , rxp_parameters = 198
        , sbl_dg_channel = 199
        , sbl_dg_channel_1 = 200
        , sbl_dg_channel_2 = 201
        , sbl_dg_channel_data = 202
        , sbl_dg_channel_data_compressed = 203
        , sbl_dg_channel_expsum = 204
        , sbl_dg_channel_expsum_1 = 205
        , sbl_dg_channel_fp = 206
        , sbl_dg_channel_header = 207
        , sbl_dg_channel_header_1 = 208
        , sbl_dg_channel_logamp = 209
        , sbl_dg_data = 210
        , sbl_dg_data_compressed = 211
        , sbl_dg_data_compressed_hr = 212
        , sbl_dg_data_hr = 213
        , sbl_dg_filter = 214
        , sbl_dg_header = 215
        , sbl_dg_header_hr = 216
        , sbl_dg_parameters = 217
        , slt_dg = 227
        , slt_dg_1 = 228
        , slt_dg_2 = 229
        , slt_dg_3 = 230
        , slt_dg_4 = 231
        , tgt_dg = 232
        , timed_blob = 233
        , trigger_debug_dyntrig_table = 234
        , trigger_debug_stattrig_table = 235
        , ttip_config = 236
        , ttip_config_channel = 237
        , ttip_start_stop = 238
        , ttip_timestamp = 239
        , ublox_lea5t_rxm = 240
        , ublox_lea5t_rxm_sfrb = 241
        , versions = 251
        , wfm_dg_hp = 253
        , wfm_dg_lp = 254
        , wfm_dg_shp = 255
        #endif //DOXYGEN
    };

    //! constructor from type
    //
    //! Construct a packet_id type enumeration.
    //!\param type_id package type identifier 
    package_id(package_id::type type_id) {
        *this = name_from_type[type_id].second;
    }

    //! constructor from id's
    //
    //! Construct a packet_id from externally unique main and sub id's
    //! Will map to unknown resp. main=0, sub=0 if requesting undefined packet.
    //!\param main_ main packet id
    //!\param sub_ sub packet id
    package_id(unsigned main_, unsigned sub_)
        : main(main_), sub(sub_)
    {}

    //! constructor from string name
    //
    //! Construct a packet_id from externally unique packet name
    //! Will map to unknown resp. main=0, sub=0 if requesting undefined packet.
    //!\param name string name of packet
    package_id(const char* name) {
        std::map<std::string, package_id>::const_iterator it;
        it = id_from_name.find(name);
        if (it != id_from_name.end()) {
            main = it->second.main;
            sub = it->second.sub;
        }
        else {
            main = 0;
            sub = 0;
        }
    }

    //! constructor from packet reference
    //
    //! Construct a packet_id from a packet instance
    //!\param p packet instance
    template<class P>
    explicit package_id(const P& p)
        : main(P::id_main), sub(P::id_sub)
    {}

    //! default constructor
    //
    //! Construct a id of invalid type
    package_id() {
        main = 0;
        sub = 0;
    }

    //! constructor from string name
    //
    //! Construct a packet_id from externally unique packet name
    //! Will map to unknown resp. main=0, sub=0 if requesting undefined packet.
    //!\param name string name of packet
    package_id(const std::string& name) {
        std::map<std::string, package_id>::const_iterator it;
        it = id_from_name.find(name);
        if (it != id_from_name.end()) {
            main = it->second.main;
            sub = it->second.sub;
        }
        else {
            main = 0;
            sub = 0;
        }
    }

    //! convert to enumeration
    //
    //! This operator converts the external id's into enumeration format.
    operator type() const;

    //! get string representation
    //
    //! This function converts the external id's into its string name.
    std::string string() const;
    unsigned main; //!< external main id
    unsigned sub;  //!< external sub id

private:
    static const std::pair<std::string, package_id> name_from_type[];
    static const std::map<std::string, package_id> id_from_name;
};

std::ostream& operator<<(std::ostream& s, const package_id& id); //!< INTERNAL ONLY
std::istream& operator>>(std::istream& s, package_id& id);//!< INTERNAL ONLY
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
template<class it>
struct package
    : public basic_package<it>
{
    package_id::type type;

    package(it begin, it end, const lookup_table& lu)
        : basic_package<it>(begin, end, lu)
    {
        lookup_table::id& id(basic_package<it>::id);
        type = package_id(id.main, id.sub);
    }
};
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! IMU raw data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct IMU_data
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef IMU_data<rebind_it> type;
    };

    typedef it iterator_type;

    IMU_data(it begin, it end, bool dirty=false)
        : systime(begin)
        , x_gyro(begin)
        , y_gyro(begin)
        , z_gyro(begin)
        , x_accl(begin)
        , y_accl(begin)
        , z_accl(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 61, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return systime.begin(); }
    it end() const { return z_accl.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  time stamp of IMU data in units of time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t x_gyro;//!<  gyro raw data x-axis in units of gyro_unit 
    #else
    binary::field<int16_t, sc_int16, 32, it> x_gyro;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t y_gyro;//!<  gyro raw data y-axis .. 
    #else
    binary::field<int16_t, sc_int16, 48, it> y_gyro;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t z_gyro;//!<  gyro raw data z-axis .. 
    #else
    binary::field<int16_t, sc_int16, 64, it> z_gyro;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t x_accl;//!<  accelerometer x-axis in units of accl_unit 
    #else
    binary::field<int16_t, sc_int16, 80, it> x_accl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t y_accl;//!<  accelerometer y-axis .. 
    #else
    binary::field<int16_t, sc_int16, 96, it> y_accl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t z_accl;//!<  accelerometer z-axis .. 
    #else
    binary::field<int16_t, sc_int16, 112, it> z_accl;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    IMU_data& operator=(const IMU_data<ito>& o) {
        systime = o.systime;
        x_gyro = o.x_gyro;
        y_gyro = o.y_gyro;
        z_gyro = o.z_gyro;
        x_accl = o.x_accl;
        y_accl = o.y_accl;
        z_accl = o.z_accl;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct IMU_data<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef IMU_data<rebind_it> type;
    };

    enum { id_main = 61, id_sub = 0};

    uint32_t         systime;
    int16_t          x_gyro;
    int16_t          y_gyro;
    int16_t          z_gyro;
    int16_t          x_accl;
    int16_t          y_accl;
    int16_t          z_accl;

    IMU_data()
        : systime()
        , x_gyro()
        , y_gyro()
        , z_gyro()
        , x_accl()
        , y_accl()
        , z_accl()
    {}

    template<class it>
    IMU_data(const IMU_data<it>& o) {
        systime = o.systime;
        x_gyro = o.x_gyro;
        y_gyro = o.y_gyro;
        z_gyro = o.z_gyro;
        x_accl = o.x_accl;
        y_accl = o.y_accl;
        z_accl = o.z_accl;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const IMU_data<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.x_gyro;
        s << ", " << x.y_gyro;
        s << ", " << x.z_gyro;
        s << ", " << x.x_accl;
        s << ", " << x.y_accl;
        s << ", " << x.z_accl;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, IMU_data<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.x_gyro;
        s >> ',' >> x.y_gyro;
        s >> ',' >> x.z_gyro;
        s >> ',' >> x.x_accl;
        s >> ',' >> x.y_accl;
        s >> ',' >> x.z_accl;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! specifies the sensitive axes of the sensors at frame_angle = 0

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct S10DOF_calib
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_calib<rebind_it> type;
    };

    typedef it iterator_type;

    S10DOF_calib(it begin, it end, bool dirty=false)
        : gyro_xaxis(begin)
        , gyro_yaxis(begin)
        , gyro_zaxis(begin)
        , accl_xaxis(begin)
        , accl_yaxis(begin)
        , accl_zaxis(begin)
        , magn_xaxis(begin)
        , magn_yaxis(begin)
        , magn_zaxis(begin)
        , gyro_offset(begin)
        , acc_offset(begin)
        , magn_offset(begin)
        , magn_fixed(begin)
        , imu_origin(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 118, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1344};
    it begin() const { return gyro_xaxis.begin(); }
    it end() const { return imu_origin.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_xaxis[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 0, it> gyro_xaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_yaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 96, it> gyro_yaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_zaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 192, it> gyro_zaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_xaxis[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 288, it> accl_xaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_yaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 384, it> accl_yaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_zaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 480, it> accl_zaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_xaxis[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 576, it> magn_xaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_yaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 672, it> magn_yaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_zaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 768, it> magn_zaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_offset[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 864, it> gyro_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float acc_offset[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 960, it> acc_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_offset[3];//!<  in nT 
    #else
    binary::array<float, 3, sc_float32, 1056, it> magn_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_fixed[3];//!<  in nT 
    #else
    binary::array<float, 3, sc_float32, 1152, it> magn_fixed;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float imu_origin[3];//!<  in meter 
    #else
    binary::array<float, 3, sc_float32, 1248, it> imu_origin;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    S10DOF_calib& operator=(const S10DOF_calib<ito>& o) {
        for(unsigned n=0; n<3; ++n) gyro_xaxis[n] = o.gyro_xaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_yaxis[n] = o.gyro_yaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_zaxis[n] = o.gyro_zaxis[n];
        for(unsigned n=0; n<3; ++n) accl_xaxis[n] = o.accl_xaxis[n];
        for(unsigned n=0; n<3; ++n) accl_yaxis[n] = o.accl_yaxis[n];
        for(unsigned n=0; n<3; ++n) accl_zaxis[n] = o.accl_zaxis[n];
        for(unsigned n=0; n<3; ++n) magn_xaxis[n] = o.magn_xaxis[n];
        for(unsigned n=0; n<3; ++n) magn_yaxis[n] = o.magn_yaxis[n];
        for(unsigned n=0; n<3; ++n) magn_zaxis[n] = o.magn_zaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_offset[n] = o.gyro_offset[n];
        for(unsigned n=0; n<3; ++n) acc_offset[n] = o.acc_offset[n];
        for(unsigned n=0; n<3; ++n) magn_offset[n] = o.magn_offset[n];
        for(unsigned n=0; n<3; ++n) magn_fixed[n] = o.magn_fixed[n];
        for(unsigned n=0; n<3; ++n) imu_origin[n] = o.imu_origin[n];
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct S10DOF_calib<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_calib<rebind_it> type;
    };

    enum { id_main = 118, id_sub = 0};

    float            gyro_xaxis[3];
    float            gyro_yaxis[3];
    float            gyro_zaxis[3];
    float            accl_xaxis[3];
    float            accl_yaxis[3];
    float            accl_zaxis[3];
    float            magn_xaxis[3];
    float            magn_yaxis[3];
    float            magn_zaxis[3];
    float            gyro_offset[3];
    float            acc_offset[3];
    float            magn_offset[3];
    float            magn_fixed[3];
    float            imu_origin[3];

    S10DOF_calib()
        : gyro_xaxis()
        , gyro_yaxis()
        , gyro_zaxis()
        , accl_xaxis()
        , accl_yaxis()
        , accl_zaxis()
        , magn_xaxis()
        , magn_yaxis()
        , magn_zaxis()
        , gyro_offset()
        , acc_offset()
        , magn_offset()
        , magn_fixed()
        , imu_origin()
    {}

    template<class it>
    S10DOF_calib(const S10DOF_calib<it>& o) {
        for(unsigned n=0; n<3; ++n) gyro_xaxis[n] = o.gyro_xaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_yaxis[n] = o.gyro_yaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_zaxis[n] = o.gyro_zaxis[n];
        for(unsigned n=0; n<3; ++n) accl_xaxis[n] = o.accl_xaxis[n];
        for(unsigned n=0; n<3; ++n) accl_yaxis[n] = o.accl_yaxis[n];
        for(unsigned n=0; n<3; ++n) accl_zaxis[n] = o.accl_zaxis[n];
        for(unsigned n=0; n<3; ++n) magn_xaxis[n] = o.magn_xaxis[n];
        for(unsigned n=0; n<3; ++n) magn_yaxis[n] = o.magn_yaxis[n];
        for(unsigned n=0; n<3; ++n) magn_zaxis[n] = o.magn_zaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_offset[n] = o.gyro_offset[n];
        for(unsigned n=0; n<3; ++n) acc_offset[n] = o.acc_offset[n];
        for(unsigned n=0; n<3; ++n) magn_offset[n] = o.magn_offset[n];
        for(unsigned n=0; n<3; ++n) magn_fixed[n] = o.magn_fixed[n];
        for(unsigned n=0; n<3; ++n) imu_origin[n] = o.imu_origin[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const S10DOF_calib<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.gyro_xaxis);
        s << ", "; write_array(s, 3, x.gyro_yaxis);
        s << ", "; write_array(s, 3, x.gyro_zaxis);
        s << ", "; write_array(s, 3, x.accl_xaxis);
        s << ", "; write_array(s, 3, x.accl_yaxis);
        s << ", "; write_array(s, 3, x.accl_zaxis);
        s << ", "; write_array(s, 3, x.magn_xaxis);
        s << ", "; write_array(s, 3, x.magn_yaxis);
        s << ", "; write_array(s, 3, x.magn_zaxis);
        s << ", "; write_array(s, 3, x.gyro_offset);
        s << ", "; write_array(s, 3, x.acc_offset);
        s << ", "; write_array(s, 3, x.magn_offset);
        s << ", "; write_array(s, 3, x.magn_fixed);
        s << ", "; write_array(s, 3, x.imu_origin);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, S10DOF_calib<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.gyro_xaxis);
        s >> ','; read_array(s, 3, x.gyro_yaxis);
        s >> ','; read_array(s, 3, x.gyro_zaxis);
        s >> ','; read_array(s, 3, x.accl_xaxis);
        s >> ','; read_array(s, 3, x.accl_yaxis);
        s >> ','; read_array(s, 3, x.accl_zaxis);
        s >> ','; read_array(s, 3, x.magn_xaxis);
        s >> ','; read_array(s, 3, x.magn_yaxis);
        s >> ','; read_array(s, 3, x.magn_zaxis);
        s >> ','; read_array(s, 3, x.gyro_offset);
        s >> ','; read_array(s, 3, x.acc_offset);
        s >> ','; read_array(s, 3, x.magn_offset);
        s >> ','; read_array(s, 3, x.magn_fixed);
        s >> ','; read_array(s, 3, x.imu_origin);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! specifies the sensitive axes of the sensors at frame_angle = 0

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct S10DOF_calib_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_calib_1<rebind_it> type;
    };

    typedef it iterator_type;

    S10DOF_calib_1(it begin, it end, bool dirty=false)
        : gyro_xaxis(begin)
        , gyro_yaxis(begin)
        , gyro_zaxis(begin)
        , accl_xaxis(begin)
        , accl_yaxis(begin)
        , accl_zaxis(begin)
        , magn_xaxis(begin)
        , magn_yaxis(begin)
        , magn_zaxis(begin)
        , gyro_offset(begin)
        , acc_offset(begin)
        , magn_offset(begin)
        , magn_fixed(begin)
        , imu_origin(begin)
        , accl_relNL(begin)
        , gyro_relNL(begin)
        , magn_relNL(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 118, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 1632};
    it begin() const { return gyro_xaxis.begin(); }
    it end() const { return magn_relNL.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_xaxis[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 0, it> gyro_xaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_yaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 96, it> gyro_yaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_zaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 192, it> gyro_zaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_xaxis[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 288, it> accl_xaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_yaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 384, it> accl_yaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_zaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 480, it> accl_zaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_xaxis[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 576, it> magn_xaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_yaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 672, it> magn_yaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_zaxis[3];//!<  .. 
    #else
    binary::array<float, 3, sc_float32, 768, it> magn_zaxis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_offset[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 864, it> gyro_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float acc_offset[3];//!<  in the same unit as the raw data 
    #else
    binary::array<float, 3, sc_float32, 960, it> acc_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_offset[3];//!<  in nT 
    #else
    binary::array<float, 3, sc_float32, 1056, it> magn_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_fixed[3];//!<  in nT 
    #else
    binary::array<float, 3, sc_float32, 1152, it> magn_fixed;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float imu_origin[3];//!<  in meter 
    #else
    binary::array<float, 3, sc_float32, 1248, it> imu_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_relNL[3];//!<  relative nonlinearity, dimensionless 
    #else
    binary::array<float, 3, sc_float32, 1344, it> accl_relNL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_relNL[3];//!<  relative nonlinearity, dimensionless 
    #else
    binary::array<float, 3, sc_float32, 1440, it> gyro_relNL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_relNL[3];//!<  relative nonlinearity, dimensionless 
    #else
    binary::array<float, 3, sc_float32, 1536, it> magn_relNL;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    S10DOF_calib_1& operator=(const S10DOF_calib_1<ito>& o) {
        for(unsigned n=0; n<3; ++n) gyro_xaxis[n] = o.gyro_xaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_yaxis[n] = o.gyro_yaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_zaxis[n] = o.gyro_zaxis[n];
        for(unsigned n=0; n<3; ++n) accl_xaxis[n] = o.accl_xaxis[n];
        for(unsigned n=0; n<3; ++n) accl_yaxis[n] = o.accl_yaxis[n];
        for(unsigned n=0; n<3; ++n) accl_zaxis[n] = o.accl_zaxis[n];
        for(unsigned n=0; n<3; ++n) magn_xaxis[n] = o.magn_xaxis[n];
        for(unsigned n=0; n<3; ++n) magn_yaxis[n] = o.magn_yaxis[n];
        for(unsigned n=0; n<3; ++n) magn_zaxis[n] = o.magn_zaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_offset[n] = o.gyro_offset[n];
        for(unsigned n=0; n<3; ++n) acc_offset[n] = o.acc_offset[n];
        for(unsigned n=0; n<3; ++n) magn_offset[n] = o.magn_offset[n];
        for(unsigned n=0; n<3; ++n) magn_fixed[n] = o.magn_fixed[n];
        for(unsigned n=0; n<3; ++n) imu_origin[n] = o.imu_origin[n];
        for(unsigned n=0; n<3; ++n) accl_relNL[n] = o.accl_relNL[n];
        for(unsigned n=0; n<3; ++n) gyro_relNL[n] = o.gyro_relNL[n];
        for(unsigned n=0; n<3; ++n) magn_relNL[n] = o.magn_relNL[n];
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct S10DOF_calib_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_calib_1<rebind_it> type;
    };

    enum { id_main = 118, id_sub = 1};

    float            gyro_xaxis[3];
    float            gyro_yaxis[3];
    float            gyro_zaxis[3];
    float            accl_xaxis[3];
    float            accl_yaxis[3];
    float            accl_zaxis[3];
    float            magn_xaxis[3];
    float            magn_yaxis[3];
    float            magn_zaxis[3];
    float            gyro_offset[3];
    float            acc_offset[3];
    float            magn_offset[3];
    float            magn_fixed[3];
    float            imu_origin[3];
    float            accl_relNL[3];
    float            gyro_relNL[3];
    float            magn_relNL[3];

    S10DOF_calib_1()
        : gyro_xaxis()
        , gyro_yaxis()
        , gyro_zaxis()
        , accl_xaxis()
        , accl_yaxis()
        , accl_zaxis()
        , magn_xaxis()
        , magn_yaxis()
        , magn_zaxis()
        , gyro_offset()
        , acc_offset()
        , magn_offset()
        , magn_fixed()
        , imu_origin()
        , accl_relNL()
        , gyro_relNL()
        , magn_relNL()
    {}

    template<class it>
    S10DOF_calib_1(const S10DOF_calib_1<it>& o) {
        for(unsigned n=0; n<3; ++n) gyro_xaxis[n] = o.gyro_xaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_yaxis[n] = o.gyro_yaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_zaxis[n] = o.gyro_zaxis[n];
        for(unsigned n=0; n<3; ++n) accl_xaxis[n] = o.accl_xaxis[n];
        for(unsigned n=0; n<3; ++n) accl_yaxis[n] = o.accl_yaxis[n];
        for(unsigned n=0; n<3; ++n) accl_zaxis[n] = o.accl_zaxis[n];
        for(unsigned n=0; n<3; ++n) magn_xaxis[n] = o.magn_xaxis[n];
        for(unsigned n=0; n<3; ++n) magn_yaxis[n] = o.magn_yaxis[n];
        for(unsigned n=0; n<3; ++n) magn_zaxis[n] = o.magn_zaxis[n];
        for(unsigned n=0; n<3; ++n) gyro_offset[n] = o.gyro_offset[n];
        for(unsigned n=0; n<3; ++n) acc_offset[n] = o.acc_offset[n];
        for(unsigned n=0; n<3; ++n) magn_offset[n] = o.magn_offset[n];
        for(unsigned n=0; n<3; ++n) magn_fixed[n] = o.magn_fixed[n];
        for(unsigned n=0; n<3; ++n) imu_origin[n] = o.imu_origin[n];
        for(unsigned n=0; n<3; ++n) accl_relNL[n] = o.accl_relNL[n];
        for(unsigned n=0; n<3; ++n) gyro_relNL[n] = o.gyro_relNL[n];
        for(unsigned n=0; n<3; ++n) magn_relNL[n] = o.magn_relNL[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const S10DOF_calib_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.gyro_xaxis);
        s << ", "; write_array(s, 3, x.gyro_yaxis);
        s << ", "; write_array(s, 3, x.gyro_zaxis);
        s << ", "; write_array(s, 3, x.accl_xaxis);
        s << ", "; write_array(s, 3, x.accl_yaxis);
        s << ", "; write_array(s, 3, x.accl_zaxis);
        s << ", "; write_array(s, 3, x.magn_xaxis);
        s << ", "; write_array(s, 3, x.magn_yaxis);
        s << ", "; write_array(s, 3, x.magn_zaxis);
        s << ", "; write_array(s, 3, x.gyro_offset);
        s << ", "; write_array(s, 3, x.acc_offset);
        s << ", "; write_array(s, 3, x.magn_offset);
        s << ", "; write_array(s, 3, x.magn_fixed);
        s << ", "; write_array(s, 3, x.imu_origin);
        s << ", "; write_array(s, 3, x.accl_relNL);
        s << ", "; write_array(s, 3, x.gyro_relNL);
        s << ", "; write_array(s, 3, x.magn_relNL);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, S10DOF_calib_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.gyro_xaxis);
        s >> ','; read_array(s, 3, x.gyro_yaxis);
        s >> ','; read_array(s, 3, x.gyro_zaxis);
        s >> ','; read_array(s, 3, x.accl_xaxis);
        s >> ','; read_array(s, 3, x.accl_yaxis);
        s >> ','; read_array(s, 3, x.accl_zaxis);
        s >> ','; read_array(s, 3, x.magn_xaxis);
        s >> ','; read_array(s, 3, x.magn_yaxis);
        s >> ','; read_array(s, 3, x.magn_zaxis);
        s >> ','; read_array(s, 3, x.gyro_offset);
        s >> ','; read_array(s, 3, x.acc_offset);
        s >> ','; read_array(s, 3, x.magn_offset);
        s >> ','; read_array(s, 3, x.magn_fixed);
        s >> ','; read_array(s, 3, x.imu_origin);
        s >> ','; read_array(s, 3, x.accl_relNL);
        s >> ','; read_array(s, 3, x.gyro_relNL);
        s >> ','; read_array(s, 3, x.magn_relNL);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! raw data of 10 deg of freedom sensors

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct S10DOF_data
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_data<rebind_it> type;
    };

    typedef it iterator_type;

    S10DOF_data(it begin, it end, bool dirty=false)
        : systime(begin)
        , frame_angle(begin)
        , x_gyro(begin)
        , y_gyro(begin)
        , z_gyro(begin)
        , x_accl(begin)
        , y_accl(begin)
        , z_accl(begin)
        , x_magn(begin)
        , y_magn(begin)
        , z_magn(begin)
        , temp(begin)
        , altd(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 114, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 240};
    it begin() const { return systime.begin(); }
    it end() const { return altd.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  time stamp of IMU data in units of time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;//!<  frame angle (same units as laser_shot_*angles) 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t x_gyro;//!<  gyro raw data x-axis in units of gyro_unit 
    #else
    binary::field<int16_t, sc_int16, 64, it> x_gyro;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t y_gyro;//!<  gyro raw data y-axis .. 
    #else
    binary::field<int16_t, sc_int16, 80, it> y_gyro;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t z_gyro;//!<  gyro raw data z-axis .. 
    #else
    binary::field<int16_t, sc_int16, 96, it> z_gyro;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t x_accl;//!<  accelerometer x-axis in units of accl_unit 
    #else
    binary::field<int16_t, sc_int16, 112, it> x_accl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t y_accl;//!<  accelerometer y-axis .. 
    #else
    binary::field<int16_t, sc_int16, 128, it> y_accl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t z_accl;//!<  accelerometer z-axis .. 
    #else
    binary::field<int16_t, sc_int16, 144, it> z_accl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t x_magn;//!<  magn raw data x-axis in units of magn_unit 
    #else
    binary::field<int16_t, sc_int16, 160, it> x_magn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t y_magn;//!<  magn raw data y-axis .. 
    #else
    binary::field<int16_t, sc_int16, 176, it> y_magn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t z_magn;//!<  magn raw data z-axis .. 
    #else
    binary::field<int16_t, sc_int16, 192, it> z_magn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t temp;//!<  ambient temperature from altimeter in units of amb_temp_unit 
    #else
    binary::field<int16_t, sc_int12, 208, it> temp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t altd;//!<  altitude from altimeter in units of altitude_unit 
    #else
    binary::field<int32_t, sc_int20, 220, it> altd;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    S10DOF_data& operator=(const S10DOF_data<ito>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        x_gyro = o.x_gyro;
        y_gyro = o.y_gyro;
        z_gyro = o.z_gyro;
        x_accl = o.x_accl;
        y_accl = o.y_accl;
        z_accl = o.z_accl;
        x_magn = o.x_magn;
        y_magn = o.y_magn;
        z_magn = o.z_magn;
        temp = o.temp;
        altd = o.altd;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct S10DOF_data<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_data<rebind_it> type;
    };

    enum { id_main = 114, id_sub = 0};

    uint32_t         systime;
    uint32_t         frame_angle;
    int16_t          x_gyro;
    int16_t          y_gyro;
    int16_t          z_gyro;
    int16_t          x_accl;
    int16_t          y_accl;
    int16_t          z_accl;
    int16_t          x_magn;
    int16_t          y_magn;
    int16_t          z_magn;
    int16_t          temp;
    int32_t          altd;

    S10DOF_data()
        : systime()
        , frame_angle()
        , x_gyro()
        , y_gyro()
        , z_gyro()
        , x_accl()
        , y_accl()
        , z_accl()
        , x_magn()
        , y_magn()
        , z_magn()
        , temp()
        , altd()
    {}

    template<class it>
    S10DOF_data(const S10DOF_data<it>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        x_gyro = o.x_gyro;
        y_gyro = o.y_gyro;
        z_gyro = o.z_gyro;
        x_accl = o.x_accl;
        y_accl = o.y_accl;
        z_accl = o.z_accl;
        x_magn = o.x_magn;
        y_magn = o.y_magn;
        z_magn = o.z_magn;
        temp = o.temp;
        altd = o.altd;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const S10DOF_data<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.frame_angle;
        s << ", " << x.x_gyro;
        s << ", " << x.y_gyro;
        s << ", " << x.z_gyro;
        s << ", " << x.x_accl;
        s << ", " << x.y_accl;
        s << ", " << x.z_accl;
        s << ", " << x.x_magn;
        s << ", " << x.y_magn;
        s << ", " << x.z_magn;
        s << ", " << x.temp;
        s << ", " << x.altd;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, S10DOF_data<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.x_gyro;
        s >> ',' >> x.y_gyro;
        s >> ',' >> x.z_gyro;
        s >> ',' >> x.x_accl;
        s >> ',' >> x.y_accl;
        s >> ',' >> x.z_accl;
        s >> ',' >> x.x_magn;
        s >> ',' >> x.y_magn;
        s >> ',' >> x.z_magn;
        s >> ',' >> x.temp;
        s >> ',' >> x.altd;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! raw data of 10 deg of freedom sensors

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct S10DOF_data_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_data_1<rebind_it> type;
    };

    typedef it iterator_type;

    S10DOF_data_1(it begin, it end, bool dirty=false)
        : systime(begin)
        , frame_angle(begin)
        , x_gyro(begin)
        , y_gyro(begin)
        , z_gyro(begin)
        , x_accl(begin)
        , y_accl(begin)
        , z_accl(begin)
        , x_magn(begin)
        , y_magn(begin)
        , z_magn(begin)
        , temp(begin)
        , altd(begin)
        , line_angle(begin)
        , frame_speed(begin)
        , flags(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 114, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 336};
    it begin() const { return systime.begin(); }
    it end() const { return flags.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  time stamp of IMU data in units of time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;//!<  frame angle (same units as laser_shot_*angles) 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t x_gyro;//!<  gyro raw data x-axis in units of gyro_unit 
    #else
    binary::field<int16_t, sc_int16, 64, it> x_gyro;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t y_gyro;//!<  gyro raw data y-axis .. 
    #else
    binary::field<int16_t, sc_int16, 80, it> y_gyro;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t z_gyro;//!<  gyro raw data z-axis .. 
    #else
    binary::field<int16_t, sc_int16, 96, it> z_gyro;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t x_accl;//!<  accelerometer x-axis in units of accl_unit 
    #else
    binary::field<int16_t, sc_int16, 112, it> x_accl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t y_accl;//!<  accelerometer y-axis .. 
    #else
    binary::field<int16_t, sc_int16, 128, it> y_accl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t z_accl;//!<  accelerometer z-axis .. 
    #else
    binary::field<int16_t, sc_int16, 144, it> z_accl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t x_magn;//!<  magn raw data x-axis in units of magn_unit 
    #else
    binary::field<int16_t, sc_int16, 160, it> x_magn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t y_magn;//!<  magn raw data y-axis .. 
    #else
    binary::field<int16_t, sc_int16, 176, it> y_magn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t z_magn;//!<  magn raw data z-axis .. 
    #else
    binary::field<int16_t, sc_int16, 192, it> z_magn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t temp;//!<  ambient temperature from altimeter in units of amb_temp_unit 
    #else
    binary::field<int16_t, sc_int12, 208, it> temp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t altd;//!<  altitude from altimeter in units of altitude_unit 
    #else
    binary::field<int32_t, sc_int20, 220, it> altd;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;//!<  line angle (same units as laser_shot_*angles) 
    #else
    binary::field<uint32_t, sc_uint32, 240, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t frame_speed;//!<  frame angle (360/s/units.frame_circle_count) 
    #else
    binary::field<int32_t, sc_int32, 272, it> frame_speed;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t flags;//!<  B0 .. line movement; B1 .. frame movement; B2 .. scan active; B3  first scan frame 
    #else
    binary::field<uint32_t, sc_uint32, 304, it> flags;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    S10DOF_data_1& operator=(const S10DOF_data_1<ito>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        x_gyro = o.x_gyro;
        y_gyro = o.y_gyro;
        z_gyro = o.z_gyro;
        x_accl = o.x_accl;
        y_accl = o.y_accl;
        z_accl = o.z_accl;
        x_magn = o.x_magn;
        y_magn = o.y_magn;
        z_magn = o.z_magn;
        temp = o.temp;
        altd = o.altd;
        line_angle = o.line_angle;
        frame_speed = o.frame_speed;
        flags = o.flags;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct S10DOF_data_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_data_1<rebind_it> type;
    };

    enum { id_main = 114, id_sub = 1};

    uint32_t         systime;
    uint32_t         frame_angle;
    int16_t          x_gyro;
    int16_t          y_gyro;
    int16_t          z_gyro;
    int16_t          x_accl;
    int16_t          y_accl;
    int16_t          z_accl;
    int16_t          x_magn;
    int16_t          y_magn;
    int16_t          z_magn;
    int16_t          temp;
    int32_t          altd;
    uint32_t         line_angle;
    int32_t          frame_speed;
    uint32_t         flags;

    S10DOF_data_1()
        : systime()
        , frame_angle()
        , x_gyro()
        , y_gyro()
        , z_gyro()
        , x_accl()
        , y_accl()
        , z_accl()
        , x_magn()
        , y_magn()
        , z_magn()
        , temp()
        , altd()
        , line_angle()
        , frame_speed()
        , flags()
    {}

    template<class it>
    S10DOF_data_1(const S10DOF_data_1<it>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        x_gyro = o.x_gyro;
        y_gyro = o.y_gyro;
        z_gyro = o.z_gyro;
        x_accl = o.x_accl;
        y_accl = o.y_accl;
        z_accl = o.z_accl;
        x_magn = o.x_magn;
        y_magn = o.y_magn;
        z_magn = o.z_magn;
        temp = o.temp;
        altd = o.altd;
        line_angle = o.line_angle;
        frame_speed = o.frame_speed;
        flags = o.flags;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const S10DOF_data_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.frame_angle;
        s << ", " << x.x_gyro;
        s << ", " << x.y_gyro;
        s << ", " << x.z_gyro;
        s << ", " << x.x_accl;
        s << ", " << x.y_accl;
        s << ", " << x.z_accl;
        s << ", " << x.x_magn;
        s << ", " << x.y_magn;
        s << ", " << x.z_magn;
        s << ", " << x.temp;
        s << ", " << x.altd;
        s << ", " << x.line_angle;
        s << ", " << x.frame_speed;
        s << ", " << x.flags;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, S10DOF_data_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.x_gyro;
        s >> ',' >> x.y_gyro;
        s >> ',' >> x.z_gyro;
        s >> ',' >> x.x_accl;
        s >> ',' >> x.y_accl;
        s >> ',' >> x.z_accl;
        s >> ',' >> x.x_magn;
        s >> ',' >> x.y_magn;
        s >> ',' >> x.z_magn;
        s >> ',' >> x.temp;
        s >> ',' >> x.altd;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_speed;
        s >> ',' >> x.flags;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! specifies the units for the package S10DOF_data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct S10DOF_units
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_units<rebind_it> type;
    };

    typedef it iterator_type;

    S10DOF_units(it begin, it end, bool dirty=false)
        : time_unit(begin)
        , frame_circle_count(begin)
        , gyro_unit(begin)
        , accl_unit(begin)
        , magn_unit(begin)
        , temp_unit(begin)
        , altd_unit(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 115, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 224};
    it begin() const { return time_unit.begin(); }
    it end() const { return altd_unit.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit;//!<  systime, 1 LSB in seconds 
    #else
    binary::field<float, sc_float32, 0, it> time_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_circle_count;//!<  frame_angle, number of LSBs per full rotation 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> frame_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_unit;//!<  xyz_gyro, 1 LSB in radian/sec 
    #else
    binary::field<float, sc_float32, 64, it> gyro_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_unit;//!<  xyz_accl, 1 LSB in 9.81m/sec (in g) 
    #else
    binary::field<float, sc_float32, 96, it> accl_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float magn_unit;//!<  xyz_magn, 1 LSB in nT 
    #else
    binary::field<float, sc_float32, 128, it> magn_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float temp_unit;//!<  temp, 1 LSB in C 
    #else
    binary::field<float, sc_float32, 160, it> temp_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float altd_unit;//!<  altd, 1 LSB in m 
    #else
    binary::field<float, sc_float32, 192, it> altd_unit;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    S10DOF_units& operator=(const S10DOF_units<ito>& o) {
        time_unit = o.time_unit;
        frame_circle_count = o.frame_circle_count;
        gyro_unit = o.gyro_unit;
        accl_unit = o.accl_unit;
        magn_unit = o.magn_unit;
        temp_unit = o.temp_unit;
        altd_unit = o.altd_unit;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct S10DOF_units<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef S10DOF_units<rebind_it> type;
    };

    enum { id_main = 115, id_sub = 0};

    float            time_unit;
    uint32_t         frame_circle_count;
    float            gyro_unit;
    float            accl_unit;
    float            magn_unit;
    float            temp_unit;
    float            altd_unit;

    S10DOF_units()
        : time_unit()
        , frame_circle_count()
        , gyro_unit()
        , accl_unit()
        , magn_unit()
        , temp_unit()
        , altd_unit()
    {}

    template<class it>
    S10DOF_units(const S10DOF_units<it>& o) {
        time_unit = o.time_unit;
        frame_circle_count = o.frame_circle_count;
        gyro_unit = o.gyro_unit;
        accl_unit = o.accl_unit;
        magn_unit = o.magn_unit;
        temp_unit = o.temp_unit;
        altd_unit = o.altd_unit;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const S10DOF_units<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.time_unit;
        s << ", " << x.frame_circle_count;
        s << ", " << x.gyro_unit;
        s << ", " << x.accl_unit;
        s << ", " << x.magn_unit;
        s << ", " << x.temp_unit;
        s << ", " << x.altd_unit;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, S10DOF_units<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.time_unit;
        s >> ',' >> x.frame_circle_count;
        s >> ',' >> x.gyro_unit;
        s >> ',' >> x.accl_unit;
        s >> ',' >> x.magn_unit;
        s >> ',' >> x.temp_unit;
        s >> ',' >> x.altd_unit;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct alert
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef alert<rebind_it> type;
    };

    typedef it iterator_type;

    alert(it begin, it end, bool dirty=false)
        : unit(begin)
        , number(begin)
        , subnumber(begin)
        , type(begin)
        , timestamp(begin)
        , message(begin)
        , flags(begin)
        , info(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 29, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 696};
    it begin() const { return unit.begin(); }
    it end() const { return info.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t unit;//!<  error signaling device unit 
    #else
    binary::field<uint8_t, sc_uint8, 0, it> unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t number;//!<  error number 
    #else
    binary::field<uint16_t, sc_uint16, 8, it> number;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t subnumber;//!<  error sub number 
    #else
    binary::field<uint16_t, sc_uint16, 24, it> subnumber;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t type;//!<  error type (WARNING=1, NORMAL=2, NORMAL_UI=4, FATAL=8) 
    #else
    binary::field<uint16_t, sc_uint16, 40, it> type;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t timestamp;//!<  error timestamp, since the Epoch (00:00:00 UTC, January 1, 1970) [s] 
    #else
    binary::field<uint64_t, sc_uint64, 56, it> timestamp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char message[64];//!<  error message 
    #else
    binary::array<char, 64, sc_char, 120, it> message;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t flags;//!<  bitmapped flags (LASER_OFF=1, MEASUREMENT_STOP=2, MEASUREMENT_ABORT=4, SHUTDOWN=8) 
    #else
    binary::field<uint32_t, sc_uint32, 632, it> flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float info;//!<  additional undefine error information 
    #else
    binary::field<float, sc_float32, 664, it> info;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    alert& operator=(const alert<ito>& o) {
        unit = o.unit;
        number = o.number;
        subnumber = o.subnumber;
        type = o.type;
        timestamp = o.timestamp;
        for(unsigned n=0; n<64; ++n) message[n] = o.message[n];
        flags = o.flags;
        info = o.info;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct alert<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef alert<rebind_it> type;
    };

    enum { id_main = 29, id_sub = 0};

    uint8_t          unit;
    uint16_t         number;
    uint16_t         subnumber;
    uint16_t         type;
    uint64_t         timestamp;
    char             message[64];
    uint32_t         flags;
    float            info;

    alert()
        : unit()
        , number()
        , subnumber()
        , type()
        , timestamp()
        , message()
        , flags()
        , info()
    {}

    template<class it>
    alert(const alert<it>& o) {
        unit = o.unit;
        number = o.number;
        subnumber = o.subnumber;
        type = o.type;
        timestamp = o.timestamp;
        for(unsigned n=0; n<64; ++n) message[n] = o.message[n];
        flags = o.flags;
        info = o.info;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const alert<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.unit;
        s << ", " << x.number;
        s << ", " << x.subnumber;
        s << ", " << x.type;
        s << ", " << x.timestamp;
        s << ", "; write_array(s, 64, x.message);
        s << ", " << x.flags;
        s << ", " << x.info;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, alert<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.unit;
        s >> ',' >> x.number;
        s >> ',' >> x.subnumber;
        s >> ',' >> x.type;
        s >> ',' >> x.timestamp;
        s >> ','; read_array(s, 64, x.message);
        s >> ',' >> x.flags;
        s >> ',' >> x.info;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct arange_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef arange_table<rebind_it> type;
    };

    typedef it iterator_type;

    arange_table(it begin, it end, bool dirty=false)
        : scale(begin)
        , arange(begin, end, arange_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 104, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 4128};
    it begin() const { return scale.begin(); }
    it end() const { return arange.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float scale;
    #else
    binary::field<float, sc_float32, 0, it> scale;
    #endif //DOXYGEN

    std::size_t arange_size;
    enum { arange_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : val(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int16_t val;
        #else
        binary::field<int16_t, sc_int16, 0, it> val;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition arange[256];
    #else
    sequence<arange_table, 16, 32, it> arange;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    arange_table& operator=(const arange_table<ito>& o) {
        scale = o.scale;
        arange_size = o.arange_size;
        arange.clean();
        for(unsigned n=0; n<arange_size; ++n){
            arange[n].val = o.arange[n].val;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct arange_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef arange_table<rebind_it> type;
    };

    enum { id_main = 104, id_sub = 0};

    float            scale;
    std::size_t arange_size;
    enum { arange_max_size = 256 };
    struct sequence_definition {
        int16_t          val;
    } arange[256];

    arange_table()
        : scale()
    {}

    template<class it>
    arange_table(const arange_table<it>& o) {
        scale = o.scale;
        arange_size = o.arange.size();
        for(unsigned n=0; n<arange_size; ++n){
            arange[n].val = o.arange[n].val;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const arange_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.scale;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.arange_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.arange[n].val
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, arange_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.scale;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.arange_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.arange_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.arange[x.arange_size-1].val)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! environmental information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct atmosphere
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere<rebind_it> type;
    };

    typedef it iterator_type;

    atmosphere(it begin, it end, bool dirty=false)
        : temperature(begin)
        , pressure(begin)
        , rel_humidity(begin)
        , rng_scale(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 27, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return temperature.begin(); }
    it end() const { return rng_scale.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float temperature;//!<  user specified average temperature along measurement path [C] 
    #else
    binary::field<float, sc_float32, 0, it> temperature;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pressure;//!<  user specified average pressure along measurment path [mbar] 
    #else
    binary::field<float, sc_float32, 32, it> pressure;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rel_humidity;//!<  user specified relative humidity along measurement path [%] 
    #else
    binary::field<float, sc_float32, 64, it> rel_humidity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_scale;//!<  INTERNAL ONLY conversion factor from range in sample intervals into range in echo packages 
    #else
    binary::field<float, sc_float32, 96, it> rng_scale;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    atmosphere& operator=(const atmosphere<ito>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct atmosphere<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere<rebind_it> type;
    };

    enum { id_main = 27, id_sub = 0};

    float            temperature;
    float            pressure;
    float            rel_humidity;
    float            rng_scale;

    atmosphere()
        : temperature()
        , pressure()
        , rel_humidity()
        , rng_scale()
    {}

    template<class it>
    atmosphere(const atmosphere<it>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const atmosphere<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.temperature;
        s << ", " << x.pressure;
        s << ", " << x.rel_humidity;
        s << ", " << x.rng_scale;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, atmosphere<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.temperature;
        s >> ',' >> x.pressure;
        s >> ',' >> x.rel_humidity;
        s >> ',' >> x.rng_scale;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! extended environmental information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct atmosphere_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere_1<rebind_it> type;
    };

    typedef it iterator_type;

    atmosphere_1(it begin, it end, bool dirty=false)
        : temperature(begin)
        , pressure(begin)
        , rel_humidity(begin)
        , rng_scale(begin)
        , pressure_sl(begin)
        , amsl(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 27, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 192};
    it begin() const { return temperature.begin(); }
    it end() const { return amsl.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float temperature;//!<  user specified average temperature along measurement path [C] 
    #else
    binary::field<float, sc_float32, 0, it> temperature;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pressure;//!<  user specified average pressure along measurment path [mbar] 
    #else
    binary::field<float, sc_float32, 32, it> pressure;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rel_humidity;//!<  user specified relative humidity along measurement path [%] 
    #else
    binary::field<float, sc_float32, 64, it> rel_humidity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_scale;//!<  INTERNAL ONLY conversion factor from range in sample intervals into range in echo packages 
    #else
    binary::field<float, sc_float32, 96, it> rng_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pressure_sl;//!<  user specified atmospheric pressure at sea level [mbar] 
    #else
    binary::field<float, sc_float32, 128, it> pressure_sl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amsl;//!<  user specified height above mean sea level (AMSL) [m] 
    #else
    binary::field<float, sc_float32, 160, it> amsl;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    atmosphere_1& operator=(const atmosphere_1<ito>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
        pressure_sl = o.pressure_sl;
        amsl = o.amsl;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct atmosphere_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere_1<rebind_it> type;
    };

    enum { id_main = 27, id_sub = 1};

    float            temperature;
    float            pressure;
    float            rel_humidity;
    float            rng_scale;
    float            pressure_sl;
    float            amsl;

    atmosphere_1()
        : temperature()
        , pressure()
        , rel_humidity()
        , rng_scale()
        , pressure_sl()
        , amsl()
    {}

    template<class it>
    atmosphere_1(const atmosphere_1<it>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
        pressure_sl = o.pressure_sl;
        amsl = o.amsl;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const atmosphere_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.temperature;
        s << ", " << x.pressure;
        s << ", " << x.rel_humidity;
        s << ", " << x.rng_scale;
        s << ", " << x.pressure_sl;
        s << ", " << x.amsl;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, atmosphere_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.temperature;
        s >> ',' >> x.pressure;
        s >> ',' >> x.rel_humidity;
        s >> ',' >> x.rng_scale;
        s >> ',' >> x.pressure_sl;
        s >> ',' >> x.amsl;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! extended environmental information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct atmosphere_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere_2<rebind_it> type;
    };

    typedef it iterator_type;

    atmosphere_2(it begin, it end, bool dirty=false)
        : temperature(begin)
        , pressure(begin)
        , rel_humidity(begin)
        , rng_scale(begin)
        , pressure_sl(begin)
        , amsl(begin)
        , group_velocity(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 27, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 224};
    it begin() const { return temperature.begin(); }
    it end() const { return group_velocity.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float temperature;//!<  user specified average temperature along measurement path [C] 
    #else
    binary::field<float, sc_float32, 0, it> temperature;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pressure;//!<  user specified average pressure along measurment path [mbar] 
    #else
    binary::field<float, sc_float32, 32, it> pressure;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rel_humidity;//!<  user specified relative humidity along measurement path [%] 
    #else
    binary::field<float, sc_float32, 64, it> rel_humidity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_scale;//!<  INTERNAL ONLY conversion factor from range in sample intervals into range in echo packages 
    #else
    binary::field<float, sc_float32, 96, it> rng_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pressure_sl;//!<  user specified atmospheric pressure at sea level [mbar] 
    #else
    binary::field<float, sc_float32, 128, it> pressure_sl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amsl;//!<  user specified height above mean sea level (AMSL) [m] 
    #else
    binary::field<float, sc_float32, 160, it> amsl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float group_velocity;//!<  effective group velocity of laser beam 
    #else
    binary::field<float, sc_float32, 192, it> group_velocity;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    atmosphere_2& operator=(const atmosphere_2<ito>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
        pressure_sl = o.pressure_sl;
        amsl = o.amsl;
        group_velocity = o.group_velocity;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct atmosphere_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere_2<rebind_it> type;
    };

    enum { id_main = 27, id_sub = 2};

    float            temperature;
    float            pressure;
    float            rel_humidity;
    float            rng_scale;
    float            pressure_sl;
    float            amsl;
    float            group_velocity;

    atmosphere_2()
        : temperature()
        , pressure()
        , rel_humidity()
        , rng_scale()
        , pressure_sl()
        , amsl()
        , group_velocity()
    {}

    template<class it>
    atmosphere_2(const atmosphere_2<it>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
        pressure_sl = o.pressure_sl;
        amsl = o.amsl;
        group_velocity = o.group_velocity;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const atmosphere_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.temperature;
        s << ", " << x.pressure;
        s << ", " << x.rel_humidity;
        s << ", " << x.rng_scale;
        s << ", " << x.pressure_sl;
        s << ", " << x.amsl;
        s << ", " << x.group_velocity;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, atmosphere_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.temperature;
        s >> ',' >> x.pressure;
        s >> ',' >> x.rel_humidity;
        s >> ',' >> x.rng_scale;
        s >> ',' >> x.pressure_sl;
        s >> ',' >> x.amsl;
        s >> ',' >> x.group_velocity;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! extended environmental information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct atmosphere_3
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere_3<rebind_it> type;
    };

    typedef it iterator_type;

    atmosphere_3(it begin, it end, bool dirty=false)
        : temperature(begin)
        , pressure(begin)
        , rel_humidity(begin)
        , rng_scale(begin)
        , pressure_sl(begin)
        , amsl(begin)
        , group_velocity(begin)
        , attenuation(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 27, id_sub = 3};
    #ifndef DOXYGEN
    enum { max_bit_width = 256};
    it begin() const { return temperature.begin(); }
    it end() const { return attenuation.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float temperature;//!<  user specified average temperature along measurement path [C] 
    #else
    binary::field<float, sc_float32, 0, it> temperature;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pressure;//!<  user specified average pressure along measurment path [mbar] 
    #else
    binary::field<float, sc_float32, 32, it> pressure;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rel_humidity;//!<  user specified relative humidity along measurement path [%] 
    #else
    binary::field<float, sc_float32, 64, it> rel_humidity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_scale;//!<  INTERNAL ONLY conversion factor from range in sample intervals into range in echo packages 
    #else
    binary::field<float, sc_float32, 96, it> rng_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pressure_sl;//!<  user specified atmospheric pressure at sea level [mbar] 
    #else
    binary::field<float, sc_float32, 128, it> pressure_sl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amsl;//!<  user specified height above mean sea level (AMSL) [m] 
    #else
    binary::field<float, sc_float32, 160, it> amsl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float group_velocity;//!<  effective group velocity of laser beam 
    #else
    binary::field<float, sc_float32, 192, it> group_velocity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float attenuation;//!<  atmospheric attenuation, used for correction of reflectance [1/km] 
    #else
    binary::field<float, sc_float32, 224, it> attenuation;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    atmosphere_3& operator=(const atmosphere_3<ito>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
        pressure_sl = o.pressure_sl;
        amsl = o.amsl;
        group_velocity = o.group_velocity;
        attenuation = o.attenuation;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct atmosphere_3<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere_3<rebind_it> type;
    };

    enum { id_main = 27, id_sub = 3};

    float            temperature;
    float            pressure;
    float            rel_humidity;
    float            rng_scale;
    float            pressure_sl;
    float            amsl;
    float            group_velocity;
    float            attenuation;

    atmosphere_3()
        : temperature()
        , pressure()
        , rel_humidity()
        , rng_scale()
        , pressure_sl()
        , amsl()
        , group_velocity()
        , attenuation()
    {}

    template<class it>
    atmosphere_3(const atmosphere_3<it>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
        pressure_sl = o.pressure_sl;
        amsl = o.amsl;
        group_velocity = o.group_velocity;
        attenuation = o.attenuation;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const atmosphere_3<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.temperature;
        s << ", " << x.pressure;
        s << ", " << x.rel_humidity;
        s << ", " << x.rng_scale;
        s << ", " << x.pressure_sl;
        s << ", " << x.amsl;
        s << ", " << x.group_velocity;
        s << ", " << x.attenuation;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, atmosphere_3<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.temperature;
        s >> ',' >> x.pressure;
        s >> ',' >> x.rel_humidity;
        s >> ',' >> x.rng_scale;
        s >> ',' >> x.pressure_sl;
        s >> ',' >> x.amsl;
        s >> ',' >> x.group_velocity;
        s >> ',' >> x.attenuation;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! extended environmental information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct atmosphere_4
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere_4<rebind_it> type;
    };

    typedef it iterator_type;

    atmosphere_4(it begin, it end, bool dirty=false)
        : temperature(begin)
        , pressure(begin)
        , rel_humidity(begin)
        , rng_scale(begin)
        , pressure_sl(begin)
        , amsl(begin)
        , group_velocity(begin)
        , attenuation(begin)
        , wavelength(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 27, id_sub = 4};
    #ifndef DOXYGEN
    enum { max_bit_width = 288};
    it begin() const { return temperature.begin(); }
    it end() const { return wavelength.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float temperature;//!<  user specified average temperature along measurement path [C] 
    #else
    binary::field<float, sc_float32, 0, it> temperature;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pressure;//!<  user specified average pressure along measurment path [mbar] 
    #else
    binary::field<float, sc_float32, 32, it> pressure;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rel_humidity;//!<  user specified relative humidity along measurement path [%] 
    #else
    binary::field<float, sc_float32, 64, it> rel_humidity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_scale;//!<  INTERNAL ONLY conversion factor from range in sample intervals into range in echo packages 
    #else
    binary::field<float, sc_float32, 96, it> rng_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pressure_sl;//!<  user specified atmospheric pressure at sea level [mbar] 
    #else
    binary::field<float, sc_float32, 128, it> pressure_sl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amsl;//!<  user specified height above mean sea level (AMSL) [m] 
    #else
    binary::field<float, sc_float32, 160, it> amsl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float group_velocity;//!<  effective group velocity of laser beam 
    #else
    binary::field<float, sc_float32, 192, it> group_velocity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float attenuation;//!<  atmospheric attenuation, used for correction of reflectance [1/km] 
    #else
    binary::field<float, sc_float32, 224, it> attenuation;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float wavelength;//!<  wavelength of the laser in units of nm 
    #else
    binary::field<float, sc_float32, 256, it> wavelength;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    atmosphere_4& operator=(const atmosphere_4<ito>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
        pressure_sl = o.pressure_sl;
        amsl = o.amsl;
        group_velocity = o.group_velocity;
        attenuation = o.attenuation;
        wavelength = o.wavelength;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct atmosphere_4<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef atmosphere_4<rebind_it> type;
    };

    enum { id_main = 27, id_sub = 4};

    float            temperature;
    float            pressure;
    float            rel_humidity;
    float            rng_scale;
    float            pressure_sl;
    float            amsl;
    float            group_velocity;
    float            attenuation;
    float            wavelength;

    atmosphere_4()
        : temperature()
        , pressure()
        , rel_humidity()
        , rng_scale()
        , pressure_sl()
        , amsl()
        , group_velocity()
        , attenuation()
        , wavelength()
    {}

    template<class it>
    atmosphere_4(const atmosphere_4<it>& o) {
        temperature = o.temperature;
        pressure = o.pressure;
        rel_humidity = o.rel_humidity;
        rng_scale = o.rng_scale;
        pressure_sl = o.pressure_sl;
        amsl = o.amsl;
        group_velocity = o.group_velocity;
        attenuation = o.attenuation;
        wavelength = o.wavelength;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const atmosphere_4<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.temperature;
        s << ", " << x.pressure;
        s << ", " << x.rel_humidity;
        s << ", " << x.rng_scale;
        s << ", " << x.pressure_sl;
        s << ", " << x.amsl;
        s << ", " << x.group_velocity;
        s << ", " << x.attenuation;
        s << ", " << x.wavelength;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, atmosphere_4<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.temperature;
        s >> ',' >> x.pressure;
        s >> ',' >> x.rel_humidity;
        s >> ',' >> x.rng_scale;
        s >> ',' >> x.pressure_sl;
        s >> ',' >> x.amsl;
        s >> ',' >> x.group_velocity;
        s >> ',' >> x.attenuation;
        s >> ',' >> x.wavelength;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct avg_fine_ref_dg
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef avg_fine_ref_dg<rebind_it> type;
    };

    typedef it iterator_type;

    avg_fine_ref_dg(it begin, it end, bool dirty=false)
        : packet_nr(begin)
        , slice_nr(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50006, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32800};
    it begin() const { return packet_nr.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t packet_nr;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> packet_nr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t slice_nr;
    #else
    binary::field<uint8_t, sc_uint8, 8, it> slice_nr;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 1024 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sample(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t sample;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> sample;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[1024];
    #else
    sequence<avg_fine_ref_dg, 32, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    avg_fine_ref_dg& operator=(const avg_fine_ref_dg<ito>& o) {
        packet_nr = o.packet_nr;
        slice_nr = o.slice_nr;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct avg_fine_ref_dg<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef avg_fine_ref_dg<rebind_it> type;
    };

    enum { id_main = 50006, id_sub = 0};

    uint8_t          packet_nr;
    uint8_t          slice_nr;
    std::size_t data_size;
    enum { data_max_size = 1024 };
    struct sequence_definition {
        uint32_t         sample;
    } data[1024];

    avg_fine_ref_dg()
        : packet_nr()
        , slice_nr()
    {}

    template<class it>
    avg_fine_ref_dg(const avg_fine_ref_dg<it>& o) {
        packet_nr = o.packet_nr;
        slice_nr = o.slice_nr;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const avg_fine_ref_dg<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.packet_nr;
        s << ", " << x.slice_nr;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sample
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, avg_fine_ref_dg<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.packet_nr;
        s >> ',' >> x.slice_nr;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sample)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! laser beam description

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct beam_geometry
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef beam_geometry<rebind_it> type;
    };

    typedef it iterator_type;

    beam_geometry(it begin, it end, bool dirty=false)
        : beam_exit_diameter(begin)
        , beam_divergence(begin)
        , beam_focus(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 3, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return beam_exit_diameter.begin(); }
    it end() const { return beam_focus.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float beam_exit_diameter;//!<  beam width at exit aperture [m] 
    #else
    binary::field<float, sc_float32, 0, it> beam_exit_diameter;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float beam_divergence;//!<  beam divergence in far field [rad] 
    #else
    binary::field<float, sc_float32, 32, it> beam_divergence;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float beam_focus;//!<  INTERNAL ONLY distance of beam waist from origin [m] 
    #else
    binary::field<float, sc_float32, 64, it> beam_focus;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    beam_geometry& operator=(const beam_geometry<ito>& o) {
        beam_exit_diameter = o.beam_exit_diameter;
        beam_divergence = o.beam_divergence;
        beam_focus = o.beam_focus;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct beam_geometry<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef beam_geometry<rebind_it> type;
    };

    enum { id_main = 3, id_sub = 0};

    float            beam_exit_diameter;
    float            beam_divergence;
    float            beam_focus;

    beam_geometry()
        : beam_exit_diameter()
        , beam_divergence()
        , beam_focus()
    {}

    template<class it>
    beam_geometry(const beam_geometry<it>& o) {
        beam_exit_diameter = o.beam_exit_diameter;
        beam_divergence = o.beam_divergence;
        beam_focus = o.beam_focus;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const beam_geometry<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.beam_exit_diameter;
        s << ", " << x.beam_divergence;
        s << ", " << x.beam_focus;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, beam_geometry<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.beam_exit_diameter;
        s >> ',' >> x.beam_divergence;
        s >> ',' >> x.beam_focus;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! modelling biaxial shift of cog of range measurement in the near range

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct biaxial_geometry
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef biaxial_geometry<rebind_it> type;
    };

    typedef it iterator_type;

    biaxial_geometry(it begin, it end, bool dirty=false)
        : aperture_direction(begin)
        , biax_shift(begin, end, biax_shift_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 76, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1120};
    it begin() const { return aperture_direction.begin(); }
    it end() const { return biax_shift.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float aperture_direction[3];
    #else
    binary::array<float, 3, sc_float32, 0, it> aperture_direction;
    #endif //DOXYGEN

    std::size_t biax_shift_size;
    enum { biax_shift_max_size = 16 };
    //! shift towards receiver aperture

    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : pivot(begin, begin_bit)
            , value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float pivot;//!<  pivot value 
        #else
        binary::field<float, sc_float32, 0, it> pivot;
        #endif
        #ifdef DOXYGEN
        float value;//!<  shift in range of 0..1 
        #else
        binary::field<float, sc_float32, 32, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition biax_shift[16];
    #else
    sequence<biaxial_geometry, 64, 96, it> biax_shift;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    biaxial_geometry& operator=(const biaxial_geometry<ito>& o) {
        for(unsigned n=0; n<3; ++n) aperture_direction[n] = o.aperture_direction[n];
        biax_shift_size = o.biax_shift_size;
        biax_shift.clean();
        for(unsigned n=0; n<biax_shift_size; ++n){
            biax_shift[n].pivot = o.biax_shift[n].pivot;
            biax_shift[n].value = o.biax_shift[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct biaxial_geometry<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef biaxial_geometry<rebind_it> type;
    };

    enum { id_main = 76, id_sub = 0};

    float            aperture_direction[3];
    std::size_t biax_shift_size;
    enum { biax_shift_max_size = 16 };
    struct sequence_definition {
        float            pivot;
        float            value;
    } biax_shift[16];

    biaxial_geometry()
        : aperture_direction()
    {}

    template<class it>
    biaxial_geometry(const biaxial_geometry<it>& o) {
        for(unsigned n=0; n<3; ++n) aperture_direction[n] = o.aperture_direction[n];
        biax_shift_size = o.biax_shift.size();
        for(unsigned n=0; n<biax_shift_size; ++n){
            biax_shift[n].pivot = o.biax_shift[n].pivot;
            biax_shift[n].value = o.biax_shift[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const biaxial_geometry<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.aperture_direction);

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.biax_shift_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.biax_shift[n].pivot
            << ", " << x.biax_shift[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, biaxial_geometry<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.aperture_direction);

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.biax_shift_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.biax_shift_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.biax_shift[x.biax_shift_size-1].pivot)
            >> ',' >> (x.biax_shift[x.biax_shift_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct blob_uint32
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef blob_uint32<rebind_it> type;
    };

    typedef it iterator_type;

    blob_uint32(it begin, it end, bool dirty=false)
        : type(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 58, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8388640};
    it begin() const { return type.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t type;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> type;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t value;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[262144];
    #else
    sequence<blob_uint32, 32, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    blob_uint32& operator=(const blob_uint32<ito>& o) {
        type = o.type;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct blob_uint32<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef blob_uint32<rebind_it> type;
    };

    enum { id_main = 58, id_sub = 0};

    uint32_t         type;
    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition {
        uint32_t         value;
    } data[262144];

    blob_uint32()
        : type()
    {}

    template<class it>
    blob_uint32(const blob_uint32<it>& o) {
        type = o.type;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const blob_uint32<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.type;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, blob_uint32<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.type;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct blob_uint8
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef blob_uint8<rebind_it> type;
    };

    typedef it iterator_type;

    blob_uint8(it begin, it end, bool dirty=false)
        : type(begin)
        , oddity(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 59, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8388640};
    it begin() const { return type.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t type;
    #else
    binary::field<uint32_t, sc_uint30, 0, it> type;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t oddity;
    #else
    binary::field<uint8_t, sc_uint2, 30, it> oddity;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 1048576 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint8_t value;
        #else
        binary::field<uint8_t, sc_uint8, 0, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[1048576];
    #else
    sequence<blob_uint8, 8, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    blob_uint8& operator=(const blob_uint8<ito>& o) {
        type = o.type;
        oddity = o.oddity;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct blob_uint8<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef blob_uint8<rebind_it> type;
    };

    enum { id_main = 59, id_sub = 0};

    uint32_t         type;
    uint8_t          oddity;
    std::size_t data_size;
    enum { data_max_size = 1048576 };
    struct sequence_definition {
        uint8_t          value;
    } data[1048576];

    blob_uint8()
        : type()
        , oddity()
    {}

    template<class it>
    blob_uint8(const blob_uint8<it>& o) {
        type = o.type;
        oddity = o.oddity;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const blob_uint8<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.type;
        s << ", " << x.oddity;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, blob_uint8<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.type;
        s >> ',' >> x.oddity;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct calib_2D_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef calib_2D_table<rebind_it> type;
    };

    typedef it iterator_type;

    calib_2D_table(it begin, it end, bool dirty=false)
        : table_kind(begin)
        , num_rows(begin)
        , num_columns(begin)
        , row_axis_scale(begin)
        , row_axis_offset(begin)
        , column_axis_scale(begin)
        , column_axis_offset(begin)
        , content_axis_scale(begin)
        , content_axis_offset(begin)
        , table(begin, end, table_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 146, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8389040};
    it begin() const { return table_kind.begin(); }
    it end() const { return table.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t table_kind;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> table_kind;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t num_rows;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> num_rows;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t num_columns;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> num_columns;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double row_axis_scale;
    #else
    binary::field<double, sc_float64, 48, it> row_axis_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double row_axis_offset;
    #else
    binary::field<double, sc_float64, 112, it> row_axis_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double column_axis_scale;
    #else
    binary::field<double, sc_float64, 176, it> column_axis_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double column_axis_offset;
    #else
    binary::field<double, sc_float64, 240, it> column_axis_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double content_axis_scale;
    #else
    binary::field<double, sc_float64, 304, it> content_axis_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double content_axis_offset;
    #else
    binary::field<double, sc_float64, 368, it> content_axis_offset;
    #endif //DOXYGEN

    std::size_t table_size;
    enum { table_max_size = 524288 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t value;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition table[524288];
    #else
    sequence<calib_2D_table, 16, 432, it> table;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    calib_2D_table& operator=(const calib_2D_table<ito>& o) {
        table_kind = o.table_kind;
        num_rows = o.num_rows;
        num_columns = o.num_columns;
        row_axis_scale = o.row_axis_scale;
        row_axis_offset = o.row_axis_offset;
        column_axis_scale = o.column_axis_scale;
        column_axis_offset = o.column_axis_offset;
        content_axis_scale = o.content_axis_scale;
        content_axis_offset = o.content_axis_offset;
        table_size = o.table_size;
        table.clean();
        for(unsigned n=0; n<table_size; ++n){
            table[n].value = o.table[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct calib_2D_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef calib_2D_table<rebind_it> type;
    };

    enum { id_main = 146, id_sub = 0};

    uint16_t         table_kind;
    uint16_t         num_rows;
    uint16_t         num_columns;
    double           row_axis_scale;
    double           row_axis_offset;
    double           column_axis_scale;
    double           column_axis_offset;
    double           content_axis_scale;
    double           content_axis_offset;
    std::size_t table_size;
    enum { table_max_size = 524288 };
    struct sequence_definition {
        uint16_t         value;
    } table[524288];

    calib_2D_table()
        : table_kind()
        , num_rows()
        , num_columns()
        , row_axis_scale()
        , row_axis_offset()
        , column_axis_scale()
        , column_axis_offset()
        , content_axis_scale()
        , content_axis_offset()
    {}

    template<class it>
    calib_2D_table(const calib_2D_table<it>& o) {
        table_kind = o.table_kind;
        num_rows = o.num_rows;
        num_columns = o.num_columns;
        row_axis_scale = o.row_axis_scale;
        row_axis_offset = o.row_axis_offset;
        column_axis_scale = o.column_axis_scale;
        column_axis_offset = o.column_axis_offset;
        content_axis_scale = o.content_axis_scale;
        content_axis_offset = o.content_axis_offset;
        table_size = o.table.size();
        for(unsigned n=0; n<table_size; ++n){
            table[n].value = o.table[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const calib_2D_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.table_kind;
        s << ", " << x.num_rows;
        s << ", " << x.num_columns;
        s << ", " << x.row_axis_scale;
        s << ", " << x.row_axis_offset;
        s << ", " << x.column_axis_scale;
        s << ", " << x.column_axis_offset;
        s << ", " << x.content_axis_scale;
        s << ", " << x.content_axis_offset;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.table_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.table[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, calib_2D_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.table_kind;
        s >> ',' >> x.num_rows;
        s >> ',' >> x.num_columns;
        s >> ',' >> x.row_axis_scale;
        s >> ',' >> x.row_axis_offset;
        s >> ',' >> x.column_axis_scale;
        s >> ',' >> x.column_axis_offset;
        s >> ',' >> x.content_axis_scale;
        s >> ',' >> x.content_axis_offset;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.table_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.table_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.table[x.table_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct calib_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef calib_table<rebind_it> type;
    };

    typedef it iterator_type;

    calib_table(it begin, it end, bool dirty=false)
        : table_kind(begin)
        , abscissa_scale(begin)
        , abscissa_offset(begin)
        , ordinate_scale(begin)
        , ordinate_offset(begin)
        , table(begin, end, table_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 82, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 33040};
    it begin() const { return table_kind.begin(); }
    it end() const { return table.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t table_kind;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> table_kind;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double abscissa_scale;
    #else
    binary::field<double, sc_float64, 16, it> abscissa_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double abscissa_offset;
    #else
    binary::field<double, sc_float64, 80, it> abscissa_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double ordinate_scale;
    #else
    binary::field<double, sc_float64, 144, it> ordinate_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double ordinate_offset;
    #else
    binary::field<double, sc_float64, 208, it> ordinate_offset;
    #endif //DOXYGEN

    std::size_t table_size;
    enum { table_max_size = 1024 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : abscissa(begin, begin_bit)
            , ordinate(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int16_t abscissa;
        #else
        binary::field<int16_t, sc_int16, 0, it> abscissa;
        #endif
        #ifdef DOXYGEN
        int16_t ordinate;
        #else
        binary::field<int16_t, sc_int16, 16, it> ordinate;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition table[1024];
    #else
    sequence<calib_table, 32, 272, it> table;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    calib_table& operator=(const calib_table<ito>& o) {
        table_kind = o.table_kind;
        abscissa_scale = o.abscissa_scale;
        abscissa_offset = o.abscissa_offset;
        ordinate_scale = o.ordinate_scale;
        ordinate_offset = o.ordinate_offset;
        table_size = o.table_size;
        table.clean();
        for(unsigned n=0; n<table_size; ++n){
            table[n].abscissa = o.table[n].abscissa;
            table[n].ordinate = o.table[n].ordinate;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct calib_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef calib_table<rebind_it> type;
    };

    enum { id_main = 82, id_sub = 0};

    uint16_t         table_kind;
    double           abscissa_scale;
    double           abscissa_offset;
    double           ordinate_scale;
    double           ordinate_offset;
    std::size_t table_size;
    enum { table_max_size = 1024 };
    struct sequence_definition {
        int16_t          abscissa;
        int16_t          ordinate;
    } table[1024];

    calib_table()
        : table_kind()
        , abscissa_scale()
        , abscissa_offset()
        , ordinate_scale()
        , ordinate_offset()
    {}

    template<class it>
    calib_table(const calib_table<it>& o) {
        table_kind = o.table_kind;
        abscissa_scale = o.abscissa_scale;
        abscissa_offset = o.abscissa_offset;
        ordinate_scale = o.ordinate_scale;
        ordinate_offset = o.ordinate_offset;
        table_size = o.table.size();
        for(unsigned n=0; n<table_size; ++n){
            table[n].abscissa = o.table[n].abscissa;
            table[n].ordinate = o.table[n].ordinate;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const calib_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.table_kind;
        s << ", " << x.abscissa_scale;
        s << ", " << x.abscissa_offset;
        s << ", " << x.ordinate_scale;
        s << ", " << x.ordinate_offset;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.table_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.table[n].abscissa
            << ", " << x.table[n].ordinate
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, calib_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.table_kind;
        s >> ',' >> x.abscissa_scale;
        s >> ',' >> x.abscissa_offset;
        s >> ',' >> x.ordinate_scale;
        s >> ',' >> x.ordinate_offset;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.table_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.table_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.table[x.table_size-1].abscissa)
            >> ',' >> (x.table[x.table_size-1].ordinate)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct calib_waveform
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef calib_waveform<rebind_it> type;
    };

    typedef it iterator_type;

    calib_waveform(it begin, it end, bool dirty=false)
        : endianess(begin)
        , n_shp_samples(begin)
        , R(begin)
        , B(begin)
        , K(begin)
        , P(begin)
        , N(begin)
        , sum_shp_samples(begin)
        , db_start(begin)
        , refpuls_position(begin)
        , avg_npulse(begin)
        , reference0(begin)
        , reference1(begin)
        , reference2(begin)
        , reference3(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50100, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 131520};
    it begin() const { return endianess.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t endianess;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> endianess;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t n_shp_samples;
    #else
    binary::field<uint8_t, sc_uint8, 16, it> n_shp_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t R;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> R;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t B;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> B;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t K;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> K;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t P;
    #else
    binary::field<uint32_t, sc_uint32, 128, it> P;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t N;
    #else
    binary::field<uint32_t, sc_uint32, 160, it> N;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t sum_shp_samples;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> sum_shp_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t db_start;
    #else
    binary::field<uint32_t, sc_uint32, 224, it> db_start;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t refpuls_position;
    #else
    binary::field<uint32_t, sc_uint32, 256, it> refpuls_position;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t avg_npulse;
    #else
    binary::field<uint32_t, sc_uint32, 288, it> avg_npulse;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference0;
    #else
    binary::field<uint32_t, sc_uint32, 320, it> reference0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference1;
    #else
    binary::field<uint32_t, sc_uint32, 352, it> reference1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference2;
    #else
    binary::field<uint32_t, sc_uint32, 384, it> reference2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference3;
    #else
    binary::field<uint32_t, sc_uint32, 416, it> reference3;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 4096 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sums(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t sums;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> sums;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[4096];
    #else
    sequence<calib_waveform, 32, 448, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    calib_waveform& operator=(const calib_waveform<ito>& o) {
        endianess = o.endianess;
        n_shp_samples = o.n_shp_samples;
        R = o.R;
        B = o.B;
        K = o.K;
        P = o.P;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        db_start = o.db_start;
        refpuls_position = o.refpuls_position;
        avg_npulse = o.avg_npulse;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sums = o.data[n].sums;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct calib_waveform<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef calib_waveform<rebind_it> type;
    };

    enum { id_main = 50100, id_sub = 0};

    uint16_t         endianess;
    uint8_t          n_shp_samples;
    uint32_t         R;
    uint32_t         B;
    uint32_t         K;
    uint32_t         P;
    uint32_t         N;
    uint32_t         sum_shp_samples;
    uint32_t         db_start;
    uint32_t         refpuls_position;
    uint32_t         avg_npulse;
    uint32_t         reference0;
    uint32_t         reference1;
    uint32_t         reference2;
    uint32_t         reference3;
    std::size_t data_size;
    enum { data_max_size = 4096 };
    struct sequence_definition {
        uint32_t         sums;
    } data[4096];

    calib_waveform()
        : endianess()
        , n_shp_samples()
        , R()
        , B()
        , K()
        , P()
        , N()
        , sum_shp_samples()
        , db_start()
        , refpuls_position()
        , avg_npulse()
        , reference0()
        , reference1()
        , reference2()
        , reference3()
    {}

    template<class it>
    calib_waveform(const calib_waveform<it>& o) {
        endianess = o.endianess;
        n_shp_samples = o.n_shp_samples;
        R = o.R;
        B = o.B;
        K = o.K;
        P = o.P;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        db_start = o.db_start;
        refpuls_position = o.refpuls_position;
        avg_npulse = o.avg_npulse;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sums = o.data[n].sums;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const calib_waveform<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.endianess;
        s << ", " << x.n_shp_samples;
        s << ", " << x.R;
        s << ", " << x.B;
        s << ", " << x.K;
        s << ", " << x.P;
        s << ", " << x.N;
        s << ", " << x.sum_shp_samples;
        s << ", " << x.db_start;
        s << ", " << x.refpuls_position;
        s << ", " << x.avg_npulse;
        s << ", " << x.reference0;
        s << ", " << x.reference1;
        s << ", " << x.reference2;
        s << ", " << x.reference3;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sums
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, calib_waveform<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.endianess;
        s >> ',' >> x.n_shp_samples;
        s >> ',' >> x.R;
        s >> ',' >> x.B;
        s >> ',' >> x.K;
        s >> ',' >> x.P;
        s >> ',' >> x.N;
        s >> ',' >> x.sum_shp_samples;
        s >> ',' >> x.db_start;
        s >> ',' >> x.refpuls_position;
        s >> ',' >> x.avg_npulse;
        s >> ',' >> x.reference0;
        s >> ',' >> x.reference1;
        s >> ',' >> x.reference2;
        s >> ',' >> x.reference3;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sums)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct calib_waveform_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef calib_waveform_1<rebind_it> type;
    };

    typedef it iterator_type;

    calib_waveform_1(it begin, it end, bool dirty=false)
        : endianess(begin)
        , n_shp_samples(begin)
        , R(begin)
        , B(begin)
        , K(begin)
        , P(begin)
        , N(begin)
        , sum_shp_samples(begin)
        , db_start(begin)
        , refpuls_position(begin)
        , avg_npulse(begin)
        , reference0(begin)
        , reference1(begin)
        , reference2(begin)
        , reference3(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50104, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 131520};
    it begin() const { return endianess.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t endianess;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> endianess;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t n_shp_samples;
    #else
    binary::field<uint8_t, sc_uint8, 16, it> n_shp_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t R;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> R;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t B;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> B;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t K;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> K;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t P;
    #else
    binary::field<uint32_t, sc_uint32, 128, it> P;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t N;
    #else
    binary::field<uint32_t, sc_uint32, 160, it> N;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t sum_shp_samples;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> sum_shp_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t db_start;
    #else
    binary::field<uint32_t, sc_uint32, 224, it> db_start;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t refpuls_position;
    #else
    binary::field<uint32_t, sc_uint32, 256, it> refpuls_position;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t avg_npulse;
    #else
    binary::field<uint32_t, sc_uint32, 288, it> avg_npulse;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference0;
    #else
    binary::field<uint32_t, sc_uint32, 320, it> reference0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference1;
    #else
    binary::field<uint32_t, sc_uint32, 352, it> reference1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference2;
    #else
    binary::field<uint32_t, sc_uint32, 384, it> reference2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference3;
    #else
    binary::field<uint32_t, sc_uint32, 416, it> reference3;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 4096 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sums(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t sums;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> sums;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[4096];
    #else
    sequence<calib_waveform_1, 32, 448, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    calib_waveform_1& operator=(const calib_waveform_1<ito>& o) {
        endianess = o.endianess;
        n_shp_samples = o.n_shp_samples;
        R = o.R;
        B = o.B;
        K = o.K;
        P = o.P;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        db_start = o.db_start;
        refpuls_position = o.refpuls_position;
        avg_npulse = o.avg_npulse;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sums = o.data[n].sums;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct calib_waveform_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef calib_waveform_1<rebind_it> type;
    };

    enum { id_main = 50104, id_sub = 0};

    uint16_t         endianess;
    uint8_t          n_shp_samples;
    uint32_t         R;
    uint32_t         B;
    uint32_t         K;
    uint32_t         P;
    uint32_t         N;
    uint32_t         sum_shp_samples;
    uint32_t         db_start;
    uint32_t         refpuls_position;
    uint32_t         avg_npulse;
    uint32_t         reference0;
    uint32_t         reference1;
    uint32_t         reference2;
    uint32_t         reference3;
    std::size_t data_size;
    enum { data_max_size = 4096 };
    struct sequence_definition {
        uint32_t         sums;
    } data[4096];

    calib_waveform_1()
        : endianess()
        , n_shp_samples()
        , R()
        , B()
        , K()
        , P()
        , N()
        , sum_shp_samples()
        , db_start()
        , refpuls_position()
        , avg_npulse()
        , reference0()
        , reference1()
        , reference2()
        , reference3()
    {}

    template<class it>
    calib_waveform_1(const calib_waveform_1<it>& o) {
        endianess = o.endianess;
        n_shp_samples = o.n_shp_samples;
        R = o.R;
        B = o.B;
        K = o.K;
        P = o.P;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        db_start = o.db_start;
        refpuls_position = o.refpuls_position;
        avg_npulse = o.avg_npulse;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sums = o.data[n].sums;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const calib_waveform_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.endianess;
        s << ", " << x.n_shp_samples;
        s << ", " << x.R;
        s << ", " << x.B;
        s << ", " << x.K;
        s << ", " << x.P;
        s << ", " << x.N;
        s << ", " << x.sum_shp_samples;
        s << ", " << x.db_start;
        s << ", " << x.refpuls_position;
        s << ", " << x.avg_npulse;
        s << ", " << x.reference0;
        s << ", " << x.reference1;
        s << ", " << x.reference2;
        s << ", " << x.reference3;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sums
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, calib_waveform_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.endianess;
        s >> ',' >> x.n_shp_samples;
        s >> ',' >> x.R;
        s >> ',' >> x.B;
        s >> ',' >> x.K;
        s >> ',' >> x.P;
        s >> ',' >> x.N;
        s >> ',' >> x.sum_shp_samples;
        s >> ',' >> x.db_start;
        s >> ',' >> x.refpuls_position;
        s >> ',' >> x.avg_npulse;
        s >> ',' >> x.reference0;
        s >> ',' >> x.reference1;
        s >> ',' >> x.reference2;
        s >> ',' >> x.reference3;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sums)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct calib_waveform_L2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef calib_waveform_L2<rebind_it> type;
    };

    typedef it iterator_type;

    calib_waveform_L2(it begin, it end, bool dirty=false)
        : endianess(begin)
        , n_shp_samples(begin)
        , R(begin)
        , B(begin)
        , K(begin)
        , P(begin)
        , N(begin)
        , sum_shp_samples(begin)
        , db_start(begin)
        , refpuls_position(begin)
        , avg_npulse(begin)
        , reference0(begin)
        , reference1(begin)
        , reference2(begin)
        , reference3(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50103, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 393664};
    it begin() const { return endianess.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t endianess;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> endianess;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t n_shp_samples;
    #else
    binary::field<uint8_t, sc_uint8, 16, it> n_shp_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t R;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> R;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t B;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> B;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t K;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> K;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t P;
    #else
    binary::field<uint32_t, sc_uint32, 128, it> P;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t N;
    #else
    binary::field<uint32_t, sc_uint32, 160, it> N;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t sum_shp_samples;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> sum_shp_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t db_start;
    #else
    binary::field<uint32_t, sc_uint32, 224, it> db_start;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t refpuls_position;
    #else
    binary::field<uint32_t, sc_uint32, 256, it> refpuls_position;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t avg_npulse;
    #else
    binary::field<uint32_t, sc_uint32, 288, it> avg_npulse;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference0;
    #else
    binary::field<uint32_t, sc_uint32, 320, it> reference0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference1;
    #else
    binary::field<uint32_t, sc_uint32, 352, it> reference1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference2;
    #else
    binary::field<uint32_t, sc_uint32, 384, it> reference2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference3;
    #else
    binary::field<uint32_t, sc_uint32, 416, it> reference3;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 12288 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sums(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t sums;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> sums;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[12288];
    #else
    sequence<calib_waveform_L2, 32, 448, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    calib_waveform_L2& operator=(const calib_waveform_L2<ito>& o) {
        endianess = o.endianess;
        n_shp_samples = o.n_shp_samples;
        R = o.R;
        B = o.B;
        K = o.K;
        P = o.P;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        db_start = o.db_start;
        refpuls_position = o.refpuls_position;
        avg_npulse = o.avg_npulse;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sums = o.data[n].sums;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct calib_waveform_L2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef calib_waveform_L2<rebind_it> type;
    };

    enum { id_main = 50103, id_sub = 0};

    uint16_t         endianess;
    uint8_t          n_shp_samples;
    uint32_t         R;
    uint32_t         B;
    uint32_t         K;
    uint32_t         P;
    uint32_t         N;
    uint32_t         sum_shp_samples;
    uint32_t         db_start;
    uint32_t         refpuls_position;
    uint32_t         avg_npulse;
    uint32_t         reference0;
    uint32_t         reference1;
    uint32_t         reference2;
    uint32_t         reference3;
    std::size_t data_size;
    enum { data_max_size = 12288 };
    struct sequence_definition {
        uint32_t         sums;
    } data[12288];

    calib_waveform_L2()
        : endianess()
        , n_shp_samples()
        , R()
        , B()
        , K()
        , P()
        , N()
        , sum_shp_samples()
        , db_start()
        , refpuls_position()
        , avg_npulse()
        , reference0()
        , reference1()
        , reference2()
        , reference3()
    {}

    template<class it>
    calib_waveform_L2(const calib_waveform_L2<it>& o) {
        endianess = o.endianess;
        n_shp_samples = o.n_shp_samples;
        R = o.R;
        B = o.B;
        K = o.K;
        P = o.P;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        db_start = o.db_start;
        refpuls_position = o.refpuls_position;
        avg_npulse = o.avg_npulse;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sums = o.data[n].sums;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const calib_waveform_L2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.endianess;
        s << ", " << x.n_shp_samples;
        s << ", " << x.R;
        s << ", " << x.B;
        s << ", " << x.K;
        s << ", " << x.P;
        s << ", " << x.N;
        s << ", " << x.sum_shp_samples;
        s << ", " << x.db_start;
        s << ", " << x.refpuls_position;
        s << ", " << x.avg_npulse;
        s << ", " << x.reference0;
        s << ", " << x.reference1;
        s << ", " << x.reference2;
        s << ", " << x.reference3;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sums
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, calib_waveform_L2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.endianess;
        s >> ',' >> x.n_shp_samples;
        s >> ',' >> x.R;
        s >> ',' >> x.B;
        s >> ',' >> x.K;
        s >> ',' >> x.P;
        s >> ',' >> x.N;
        s >> ',' >> x.sum_shp_samples;
        s >> ',' >> x.db_start;
        s >> ',' >> x.refpuls_position;
        s >> ',' >> x.avg_npulse;
        s >> ',' >> x.reference0;
        s >> ',' >> x.reference1;
        s >> ',' >> x.reference2;
        s >> ',' >> x.reference3;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sums)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct calib_waveform_L2_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef calib_waveform_L2_1<rebind_it> type;
    };

    typedef it iterator_type;

    calib_waveform_L2_1(it begin, it end, bool dirty=false)
        : endianess(begin)
        , n_shp_samples(begin)
        , R(begin)
        , B(begin)
        , K(begin)
        , P(begin)
        , N(begin)
        , sum_shp_samples(begin)
        , db_start(begin)
        , refpuls_position(begin)
        , avg_npulse(begin)
        , reference0(begin)
        , reference1(begin)
        , reference2(begin)
        , reference3(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50105, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 393664};
    it begin() const { return endianess.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t endianess;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> endianess;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t n_shp_samples;
    #else
    binary::field<uint8_t, sc_uint8, 16, it> n_shp_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t R;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> R;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t B;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> B;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t K;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> K;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t P;
    #else
    binary::field<uint32_t, sc_uint32, 128, it> P;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t N;
    #else
    binary::field<uint32_t, sc_uint32, 160, it> N;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t sum_shp_samples;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> sum_shp_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t db_start;
    #else
    binary::field<uint32_t, sc_uint32, 224, it> db_start;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t refpuls_position;
    #else
    binary::field<uint32_t, sc_uint32, 256, it> refpuls_position;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t avg_npulse;
    #else
    binary::field<uint32_t, sc_uint32, 288, it> avg_npulse;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference0;
    #else
    binary::field<uint32_t, sc_uint32, 320, it> reference0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference1;
    #else
    binary::field<uint32_t, sc_uint32, 352, it> reference1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference2;
    #else
    binary::field<uint32_t, sc_uint32, 384, it> reference2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference3;
    #else
    binary::field<uint32_t, sc_uint32, 416, it> reference3;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 12288 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sums(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t sums;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> sums;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[12288];
    #else
    sequence<calib_waveform_L2_1, 32, 448, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    calib_waveform_L2_1& operator=(const calib_waveform_L2_1<ito>& o) {
        endianess = o.endianess;
        n_shp_samples = o.n_shp_samples;
        R = o.R;
        B = o.B;
        K = o.K;
        P = o.P;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        db_start = o.db_start;
        refpuls_position = o.refpuls_position;
        avg_npulse = o.avg_npulse;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sums = o.data[n].sums;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct calib_waveform_L2_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef calib_waveform_L2_1<rebind_it> type;
    };

    enum { id_main = 50105, id_sub = 0};

    uint16_t         endianess;
    uint8_t          n_shp_samples;
    uint32_t         R;
    uint32_t         B;
    uint32_t         K;
    uint32_t         P;
    uint32_t         N;
    uint32_t         sum_shp_samples;
    uint32_t         db_start;
    uint32_t         refpuls_position;
    uint32_t         avg_npulse;
    uint32_t         reference0;
    uint32_t         reference1;
    uint32_t         reference2;
    uint32_t         reference3;
    std::size_t data_size;
    enum { data_max_size = 12288 };
    struct sequence_definition {
        uint32_t         sums;
    } data[12288];

    calib_waveform_L2_1()
        : endianess()
        , n_shp_samples()
        , R()
        , B()
        , K()
        , P()
        , N()
        , sum_shp_samples()
        , db_start()
        , refpuls_position()
        , avg_npulse()
        , reference0()
        , reference1()
        , reference2()
        , reference3()
    {}

    template<class it>
    calib_waveform_L2_1(const calib_waveform_L2_1<it>& o) {
        endianess = o.endianess;
        n_shp_samples = o.n_shp_samples;
        R = o.R;
        B = o.B;
        K = o.K;
        P = o.P;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        db_start = o.db_start;
        refpuls_position = o.refpuls_position;
        avg_npulse = o.avg_npulse;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sums = o.data[n].sums;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const calib_waveform_L2_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.endianess;
        s << ", " << x.n_shp_samples;
        s << ", " << x.R;
        s << ", " << x.B;
        s << ", " << x.K;
        s << ", " << x.P;
        s << ", " << x.N;
        s << ", " << x.sum_shp_samples;
        s << ", " << x.db_start;
        s << ", " << x.refpuls_position;
        s << ", " << x.avg_npulse;
        s << ", " << x.reference0;
        s << ", " << x.reference1;
        s << ", " << x.reference2;
        s << ", " << x.reference3;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sums
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, calib_waveform_L2_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.endianess;
        s >> ',' >> x.n_shp_samples;
        s >> ',' >> x.R;
        s >> ',' >> x.B;
        s >> ',' >> x.K;
        s >> ',' >> x.P;
        s >> ',' >> x.N;
        s >> ',' >> x.sum_shp_samples;
        s >> ',' >> x.db_start;
        s >> ',' >> x.refpuls_position;
        s >> ',' >> x.avg_npulse;
        s >> ',' >> x.reference0;
        s >> ',' >> x.reference1;
        s >> ',' >> x.reference2;
        s >> ',' >> x.reference3;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sums)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct calib_wfm_sbl_header
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef calib_wfm_sbl_header<rebind_it> type;
    };

    typedef it iterator_type;

    calib_wfm_sbl_header(it begin, it end, bool dirty=false)
        : endianess(begin)
        , shp_integ_length(begin)
        , K(begin)
        , N(begin)
        , sum_shp_samples(begin)
        , ls_npulse(begin)
        , trig_cnt(begin)
        , RESERVED1(begin)
        , RESERVED2(begin)
        , RESERVED3(begin)
        , RESERVED4(begin)
        , RESERVED5(begin)
        , reference0(begin)
        , reference1(begin)
        , reference2(begin)
        , reference3(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50106, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 480};
    it begin() const { return endianess.begin(); }
    it end() const { return reference3.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t endianess;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> endianess;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t shp_integ_length;
    #else
    binary::field<uint8_t, sc_uint8, 16, it> shp_integ_length;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t K;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> K;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t N;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> N;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t sum_shp_samples;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> sum_shp_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t ls_npulse;
    #else
    binary::field<uint32_t, sc_uint32, 128, it> ls_npulse;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t trig_cnt;
    #else
    binary::field<uint32_t, sc_uint32, 160, it> trig_cnt;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED1;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> RESERVED1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED2;
    #else
    binary::field<uint32_t, sc_uint32, 224, it> RESERVED2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED3;
    #else
    binary::field<uint32_t, sc_uint32, 256, it> RESERVED3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED4;
    #else
    binary::field<uint32_t, sc_uint32, 288, it> RESERVED4;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED5;
    #else
    binary::field<uint32_t, sc_uint32, 320, it> RESERVED5;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference0;
    #else
    binary::field<uint32_t, sc_uint32, 352, it> reference0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference1;
    #else
    binary::field<uint32_t, sc_uint32, 384, it> reference1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference2;
    #else
    binary::field<uint32_t, sc_uint32, 416, it> reference2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t reference3;
    #else
    binary::field<uint32_t, sc_uint32, 448, it> reference3;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    calib_wfm_sbl_header& operator=(const calib_wfm_sbl_header<ito>& o) {
        endianess = o.endianess;
        shp_integ_length = o.shp_integ_length;
        K = o.K;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        ls_npulse = o.ls_npulse;
        trig_cnt = o.trig_cnt;
        RESERVED1 = o.RESERVED1;
        RESERVED2 = o.RESERVED2;
        RESERVED3 = o.RESERVED3;
        RESERVED4 = o.RESERVED4;
        RESERVED5 = o.RESERVED5;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct calib_wfm_sbl_header<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef calib_wfm_sbl_header<rebind_it> type;
    };

    enum { id_main = 50106, id_sub = 0};

    uint16_t         endianess;
    uint8_t          shp_integ_length;
    uint32_t         K;
    uint32_t         N;
    uint32_t         sum_shp_samples;
    uint32_t         ls_npulse;
    uint32_t         trig_cnt;
    uint32_t         RESERVED1;
    uint32_t         RESERVED2;
    uint32_t         RESERVED3;
    uint32_t         RESERVED4;
    uint32_t         RESERVED5;
    uint32_t         reference0;
    uint32_t         reference1;
    uint32_t         reference2;
    uint32_t         reference3;

    calib_wfm_sbl_header()
        : endianess()
        , shp_integ_length()
        , K()
        , N()
        , sum_shp_samples()
        , ls_npulse()
        , trig_cnt()
        , RESERVED1()
        , RESERVED2()
        , RESERVED3()
        , RESERVED4()
        , RESERVED5()
        , reference0()
        , reference1()
        , reference2()
        , reference3()
    {}

    template<class it>
    calib_wfm_sbl_header(const calib_wfm_sbl_header<it>& o) {
        endianess = o.endianess;
        shp_integ_length = o.shp_integ_length;
        K = o.K;
        N = o.N;
        sum_shp_samples = o.sum_shp_samples;
        ls_npulse = o.ls_npulse;
        trig_cnt = o.trig_cnt;
        RESERVED1 = o.RESERVED1;
        RESERVED2 = o.RESERVED2;
        RESERVED3 = o.RESERVED3;
        RESERVED4 = o.RESERVED4;
        RESERVED5 = o.RESERVED5;
        reference0 = o.reference0;
        reference1 = o.reference1;
        reference2 = o.reference2;
        reference3 = o.reference3;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const calib_wfm_sbl_header<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.endianess;
        s << ", " << x.shp_integ_length;
        s << ", " << x.K;
        s << ", " << x.N;
        s << ", " << x.sum_shp_samples;
        s << ", " << x.ls_npulse;
        s << ", " << x.trig_cnt;
        s << ", " << x.RESERVED1;
        s << ", " << x.RESERVED2;
        s << ", " << x.RESERVED3;
        s << ", " << x.RESERVED4;
        s << ", " << x.RESERVED5;
        s << ", " << x.reference0;
        s << ", " << x.reference1;
        s << ", " << x.reference2;
        s << ", " << x.reference3;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, calib_wfm_sbl_header<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.endianess;
        s >> ',' >> x.shp_integ_length;
        s >> ',' >> x.K;
        s >> ',' >> x.N;
        s >> ',' >> x.sum_shp_samples;
        s >> ',' >> x.ls_npulse;
        s >> ',' >> x.trig_cnt;
        s >> ',' >> x.RESERVED1;
        s >> ',' >> x.RESERVED2;
        s >> ',' >> x.RESERVED3;
        s >> ',' >> x.RESERVED4;
        s >> ',' >> x.RESERVED5;
        s >> ',' >> x.reference0;
        s >> ',' >> x.reference1;
        s >> ',' >> x.reference2;
        s >> ',' >> x.reference3;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct cc_slice
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef cc_slice<rebind_it> type;
    };

    typedef it iterator_type;

    cc_slice(it begin, it end, bool dirty=false)
        : we_ampl(begin)
        , rng_min(begin)
        , rng_max(begin)
        , ampl_min(begin)
        , ampl_max(begin)
        , rng_cnt(begin)
        , ampl_cnt(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 133, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 2097344};
    it begin() const { return we_ampl.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float we_ampl;
    #else
    binary::field<float, sc_float32, 0, it> we_ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_min;
    #else
    binary::field<float, sc_float32, 32, it> rng_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_max;
    #else
    binary::field<float, sc_float32, 64, it> rng_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float ampl_min;
    #else
    binary::field<float, sc_float32, 96, it> ampl_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float ampl_max;
    #else
    binary::field<float, sc_float32, 128, it> ampl_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t rng_cnt;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> rng_cnt;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl_cnt;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> ampl_cnt;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 65536 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : ampl(begin, begin_bit)
            , rng(begin, begin_bit)
            , flags(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t ampl;
        #else
        binary::field<uint16_t, sc_uint12, 0, it> ampl;
        #endif
        #ifdef DOXYGEN
        int16_t rng;
        #else
        binary::field<int16_t, sc_int15, 12, it> rng;
        #endif
        #ifdef DOXYGEN
        uint8_t flags;
        #else
        binary::field<uint8_t, sc_uint5, 27, it> flags;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[65536];
    #else
    sequence<cc_slice, 32, 192, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    cc_slice& operator=(const cc_slice<ito>& o) {
        we_ampl = o.we_ampl;
        rng_min = o.rng_min;
        rng_max = o.rng_max;
        ampl_min = o.ampl_min;
        ampl_max = o.ampl_max;
        rng_cnt = o.rng_cnt;
        ampl_cnt = o.ampl_cnt;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].ampl = o.data[n].ampl;
            data[n].rng = o.data[n].rng;
            data[n].flags = o.data[n].flags;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct cc_slice<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef cc_slice<rebind_it> type;
    };

    enum { id_main = 133, id_sub = 0};

    float            we_ampl;
    float            rng_min;
    float            rng_max;
    float            ampl_min;
    float            ampl_max;
    uint16_t         rng_cnt;
    uint16_t         ampl_cnt;
    std::size_t data_size;
    enum { data_max_size = 65536 };
    struct sequence_definition {
        uint16_t         ampl;
        int16_t          rng;
        uint8_t          flags;
    } data[65536];

    cc_slice()
        : we_ampl()
        , rng_min()
        , rng_max()
        , ampl_min()
        , ampl_max()
        , rng_cnt()
        , ampl_cnt()
    {}

    template<class it>
    cc_slice(const cc_slice<it>& o) {
        we_ampl = o.we_ampl;
        rng_min = o.rng_min;
        rng_max = o.rng_max;
        ampl_min = o.ampl_min;
        ampl_max = o.ampl_max;
        rng_cnt = o.rng_cnt;
        ampl_cnt = o.ampl_cnt;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].ampl = o.data[n].ampl;
            data[n].rng = o.data[n].rng;
            data[n].flags = o.data[n].flags;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const cc_slice<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.we_ampl;
        s << ", " << x.rng_min;
        s << ", " << x.rng_max;
        s << ", " << x.ampl_min;
        s << ", " << x.ampl_max;
        s << ", " << x.rng_cnt;
        s << ", " << x.ampl_cnt;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].ampl
            << ", " << x.data[n].rng
            << ", " << x.data[n].flags
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, cc_slice<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.we_ampl;
        s >> ',' >> x.rng_min;
        s >> ',' >> x.rng_max;
        s >> ',' >> x.ampl_min;
        s >> ',' >> x.ampl_max;
        s >> ',' >> x.rng_cnt;
        s >> ',' >> x.ampl_cnt;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].ampl)
            >> ',' >> (x.data[x.data_size-1].rng)
            >> ',' >> (x.data[x.data_size-1].flags)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct channel_combination_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef channel_combination_table<rebind_it> type;
    };

    typedef it iterator_type;

    channel_combination_table(it begin, it end, bool dirty=false)
        : limits(begin, end, limits_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 56, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 512};
    it begin() const { return limits.begin(); }
    it end() const { return limits.end(); }

    #endif //DOXYGEN

    std::size_t limits_size;
    enum { limits_max_size = 16 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : source(begin, begin_bit)
            , destination(begin, begin_bit)
            , minmax(begin, begin_bit)
            , limit(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint8_t source;
        #else
        binary::field<uint8_t, sc_uint8, 0, it> source;
        #endif
        #ifdef DOXYGEN
        uint8_t destination;
        #else
        binary::field<uint8_t, sc_uint8, 8, it> destination;
        #endif
        #ifdef DOXYGEN
        uint8_t minmax;
        #else
        binary::field<uint8_t, sc_bit, 16, it> minmax;
        #endif
        #ifdef DOXYGEN
        uint16_t limit;
        #else
        binary::field<uint16_t, sc_uint15, 17, it> limit;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition limits[16];
    #else
    sequence<channel_combination_table, 32, 0, it> limits;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    channel_combination_table& operator=(const channel_combination_table<ito>& o) {
        limits_size = o.limits_size;
        limits.clean();
        for(unsigned n=0; n<limits_size; ++n){
            limits[n].source = o.limits[n].source;
            limits[n].destination = o.limits[n].destination;
            limits[n].minmax = o.limits[n].minmax;
            limits[n].limit = o.limits[n].limit;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct channel_combination_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef channel_combination_table<rebind_it> type;
    };

    enum { id_main = 56, id_sub = 0};

    std::size_t limits_size;
    enum { limits_max_size = 16 };
    struct sequence_definition {
        uint8_t          source;
        uint8_t          destination;
        uint8_t          minmax;
        uint16_t         limit;
    } limits[16];

    channel_combination_table()
    {}

    template<class it>
    channel_combination_table(const channel_combination_table<it>& o) {
        limits_size = o.limits.size();
        for(unsigned n=0; n<limits_size; ++n){
            limits[n].source = o.limits[n].source;
            limits[n].destination = o.limits[n].destination;
            limits[n].minmax = o.limits[n].minmax;
            limits[n].limit = o.limits[n].limit;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const channel_combination_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.limits_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.limits[n].source
            << ", " << x.limits[n].destination
            << ", " << x.limits[n].minmax
            << ", " << x.limits[n].limit
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, channel_combination_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.limits_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.limits_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.limits[x.limits_size-1].source)
            >> ',' >> (x.limits[x.limits_size-1].destination)
            >> ',' >> (x.limits[x.limits_size-1].minmax)
            >> ',' >> (x.limits[x.limits_size-1].limit)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct context_end
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef context_end<rebind_it> type;
    };

    typedef it iterator_type;

    context_end(it begin, it end, bool dirty=false)
        : sub(begin)
        , main(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 21, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 32};
    it begin() const { return sub.begin(); }
    it end() const { return main.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sub;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> sub;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t main;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> main;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    context_end& operator=(const context_end<ito>& o) {
        sub = o.sub;
        main = o.main;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct context_end<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef context_end<rebind_it> type;
    };

    enum { id_main = 21, id_sub = 1};

    uint16_t         sub;
    uint16_t         main;

    context_end()
        : sub()
        , main()
    {}

    template<class it>
    context_end(const context_end<it>& o) {
        sub = o.sub;
        main = o.main;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const context_end<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.sub;
        s << ", " << x.main;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, context_end<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.sub;
        s >> ',' >> x.main;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! external synchronization input

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct counter_sync
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef counter_sync<rebind_it> type;
    };

    typedef it iterator_type;

    counter_sync(it begin, it end, bool dirty=false)
        : systime(begin)
        , count(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 13, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 64};
    it begin() const { return systime.begin(); }
    it end() const { return count.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time stamp of external event in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t count;//!<  number of events of the external event input 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> count;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    counter_sync& operator=(const counter_sync<ito>& o) {
        systime = o.systime;
        count = o.count;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct counter_sync<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef counter_sync<rebind_it> type;
    };

    enum { id_main = 13, id_sub = 0};

    uint32_t         systime;
    uint32_t         count;

    counter_sync()
        : systime()
        , count()
    {}

    template<class it>
    counter_sync(const counter_sync<it>& o) {
        systime = o.systime;
        count = o.count;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const counter_sync<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.count;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, counter_sync<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.count;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! external synchronization input

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct counter_sync_2angles_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef counter_sync_2angles_hr<rebind_it> type;
    };

    typedef it iterator_type;

    counter_sync_2angles_hr(it begin, it end, bool dirty=false)
        : systime(begin)
        , source(begin)
        , count(begin)
        , line_angle(begin)
        , frame_angle(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 122, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 192};
    it begin() const { return systime.begin(); }
    it end() const { return frame_angle.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;//!<  time of laser shot in units of units.time_unit_hi_prec 
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t source;//!<  identifier of trigger source 
    #else
    binary::field<uint32_t, sc_uint32, 64, it> source;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t count;//!<  number of events of the external event input 
    #else
    binary::field<uint32_t, sc_uint32, 96, it> count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;//!<  line angle 
    #else
    binary::field<uint32_t, sc_uint32, 128, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;//!<  frame angle 
    #else
    binary::field<uint32_t, sc_uint32, 160, it> frame_angle;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    counter_sync_2angles_hr& operator=(const counter_sync_2angles_hr<ito>& o) {
        systime = o.systime;
        source = o.source;
        count = o.count;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct counter_sync_2angles_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef counter_sync_2angles_hr<rebind_it> type;
    };

    enum { id_main = 122, id_sub = 0};

    uint64_t         systime;
    uint32_t         source;
    uint32_t         count;
    uint32_t         line_angle;
    uint32_t         frame_angle;

    counter_sync_2angles_hr()
        : systime()
        , source()
        , count()
        , line_angle()
        , frame_angle()
    {}

    template<class it>
    counter_sync_2angles_hr(const counter_sync_2angles_hr<it>& o) {
        systime = o.systime;
        source = o.source;
        count = o.count;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const counter_sync_2angles_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.source;
        s << ", " << x.count;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, counter_sync_2angles_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.source;
        s >> ',' >> x.count;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct crc32_check
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef crc32_check<rebind_it> type;
    };

    typedef it iterator_type;

    crc32_check(it begin, it end, bool dirty=false)
        : stream_id(begin)
        , sequence(begin)
        , crc(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 64};
    it begin() const { return stream_id.begin(); }
    it end() const { return crc.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t stream_id;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> stream_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t sequence;
    #else
    binary::field<uint32_t, sc_uint24, 8, it> sequence;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t crc;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> crc;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    crc32_check& operator=(const crc32_check<ito>& o) {
        stream_id = o.stream_id;
        sequence = o.sequence;
        crc = o.crc;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct crc32_check<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef crc32_check<rebind_it> type;
    };

    enum { id_main = 50, id_sub = 0};

    uint8_t          stream_id;
    uint32_t         sequence;
    uint32_t         crc;

    crc32_check()
        : stream_id()
        , sequence()
        , crc()
    {}

    template<class it>
    crc32_check(const crc32_check<it>& o) {
        stream_id = o.stream_id;
        sequence = o.sequence;
        crc = o.crc;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const crc32_check<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.stream_id;
        s << ", " << x.sequence;
        s << ", " << x.crc;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, crc32_check<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.stream_id;
        s >> ',' >> x.sequence;
        s >> ',' >> x.crc;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct crc32_header
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef crc32_header<rebind_it> type;
    };

    typedef it iterator_type;

    crc32_header(it begin, it end, bool dirty=false)
        : stream_id(begin)
        , package_ids(begin, end, package_ids_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 49, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8160};
    it begin() const { return stream_id.begin(); }
    it end() const { return package_ids.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t stream_id;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> stream_id;
    #endif //DOXYGEN

    std::size_t package_ids_size;
    enum { package_ids_max_size = 254 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sub(begin, begin_bit)
            , main(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t sub;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> sub;
        #endif
        #ifdef DOXYGEN
        uint16_t main;
        #else
        binary::field<uint16_t, sc_uint16, 16, it> main;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition package_ids[254];
    #else
    sequence<crc32_header, 32, 32, it> package_ids;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    crc32_header& operator=(const crc32_header<ito>& o) {
        stream_id = o.stream_id;
        package_ids_size = o.package_ids_size;
        package_ids.clean();
        for(unsigned n=0; n<package_ids_size; ++n){
            package_ids[n].sub = o.package_ids[n].sub;
            package_ids[n].main = o.package_ids[n].main;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct crc32_header<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef crc32_header<rebind_it> type;
    };

    enum { id_main = 49, id_sub = 0};

    uint8_t          stream_id;
    std::size_t package_ids_size;
    enum { package_ids_max_size = 254 };
    struct sequence_definition {
        uint16_t         sub;
        uint16_t         main;
    } package_ids[254];

    crc32_header()
        : stream_id()
    {}

    template<class it>
    crc32_header(const crc32_header<it>& o) {
        stream_id = o.stream_id;
        package_ids_size = o.package_ids.size();
        for(unsigned n=0; n<package_ids_size; ++n){
            package_ids[n].sub = o.package_ids[n].sub;
            package_ids[n].main = o.package_ids[n].main;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const crc32_header<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.stream_id;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.package_ids_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.package_ids[n].sub
            << ", " << x.package_ids[n].main
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, crc32_header<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.stream_id;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.package_ids_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.package_ids_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.package_ids[x.package_ids_size-1].sub)
            >> ',' >> (x.package_ids[x.package_ids_size-1].main)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct cs_trans
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef cs_trans<rebind_it> type;
    };

    typedef it iterator_type;

    cs_trans(it begin, it end, bool dirty=false)
        : kind(begin)
        , desc(begin)
        , matrix(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 140, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1568};
    it begin() const { return kind.begin(); }
    it end() const { return matrix.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t kind;//!<  kind of transformation, for automatic processing: 0  undefined, 1: SOCS to  System CS 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> kind;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char desc[64];//!<  textual description of kind of transformation 
    #else
    binary::array<char, 64, sc_char, 32, it> desc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double matrix[16];//!<  4x4 transformation matrix in raw-wise representation:           m00 m01 m02 m03           m10 m11 m12 m13  --> matrix[0..15] = m00 m01 m02 m03 m10 m11 m12 m13 m20 m21 m22 m23 m30 m31 m32 m33           m20 m21 m22 m23           m30 m31 m32 m33 
    #else
    binary::array<double, 16, sc_float64, 544, it> matrix;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    cs_trans& operator=(const cs_trans<ito>& o) {
        kind = o.kind;
        for(unsigned n=0; n<64; ++n) desc[n] = o.desc[n];
        for(unsigned n=0; n<16; ++n) matrix[n] = o.matrix[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct cs_trans<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef cs_trans<rebind_it> type;
    };

    enum { id_main = 140, id_sub = 0};

    uint32_t         kind;
    char             desc[64];
    double           matrix[16];

    cs_trans()
        : kind()
        , desc()
        , matrix()
    {}

    template<class it>
    cs_trans(const cs_trans<it>& o) {
        kind = o.kind;
        for(unsigned n=0; n<64; ++n) desc[n] = o.desc[n];
        for(unsigned n=0; n<16; ++n) matrix[n] = o.matrix[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const cs_trans<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.kind;
        s << ", "; write_array(s, 64, x.desc);
        s << ", "; write_array(s, 16, x.matrix);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, cs_trans<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.kind;
        s >> ','; read_array(s, 64, x.desc);
        s >> ','; read_array(s, 16, x.matrix);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct datagram_separator
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef datagram_separator<rebind_it> type;
    };

    typedef it iterator_type;

    datagram_separator(it begin, it end, bool dirty=false)
        : sequence_number(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 65226, id_sub = 60926};
    #ifndef DOXYGEN
    enum { max_bit_width = 32};
    it begin() const { return sequence_number.begin(); }
    it end() const { return sequence_number.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t sequence_number;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> sequence_number;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    datagram_separator& operator=(const datagram_separator<ito>& o) {
        sequence_number = o.sequence_number;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct datagram_separator<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef datagram_separator<rebind_it> type;
    };

    enum { id_main = 65226, id_sub = 60926};

    uint32_t         sequence_number;

    datagram_separator()
        : sequence_number()
    {}

    template<class it>
    datagram_separator(const datagram_separator<it>& o) {
        sequence_number = o.sequence_number;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const datagram_separator<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.sequence_number;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, datagram_separator<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.sequence_number;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct debug_hw_dg
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef debug_hw_dg<rebind_it> type;
    };

    typedef it iterator_type;

    debug_hw_dg(it begin, it end, bool dirty=false)
        : packet_type(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50101, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8224};
    it begin() const { return packet_type.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t packet_type;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> packet_type;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t value;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[256];
    #else
    sequence<debug_hw_dg, 32, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    debug_hw_dg& operator=(const debug_hw_dg<ito>& o) {
        packet_type = o.packet_type;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct debug_hw_dg<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef debug_hw_dg<rebind_it> type;
    };

    enum { id_main = 50101, id_sub = 0};

    uint32_t         packet_type;
    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition {
        uint32_t         value;
    } data[256];

    debug_hw_dg()
        : packet_type()
    {}

    template<class it>
    debug_hw_dg(const debug_hw_dg<it>& o) {
        packet_type = o.packet_type;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const debug_hw_dg<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.packet_type;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, debug_hw_dg<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.packet_type;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct debug_sw_dg
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef debug_sw_dg<rebind_it> type;
    };

    typedef it iterator_type;

    debug_sw_dg(it begin, it end, bool dirty=false)
        : packet_type(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50102, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8224};
    it begin() const { return packet_type.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t packet_type;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> packet_type;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t value;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[256];
    #else
    sequence<debug_sw_dg, 32, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    debug_sw_dg& operator=(const debug_sw_dg<ito>& o) {
        packet_type = o.packet_type;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct debug_sw_dg<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef debug_sw_dg<rebind_it> type;
    };

    enum { id_main = 50102, id_sub = 0};

    uint32_t         packet_type;
    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition {
        uint32_t         value;
    } data[256];

    debug_sw_dg()
        : packet_type()
    {}

    template<class it>
    debug_sw_dg(const debug_sw_dg<it>& o) {
        packet_type = o.packet_type;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const debug_sw_dg<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.packet_type;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, debug_sw_dg<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.packet_type;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_geometry
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry<rebind_it> type;
    };

    typedef it iterator_type;

    device_geometry(it begin, it end, bool dirty=false)
        : laser_origin(begin)
        , laser_direction(begin)
        , mirror_axis_origin(begin)
        , mirror_axis_direction(begin)
        , line_angle_0(begin)
        , num_facets(begin)
        , facet(begin, end, facet_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 4, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1448};
    it begin() const { return laser_origin.begin(); }
    it end() const { return facet.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_origin[3];
    #else
    binary::array<float, 3, sc_float32, 0, it> laser_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_direction[3];
    #else
    binary::array<float, 3, sc_float32, 96, it> laser_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_axis_origin[3];
    #else
    binary::array<float, 3, sc_float32, 192, it> mirror_axis_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_axis_direction[3];
    #else
    binary::array<float, 3, sc_float32, 288, it> mirror_axis_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t line_angle_0;
    #else
    binary::field<int32_t, sc_int32, 384, it> line_angle_0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_facets;
    #else
    binary::field<uint8_t, sc_uint8, 416, it> num_facets;
    #endif //DOXYGEN

    std::size_t facet_size;
    enum { facet_max_size = 8 };
    //! facet orientation

    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : nx(begin, begin_bit)
            , ny(begin, begin_bit)
            , nz(begin, begin_bit)
            , d(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float nx;//!<  x component of facet normal 
        #else
        binary::field<float, sc_float32, 0, it> nx;
        #endif
        #ifdef DOXYGEN
        float ny;//!<  y component of facet normal 
        #else
        binary::field<float, sc_float32, 32, it> ny;
        #endif
        #ifdef DOXYGEN
        float nz;//!<  z component of facet normal 
        #else
        binary::field<float, sc_float32, 64, it> nz;
        #endif
        #ifdef DOXYGEN
        float d;//!<  facet distance to origin 
        #else
        binary::field<float, sc_float32, 96, it> d;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition facet[8];
    #else
    sequence<device_geometry, 128, 424, it> facet;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    device_geometry& operator=(const device_geometry<ito>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_origin[n] = o.mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_direction[n] = o.mirror_axis_direction[n];
        line_angle_0 = o.line_angle_0;
        num_facets = o.num_facets;
        facet_size = o.facet_size;
        facet.clean();
        for(unsigned n=0; n<facet_size; ++n){
            facet[n].nx = o.facet[n].nx;
            facet[n].ny = o.facet[n].ny;
            facet[n].nz = o.facet[n].nz;
            facet[n].d = o.facet[n].d;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct device_geometry<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry<rebind_it> type;
    };

    enum { id_main = 4, id_sub = 0};

    float            laser_origin[3];
    float            laser_direction[3];
    float            mirror_axis_origin[3];
    float            mirror_axis_direction[3];
    int32_t          line_angle_0;
    uint8_t          num_facets;
    std::size_t facet_size;
    enum { facet_max_size = 8 };
    struct sequence_definition {
        float            nx;
        float            ny;
        float            nz;
        float            d;
    } facet[8];

    device_geometry()
        : laser_origin()
        , laser_direction()
        , mirror_axis_origin()
        , mirror_axis_direction()
        , line_angle_0()
        , num_facets()
    {}

    template<class it>
    device_geometry(const device_geometry<it>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_origin[n] = o.mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_direction[n] = o.mirror_axis_direction[n];
        line_angle_0 = o.line_angle_0;
        num_facets = o.num_facets;
        facet_size = o.facet.size();
        for(unsigned n=0; n<facet_size; ++n){
            facet[n].nx = o.facet[n].nx;
            facet[n].ny = o.facet[n].ny;
            facet[n].nz = o.facet[n].nz;
            facet[n].d = o.facet[n].d;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_geometry<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.laser_origin);
        s << ", "; write_array(s, 3, x.laser_direction);
        s << ", "; write_array(s, 3, x.mirror_axis_origin);
        s << ", "; write_array(s, 3, x.mirror_axis_direction);
        s << ", " << x.line_angle_0;
        s << ", " << x.num_facets;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.facet_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.facet[n].nx
            << ", " << x.facet[n].ny
            << ", " << x.facet[n].nz
            << ", " << x.facet[n].d
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_geometry<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.laser_origin);
        s >> ','; read_array(s, 3, x.laser_direction);
        s >> ','; read_array(s, 3, x.mirror_axis_origin);
        s >> ','; read_array(s, 3, x.mirror_axis_direction);
        s >> ',' >> x.line_angle_0;
        s >> ',' >> x.num_facets;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.facet_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.facet_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.facet[x.facet_size-1].nx)
            >> ',' >> (x.facet[x.facet_size-1].ny)
            >> ',' >> (x.facet[x.facet_size-1].nz)
            >> ',' >> (x.facet[x.facet_size-1].d)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_geometry_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_1<rebind_it> type;
    };

    typedef it iterator_type;

    device_geometry_1(it begin, it end, bool dirty=false)
        : exit_pane_thickness(begin)
        , exit_pane_index(begin)
        , exit_pane_direction(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 91, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 160};
    it begin() const { return exit_pane_thickness.begin(); }
    it end() const { return exit_pane_direction.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float exit_pane_thickness;
    #else
    binary::field<float, sc_float32, 0, it> exit_pane_thickness;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float exit_pane_index;
    #else
    binary::field<float, sc_float32, 32, it> exit_pane_index;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float exit_pane_direction[3];
    #else
    binary::array<float, 3, sc_float32, 64, it> exit_pane_direction;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    device_geometry_1& operator=(const device_geometry_1<ito>& o) {
        exit_pane_thickness = o.exit_pane_thickness;
        exit_pane_index = o.exit_pane_index;
        for(unsigned n=0; n<3; ++n) exit_pane_direction[n] = o.exit_pane_direction[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct device_geometry_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_1<rebind_it> type;
    };

    enum { id_main = 91, id_sub = 0};

    float            exit_pane_thickness;
    float            exit_pane_index;
    float            exit_pane_direction[3];

    device_geometry_1()
        : exit_pane_thickness()
        , exit_pane_index()
        , exit_pane_direction()
    {}

    template<class it>
    device_geometry_1(const device_geometry_1<it>& o) {
        exit_pane_thickness = o.exit_pane_thickness;
        exit_pane_index = o.exit_pane_index;
        for(unsigned n=0; n<3; ++n) exit_pane_direction[n] = o.exit_pane_direction[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_geometry_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.exit_pane_thickness;
        s << ", " << x.exit_pane_index;
        s << ", "; write_array(s, 3, x.exit_pane_direction);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_geometry_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.exit_pane_thickness;
        s >> ',' >> x.exit_pane_index;
        s >> ','; read_array(s, 3, x.exit_pane_direction);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_geometry_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_2<rebind_it> type;
    };

    typedef it iterator_type;

    device_geometry_2(it begin, it end, bool dirty=false)
        : laser_origin(begin)
        , laser_direction(begin)
        , wedge_axis_origin(begin)
        , wedge_axis_direction(begin)
        , facet1_direction(begin)
        , facet2_direction(begin)
        , facet_distance(begin)
        , refraction_index(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 98, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 640};
    it begin() const { return laser_origin.begin(); }
    it end() const { return refraction_index.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_origin[3];
    #else
    binary::array<float, 3, sc_float32, 0, it> laser_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_direction[3];
    #else
    binary::array<float, 3, sc_float32, 96, it> laser_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float wedge_axis_origin[3];
    #else
    binary::array<float, 3, sc_float32, 192, it> wedge_axis_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float wedge_axis_direction[3];
    #else
    binary::array<float, 3, sc_float32, 288, it> wedge_axis_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float facet1_direction[3];
    #else
    binary::array<float, 3, sc_float32, 384, it> facet1_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float facet2_direction[3];
    #else
    binary::array<float, 3, sc_float32, 480, it> facet2_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float facet_distance;
    #else
    binary::field<float, sc_float32, 576, it> facet_distance;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float refraction_index;
    #else
    binary::field<float, sc_float32, 608, it> refraction_index;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    device_geometry_2& operator=(const device_geometry_2<ito>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) wedge_axis_origin[n] = o.wedge_axis_origin[n];
        for(unsigned n=0; n<3; ++n) wedge_axis_direction[n] = o.wedge_axis_direction[n];
        for(unsigned n=0; n<3; ++n) facet1_direction[n] = o.facet1_direction[n];
        for(unsigned n=0; n<3; ++n) facet2_direction[n] = o.facet2_direction[n];
        facet_distance = o.facet_distance;
        refraction_index = o.refraction_index;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct device_geometry_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_2<rebind_it> type;
    };

    enum { id_main = 98, id_sub = 0};

    float            laser_origin[3];
    float            laser_direction[3];
    float            wedge_axis_origin[3];
    float            wedge_axis_direction[3];
    float            facet1_direction[3];
    float            facet2_direction[3];
    float            facet_distance;
    float            refraction_index;

    device_geometry_2()
        : laser_origin()
        , laser_direction()
        , wedge_axis_origin()
        , wedge_axis_direction()
        , facet1_direction()
        , facet2_direction()
        , facet_distance()
        , refraction_index()
    {}

    template<class it>
    device_geometry_2(const device_geometry_2<it>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) wedge_axis_origin[n] = o.wedge_axis_origin[n];
        for(unsigned n=0; n<3; ++n) wedge_axis_direction[n] = o.wedge_axis_direction[n];
        for(unsigned n=0; n<3; ++n) facet1_direction[n] = o.facet1_direction[n];
        for(unsigned n=0; n<3; ++n) facet2_direction[n] = o.facet2_direction[n];
        facet_distance = o.facet_distance;
        refraction_index = o.refraction_index;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_geometry_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.laser_origin);
        s << ", "; write_array(s, 3, x.laser_direction);
        s << ", "; write_array(s, 3, x.wedge_axis_origin);
        s << ", "; write_array(s, 3, x.wedge_axis_direction);
        s << ", "; write_array(s, 3, x.facet1_direction);
        s << ", "; write_array(s, 3, x.facet2_direction);
        s << ", " << x.facet_distance;
        s << ", " << x.refraction_index;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_geometry_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.laser_origin);
        s >> ','; read_array(s, 3, x.laser_direction);
        s >> ','; read_array(s, 3, x.wedge_axis_origin);
        s >> ','; read_array(s, 3, x.wedge_axis_direction);
        s >> ','; read_array(s, 3, x.facet1_direction);
        s >> ','; read_array(s, 3, x.facet2_direction);
        s >> ',' >> x.facet_distance;
        s >> ',' >> x.refraction_index;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_geometry_3
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_3<rebind_it> type;
    };

    typedef it iterator_type;

    device_geometry_3(it begin, it end, bool dirty=false)
        : laser_origin(begin)
        , laser_direction(begin)
        , mirror_axis_origin(begin)
        , mirror_axis_direction(begin)
        , defl_mirror_origin(begin)
        , defl_mirror_direction(begin)
        , num_facets(begin)
        , facet(begin, end, facet_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 106, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1608};
    it begin() const { return laser_origin.begin(); }
    it end() const { return facet.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_origin[3];
    #else
    binary::array<float, 3, sc_float32, 0, it> laser_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_direction[3];
    #else
    binary::array<float, 3, sc_float32, 96, it> laser_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_axis_origin[3];
    #else
    binary::array<float, 3, sc_float32, 192, it> mirror_axis_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_axis_direction[3];
    #else
    binary::array<float, 3, sc_float32, 288, it> mirror_axis_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float defl_mirror_origin[3];
    #else
    binary::array<float, 3, sc_float32, 384, it> defl_mirror_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float defl_mirror_direction[3];
    #else
    binary::array<float, 3, sc_float32, 480, it> defl_mirror_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_facets;
    #else
    binary::field<uint8_t, sc_uint8, 576, it> num_facets;
    #endif //DOXYGEN

    std::size_t facet_size;
    enum { facet_max_size = 8 };
    //! facet orientation

    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : nx(begin, begin_bit)
            , ny(begin, begin_bit)
            , nz(begin, begin_bit)
            , d(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float nx;//!<  x component of facet normal 
        #else
        binary::field<float, sc_float32, 0, it> nx;
        #endif
        #ifdef DOXYGEN
        float ny;//!<  y component of facet normal 
        #else
        binary::field<float, sc_float32, 32, it> ny;
        #endif
        #ifdef DOXYGEN
        float nz;//!<  z component of facet normal 
        #else
        binary::field<float, sc_float32, 64, it> nz;
        #endif
        #ifdef DOXYGEN
        float d;//!<  facet distance to origin 
        #else
        binary::field<float, sc_float32, 96, it> d;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition facet[8];
    #else
    sequence<device_geometry_3, 128, 584, it> facet;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    device_geometry_3& operator=(const device_geometry_3<ito>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_origin[n] = o.mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_direction[n] = o.mirror_axis_direction[n];
        for(unsigned n=0; n<3; ++n) defl_mirror_origin[n] = o.defl_mirror_origin[n];
        for(unsigned n=0; n<3; ++n) defl_mirror_direction[n] = o.defl_mirror_direction[n];
        num_facets = o.num_facets;
        facet_size = o.facet_size;
        facet.clean();
        for(unsigned n=0; n<facet_size; ++n){
            facet[n].nx = o.facet[n].nx;
            facet[n].ny = o.facet[n].ny;
            facet[n].nz = o.facet[n].nz;
            facet[n].d = o.facet[n].d;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct device_geometry_3<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_3<rebind_it> type;
    };

    enum { id_main = 106, id_sub = 0};

    float            laser_origin[3];
    float            laser_direction[3];
    float            mirror_axis_origin[3];
    float            mirror_axis_direction[3];
    float            defl_mirror_origin[3];
    float            defl_mirror_direction[3];
    uint8_t          num_facets;
    std::size_t facet_size;
    enum { facet_max_size = 8 };
    struct sequence_definition {
        float            nx;
        float            ny;
        float            nz;
        float            d;
    } facet[8];

    device_geometry_3()
        : laser_origin()
        , laser_direction()
        , mirror_axis_origin()
        , mirror_axis_direction()
        , defl_mirror_origin()
        , defl_mirror_direction()
        , num_facets()
    {}

    template<class it>
    device_geometry_3(const device_geometry_3<it>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_origin[n] = o.mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_direction[n] = o.mirror_axis_direction[n];
        for(unsigned n=0; n<3; ++n) defl_mirror_origin[n] = o.defl_mirror_origin[n];
        for(unsigned n=0; n<3; ++n) defl_mirror_direction[n] = o.defl_mirror_direction[n];
        num_facets = o.num_facets;
        facet_size = o.facet.size();
        for(unsigned n=0; n<facet_size; ++n){
            facet[n].nx = o.facet[n].nx;
            facet[n].ny = o.facet[n].ny;
            facet[n].nz = o.facet[n].nz;
            facet[n].d = o.facet[n].d;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_geometry_3<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.laser_origin);
        s << ", "; write_array(s, 3, x.laser_direction);
        s << ", "; write_array(s, 3, x.mirror_axis_origin);
        s << ", "; write_array(s, 3, x.mirror_axis_direction);
        s << ", "; write_array(s, 3, x.defl_mirror_origin);
        s << ", "; write_array(s, 3, x.defl_mirror_direction);
        s << ", " << x.num_facets;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.facet_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.facet[n].nx
            << ", " << x.facet[n].ny
            << ", " << x.facet[n].nz
            << ", " << x.facet[n].d
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_geometry_3<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.laser_origin);
        s >> ','; read_array(s, 3, x.laser_direction);
        s >> ','; read_array(s, 3, x.mirror_axis_origin);
        s >> ','; read_array(s, 3, x.mirror_axis_direction);
        s >> ','; read_array(s, 3, x.defl_mirror_origin);
        s >> ','; read_array(s, 3, x.defl_mirror_direction);
        s >> ',' >> x.num_facets;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.facet_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.facet_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.facet[x.facet_size-1].nx)
            >> ',' >> (x.facet[x.facet_size-1].ny)
            >> ',' >> (x.facet[x.facet_size-1].nz)
            >> ',' >> (x.facet[x.facet_size-1].d)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_geometry_4
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_4<rebind_it> type;
    };

    typedef it iterator_type;

    device_geometry_4(it begin, it end, bool dirty=false)
        : laser_origin(begin)
        , laser_direction(begin)
        , mirror_1_axis_origin(begin)
        , mirror_1_axis_direction(begin)
        , line_angle_1_0(begin)
        , mirror_2_axis_origin(begin)
        , mirror_2_axis_direction(begin)
        , facet_2_nx(begin)
        , facet_2_ny(begin)
        , facet_2_nz(begin)
        , facet_2_d(begin)
        , num_facets_1(begin)
        , facet_1(begin, end, facet_1_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 113, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1768};
    it begin() const { return laser_origin.begin(); }
    it end() const { return facet_1.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_origin[3];
    #else
    binary::array<float, 3, sc_float32, 0, it> laser_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_direction[3];
    #else
    binary::array<float, 3, sc_float32, 96, it> laser_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_1_axis_origin[3];
    #else
    binary::array<float, 3, sc_float32, 192, it> mirror_1_axis_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_1_axis_direction[3];
    #else
    binary::array<float, 3, sc_float32, 288, it> mirror_1_axis_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t line_angle_1_0;
    #else
    binary::field<int32_t, sc_int32, 384, it> line_angle_1_0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_2_axis_origin[3];
    #else
    binary::array<float, 3, sc_float32, 416, it> mirror_2_axis_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_2_axis_direction[3];
    #else
    binary::array<float, 3, sc_float32, 512, it> mirror_2_axis_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float facet_2_nx;
    #else
    binary::field<float, sc_float32, 608, it> facet_2_nx;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float facet_2_ny;
    #else
    binary::field<float, sc_float32, 640, it> facet_2_ny;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float facet_2_nz;
    #else
    binary::field<float, sc_float32, 672, it> facet_2_nz;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float facet_2_d;
    #else
    binary::field<float, sc_float32, 704, it> facet_2_d;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_facets_1;
    #else
    binary::field<uint8_t, sc_uint8, 736, it> num_facets_1;
    #endif //DOXYGEN

    std::size_t facet_1_size;
    enum { facet_1_max_size = 8 };
    //! facet orientation

    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : nx(begin, begin_bit)
            , ny(begin, begin_bit)
            , nz(begin, begin_bit)
            , d(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float nx;
        #else
        binary::field<float, sc_float32, 0, it> nx;
        #endif
        #ifdef DOXYGEN
        float ny;
        #else
        binary::field<float, sc_float32, 32, it> ny;
        #endif
        #ifdef DOXYGEN
        float nz;
        #else
        binary::field<float, sc_float32, 64, it> nz;
        #endif
        #ifdef DOXYGEN
        float d;
        #else
        binary::field<float, sc_float32, 96, it> d;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition facet_1[8];
    #else
    sequence<device_geometry_4, 128, 744, it> facet_1;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    device_geometry_4& operator=(const device_geometry_4<ito>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) mirror_1_axis_origin[n] = o.mirror_1_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_1_axis_direction[n] = o.mirror_1_axis_direction[n];
        line_angle_1_0 = o.line_angle_1_0;
        for(unsigned n=0; n<3; ++n) mirror_2_axis_origin[n] = o.mirror_2_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_2_axis_direction[n] = o.mirror_2_axis_direction[n];
        facet_2_nx = o.facet_2_nx;
        facet_2_ny = o.facet_2_ny;
        facet_2_nz = o.facet_2_nz;
        facet_2_d = o.facet_2_d;
        num_facets_1 = o.num_facets_1;
        facet_1_size = o.facet_1_size;
        facet_1.clean();
        for(unsigned n=0; n<facet_1_size; ++n){
            facet_1[n].nx = o.facet_1[n].nx;
            facet_1[n].ny = o.facet_1[n].ny;
            facet_1[n].nz = o.facet_1[n].nz;
            facet_1[n].d = o.facet_1[n].d;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct device_geometry_4<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_4<rebind_it> type;
    };

    enum { id_main = 113, id_sub = 0};

    float            laser_origin[3];
    float            laser_direction[3];
    float            mirror_1_axis_origin[3];
    float            mirror_1_axis_direction[3];
    int32_t          line_angle_1_0;
    float            mirror_2_axis_origin[3];
    float            mirror_2_axis_direction[3];
    float            facet_2_nx;
    float            facet_2_ny;
    float            facet_2_nz;
    float            facet_2_d;
    uint8_t          num_facets_1;
    std::size_t facet_1_size;
    enum { facet_1_max_size = 8 };
    struct sequence_definition {
        float            nx;
        float            ny;
        float            nz;
        float            d;
    } facet_1[8];

    device_geometry_4()
        : laser_origin()
        , laser_direction()
        , mirror_1_axis_origin()
        , mirror_1_axis_direction()
        , line_angle_1_0()
        , mirror_2_axis_origin()
        , mirror_2_axis_direction()
        , facet_2_nx()
        , facet_2_ny()
        , facet_2_nz()
        , facet_2_d()
        , num_facets_1()
    {}

    template<class it>
    device_geometry_4(const device_geometry_4<it>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) mirror_1_axis_origin[n] = o.mirror_1_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_1_axis_direction[n] = o.mirror_1_axis_direction[n];
        line_angle_1_0 = o.line_angle_1_0;
        for(unsigned n=0; n<3; ++n) mirror_2_axis_origin[n] = o.mirror_2_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_2_axis_direction[n] = o.mirror_2_axis_direction[n];
        facet_2_nx = o.facet_2_nx;
        facet_2_ny = o.facet_2_ny;
        facet_2_nz = o.facet_2_nz;
        facet_2_d = o.facet_2_d;
        num_facets_1 = o.num_facets_1;
        facet_1_size = o.facet_1.size();
        for(unsigned n=0; n<facet_1_size; ++n){
            facet_1[n].nx = o.facet_1[n].nx;
            facet_1[n].ny = o.facet_1[n].ny;
            facet_1[n].nz = o.facet_1[n].nz;
            facet_1[n].d = o.facet_1[n].d;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_geometry_4<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.laser_origin);
        s << ", "; write_array(s, 3, x.laser_direction);
        s << ", "; write_array(s, 3, x.mirror_1_axis_origin);
        s << ", "; write_array(s, 3, x.mirror_1_axis_direction);
        s << ", " << x.line_angle_1_0;
        s << ", "; write_array(s, 3, x.mirror_2_axis_origin);
        s << ", "; write_array(s, 3, x.mirror_2_axis_direction);
        s << ", " << x.facet_2_nx;
        s << ", " << x.facet_2_ny;
        s << ", " << x.facet_2_nz;
        s << ", " << x.facet_2_d;
        s << ", " << x.num_facets_1;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.facet_1_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.facet_1[n].nx
            << ", " << x.facet_1[n].ny
            << ", " << x.facet_1[n].nz
            << ", " << x.facet_1[n].d
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_geometry_4<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.laser_origin);
        s >> ','; read_array(s, 3, x.laser_direction);
        s >> ','; read_array(s, 3, x.mirror_1_axis_origin);
        s >> ','; read_array(s, 3, x.mirror_1_axis_direction);
        s >> ',' >> x.line_angle_1_0;
        s >> ','; read_array(s, 3, x.mirror_2_axis_origin);
        s >> ','; read_array(s, 3, x.mirror_2_axis_direction);
        s >> ',' >> x.facet_2_nx;
        s >> ',' >> x.facet_2_ny;
        s >> ',' >> x.facet_2_nz;
        s >> ',' >> x.facet_2_d;
        s >> ',' >> x.num_facets_1;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.facet_1_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.facet_1_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.facet_1[x.facet_1_size-1].nx)
            >> ',' >> (x.facet_1[x.facet_1_size-1].ny)
            >> ',' >> (x.facet_1[x.facet_1_size-1].nz)
            >> ',' >> (x.facet_1[x.facet_1_size-1].d)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_geometry_5
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_5<rebind_it> type;
    };

    typedef it iterator_type;

    device_geometry_5(it begin, it end, bool dirty=false)
        : laser_origin(begin)
        , laser_direction(begin)
        , line_mirror_axis_origin(begin)
        , line_mirror_axis_direction(begin)
        , frame_mirror_axis_origin(begin)
        , frame_mirror_axis_direction(begin)
        , facet_direction(begin)
        , facet_distance(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 117, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 704};
    it begin() const { return laser_origin.begin(); }
    it end() const { return facet_distance.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_origin[3];
    #else
    binary::array<float, 3, sc_float32, 0, it> laser_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_direction[3];
    #else
    binary::array<float, 3, sc_float32, 96, it> laser_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float line_mirror_axis_origin[3];
    #else
    binary::array<float, 3, sc_float32, 192, it> line_mirror_axis_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float line_mirror_axis_direction[3];
    #else
    binary::array<float, 3, sc_float32, 288, it> line_mirror_axis_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float frame_mirror_axis_origin[3];
    #else
    binary::array<float, 3, sc_float32, 384, it> frame_mirror_axis_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float frame_mirror_axis_direction[3];
    #else
    binary::array<float, 3, sc_float32, 480, it> frame_mirror_axis_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float facet_direction[3];
    #else
    binary::array<float, 3, sc_float32, 576, it> facet_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float facet_distance;
    #else
    binary::field<float, sc_float32, 672, it> facet_distance;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    device_geometry_5& operator=(const device_geometry_5<ito>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) line_mirror_axis_origin[n] = o.line_mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) line_mirror_axis_direction[n] = o.line_mirror_axis_direction[n];
        for(unsigned n=0; n<3; ++n) frame_mirror_axis_origin[n] = o.frame_mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) frame_mirror_axis_direction[n] = o.frame_mirror_axis_direction[n];
        for(unsigned n=0; n<3; ++n) facet_direction[n] = o.facet_direction[n];
        facet_distance = o.facet_distance;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct device_geometry_5<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_5<rebind_it> type;
    };

    enum { id_main = 117, id_sub = 0};

    float            laser_origin[3];
    float            laser_direction[3];
    float            line_mirror_axis_origin[3];
    float            line_mirror_axis_direction[3];
    float            frame_mirror_axis_origin[3];
    float            frame_mirror_axis_direction[3];
    float            facet_direction[3];
    float            facet_distance;

    device_geometry_5()
        : laser_origin()
        , laser_direction()
        , line_mirror_axis_origin()
        , line_mirror_axis_direction()
        , frame_mirror_axis_origin()
        , frame_mirror_axis_direction()
        , facet_direction()
        , facet_distance()
    {}

    template<class it>
    device_geometry_5(const device_geometry_5<it>& o) {
        for(unsigned n=0; n<3; ++n) laser_origin[n] = o.laser_origin[n];
        for(unsigned n=0; n<3; ++n) laser_direction[n] = o.laser_direction[n];
        for(unsigned n=0; n<3; ++n) line_mirror_axis_origin[n] = o.line_mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) line_mirror_axis_direction[n] = o.line_mirror_axis_direction[n];
        for(unsigned n=0; n<3; ++n) frame_mirror_axis_origin[n] = o.frame_mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) frame_mirror_axis_direction[n] = o.frame_mirror_axis_direction[n];
        for(unsigned n=0; n<3; ++n) facet_direction[n] = o.facet_direction[n];
        facet_distance = o.facet_distance;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_geometry_5<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.laser_origin);
        s << ", "; write_array(s, 3, x.laser_direction);
        s << ", "; write_array(s, 3, x.line_mirror_axis_origin);
        s << ", "; write_array(s, 3, x.line_mirror_axis_direction);
        s << ", "; write_array(s, 3, x.frame_mirror_axis_origin);
        s << ", "; write_array(s, 3, x.frame_mirror_axis_direction);
        s << ", "; write_array(s, 3, x.facet_direction);
        s << ", " << x.facet_distance;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_geometry_5<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.laser_origin);
        s >> ','; read_array(s, 3, x.laser_direction);
        s >> ','; read_array(s, 3, x.line_mirror_axis_origin);
        s >> ','; read_array(s, 3, x.line_mirror_axis_direction);
        s >> ','; read_array(s, 3, x.frame_mirror_axis_origin);
        s >> ','; read_array(s, 3, x.frame_mirror_axis_direction);
        s >> ','; read_array(s, 3, x.facet_direction);
        s >> ',' >> x.facet_distance;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_geometry_6
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_6<rebind_it> type;
    };

    typedef it iterator_type;

    device_geometry_6(it begin, it end, bool dirty=false)
        : t_axis(begin)
        , s_axis(begin)
        , angle_sin_min(begin)
        , angle_sin_inc(begin)
        , nodes(begin, end, nodes_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 127, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1600};
    it begin() const { return t_axis.begin(); }
    it end() const { return nodes.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float t_axis[3];
    #else
    binary::array<float, 3, sc_float32, 0, it> t_axis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s_axis[3];
    #else
    binary::array<float, 3, sc_float32, 96, it> s_axis;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float angle_sin_min;//!<  minimum of angle_sin 
    #else
    binary::field<float, sc_float32, 192, it> angle_sin_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float angle_sin_inc;//!<  increment of angle_sin 
    #else
    binary::field<float, sc_float32, 224, it> angle_sin_inc;
    #endif //DOXYGEN

    std::size_t nodes_size;
    enum { nodes_max_size = 21 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : t_rot_angle(begin, begin_bit)
            , s_rot_angle(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float t_rot_angle;//!<  rotation angle in rad 
        #else
        binary::field<float, sc_float32, 0, it> t_rot_angle;
        #endif
        #ifdef DOXYGEN
        float s_rot_angle;//!<  rotation angle in rad 
        #else
        binary::field<float, sc_float32, 32, it> s_rot_angle;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition nodes[21];
    #else
    sequence<device_geometry_6, 64, 256, it> nodes;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    device_geometry_6& operator=(const device_geometry_6<ito>& o) {
        for(unsigned n=0; n<3; ++n) t_axis[n] = o.t_axis[n];
        for(unsigned n=0; n<3; ++n) s_axis[n] = o.s_axis[n];
        angle_sin_min = o.angle_sin_min;
        angle_sin_inc = o.angle_sin_inc;
        nodes_size = o.nodes_size;
        nodes.clean();
        for(unsigned n=0; n<nodes_size; ++n){
            nodes[n].t_rot_angle = o.nodes[n].t_rot_angle;
            nodes[n].s_rot_angle = o.nodes[n].s_rot_angle;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct device_geometry_6<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_6<rebind_it> type;
    };

    enum { id_main = 127, id_sub = 0};

    float            t_axis[3];
    float            s_axis[3];
    float            angle_sin_min;
    float            angle_sin_inc;
    std::size_t nodes_size;
    enum { nodes_max_size = 21 };
    struct sequence_definition {
        float            t_rot_angle;
        float            s_rot_angle;
    } nodes[21];

    device_geometry_6()
        : t_axis()
        , s_axis()
        , angle_sin_min()
        , angle_sin_inc()
    {}

    template<class it>
    device_geometry_6(const device_geometry_6<it>& o) {
        for(unsigned n=0; n<3; ++n) t_axis[n] = o.t_axis[n];
        for(unsigned n=0; n<3; ++n) s_axis[n] = o.s_axis[n];
        angle_sin_min = o.angle_sin_min;
        angle_sin_inc = o.angle_sin_inc;
        nodes_size = o.nodes.size();
        for(unsigned n=0; n<nodes_size; ++n){
            nodes[n].t_rot_angle = o.nodes[n].t_rot_angle;
            nodes[n].s_rot_angle = o.nodes[n].s_rot_angle;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_geometry_6<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.t_axis);
        s << ", "; write_array(s, 3, x.s_axis);
        s << ", " << x.angle_sin_min;
        s << ", " << x.angle_sin_inc;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.nodes_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.nodes[n].t_rot_angle
            << ", " << x.nodes[n].s_rot_angle
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_geometry_6<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.t_axis);
        s >> ','; read_array(s, 3, x.s_axis);
        s >> ',' >> x.angle_sin_min;
        s >> ',' >> x.angle_sin_inc;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.nodes_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.nodes_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.nodes[x.nodes_size-1].t_rot_angle)
            >> ',' >> (x.nodes[x.nodes_size-1].s_rot_angle)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_geometry_7
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_7<rebind_it> type;
    };

    typedef it iterator_type;

    device_geometry_7(it begin, it end, bool dirty=false)
        : cone_axis_direction(begin)
        , beam_direction_0(begin)
        , nodes(begin, end, nodes_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 144, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 4288};
    it begin() const { return cone_axis_direction.begin(); }
    it end() const { return nodes.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float cone_axis_direction[3];
    #else
    binary::array<float, 3, sc_float32, 0, it> cone_axis_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float beam_direction_0[3];//!<  at lambda = 0 
    #else
    binary::array<float, 3, sc_float32, 96, it> beam_direction_0;
    #endif //DOXYGEN

    std::size_t nodes_size;
    enum { nodes_max_size = 64 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : t_rot_angle(begin, begin_bit)
            , s_rot_angle(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float t_rot_angle;//!<  rotation angle in rad 
        #else
        binary::field<float, sc_float32, 0, it> t_rot_angle;
        #endif
        #ifdef DOXYGEN
        float s_rot_angle;//!<  rotation angle in rad 
        #else
        binary::field<float, sc_float32, 32, it> s_rot_angle;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition nodes[64];
    #else
    sequence<device_geometry_7, 64, 192, it> nodes;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    device_geometry_7& operator=(const device_geometry_7<ito>& o) {
        for(unsigned n=0; n<3; ++n) cone_axis_direction[n] = o.cone_axis_direction[n];
        for(unsigned n=0; n<3; ++n) beam_direction_0[n] = o.beam_direction_0[n];
        nodes_size = o.nodes_size;
        nodes.clean();
        for(unsigned n=0; n<nodes_size; ++n){
            nodes[n].t_rot_angle = o.nodes[n].t_rot_angle;
            nodes[n].s_rot_angle = o.nodes[n].s_rot_angle;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct device_geometry_7<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_7<rebind_it> type;
    };

    enum { id_main = 144, id_sub = 0};

    float            cone_axis_direction[3];
    float            beam_direction_0[3];
    std::size_t nodes_size;
    enum { nodes_max_size = 64 };
    struct sequence_definition {
        float            t_rot_angle;
        float            s_rot_angle;
    } nodes[64];

    device_geometry_7()
        : cone_axis_direction()
        , beam_direction_0()
    {}

    template<class it>
    device_geometry_7(const device_geometry_7<it>& o) {
        for(unsigned n=0; n<3; ++n) cone_axis_direction[n] = o.cone_axis_direction[n];
        for(unsigned n=0; n<3; ++n) beam_direction_0[n] = o.beam_direction_0[n];
        nodes_size = o.nodes.size();
        for(unsigned n=0; n<nodes_size; ++n){
            nodes[n].t_rot_angle = o.nodes[n].t_rot_angle;
            nodes[n].s_rot_angle = o.nodes[n].s_rot_angle;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_geometry_7<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.cone_axis_direction);
        s << ", "; write_array(s, 3, x.beam_direction_0);

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.nodes_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.nodes[n].t_rot_angle
            << ", " << x.nodes[n].s_rot_angle
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_geometry_7<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.cone_axis_direction);
        s >> ','; read_array(s, 3, x.beam_direction_0);

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.nodes_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.nodes_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.nodes[x.nodes_size-1].t_rot_angle)
            >> ',' >> (x.nodes[x.nodes_size-1].s_rot_angle)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_geometry_passive_channel
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_passive_channel<rebind_it> type;
    };

    typedef it iterator_type;

    device_geometry_passive_channel(it begin, it end, bool dirty=false)
        : detector_origin(begin)
        , detector_direction(begin)
        , mirror_axis_origin(begin)
        , mirror_axis_direction(begin)
        , line_angle_0(begin)
        , num_facets(begin)
        , facet(begin, end, facet_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 143, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1448};
    it begin() const { return detector_origin.begin(); }
    it end() const { return facet.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float detector_origin[3];
    #else
    binary::array<float, 3, sc_float32, 0, it> detector_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float detector_direction[3];
    #else
    binary::array<float, 3, sc_float32, 96, it> detector_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_axis_origin[3];
    #else
    binary::array<float, 3, sc_float32, 192, it> mirror_axis_origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_axis_direction[3];
    #else
    binary::array<float, 3, sc_float32, 288, it> mirror_axis_direction;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t line_angle_0;
    #else
    binary::field<int32_t, sc_int32, 384, it> line_angle_0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_facets;
    #else
    binary::field<uint8_t, sc_uint8, 416, it> num_facets;
    #endif //DOXYGEN

    std::size_t facet_size;
    enum { facet_max_size = 8 };
    //! facet orientation

    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : nx(begin, begin_bit)
            , ny(begin, begin_bit)
            , nz(begin, begin_bit)
            , d(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float nx;//!<  x component of facet normal 
        #else
        binary::field<float, sc_float32, 0, it> nx;
        #endif
        #ifdef DOXYGEN
        float ny;//!<  y component of facet normal 
        #else
        binary::field<float, sc_float32, 32, it> ny;
        #endif
        #ifdef DOXYGEN
        float nz;//!<  z component of facet normal 
        #else
        binary::field<float, sc_float32, 64, it> nz;
        #endif
        #ifdef DOXYGEN
        float d;//!<  facet distance to origin 
        #else
        binary::field<float, sc_float32, 96, it> d;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition facet[8];
    #else
    sequence<device_geometry_passive_channel, 128, 424, it> facet;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    device_geometry_passive_channel& operator=(const device_geometry_passive_channel<ito>& o) {
        for(unsigned n=0; n<3; ++n) detector_origin[n] = o.detector_origin[n];
        for(unsigned n=0; n<3; ++n) detector_direction[n] = o.detector_direction[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_origin[n] = o.mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_direction[n] = o.mirror_axis_direction[n];
        line_angle_0 = o.line_angle_0;
        num_facets = o.num_facets;
        facet_size = o.facet_size;
        facet.clean();
        for(unsigned n=0; n<facet_size; ++n){
            facet[n].nx = o.facet[n].nx;
            facet[n].ny = o.facet[n].ny;
            facet[n].nz = o.facet[n].nz;
            facet[n].d = o.facet[n].d;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct device_geometry_passive_channel<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_geometry_passive_channel<rebind_it> type;
    };

    enum { id_main = 143, id_sub = 0};

    float            detector_origin[3];
    float            detector_direction[3];
    float            mirror_axis_origin[3];
    float            mirror_axis_direction[3];
    int32_t          line_angle_0;
    uint8_t          num_facets;
    std::size_t facet_size;
    enum { facet_max_size = 8 };
    struct sequence_definition {
        float            nx;
        float            ny;
        float            nz;
        float            d;
    } facet[8];

    device_geometry_passive_channel()
        : detector_origin()
        , detector_direction()
        , mirror_axis_origin()
        , mirror_axis_direction()
        , line_angle_0()
        , num_facets()
    {}

    template<class it>
    device_geometry_passive_channel(const device_geometry_passive_channel<it>& o) {
        for(unsigned n=0; n<3; ++n) detector_origin[n] = o.detector_origin[n];
        for(unsigned n=0; n<3; ++n) detector_direction[n] = o.detector_direction[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_origin[n] = o.mirror_axis_origin[n];
        for(unsigned n=0; n<3; ++n) mirror_axis_direction[n] = o.mirror_axis_direction[n];
        line_angle_0 = o.line_angle_0;
        num_facets = o.num_facets;
        facet_size = o.facet.size();
        for(unsigned n=0; n<facet_size; ++n){
            facet[n].nx = o.facet[n].nx;
            facet[n].ny = o.facet[n].ny;
            facet[n].nz = o.facet[n].nz;
            facet[n].d = o.facet[n].d;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_geometry_passive_channel<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.detector_origin);
        s << ", "; write_array(s, 3, x.detector_direction);
        s << ", "; write_array(s, 3, x.mirror_axis_origin);
        s << ", "; write_array(s, 3, x.mirror_axis_direction);
        s << ", " << x.line_angle_0;
        s << ", " << x.num_facets;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.facet_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.facet[n].nx
            << ", " << x.facet[n].ny
            << ", " << x.facet[n].nz
            << ", " << x.facet[n].d
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_geometry_passive_channel<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.detector_origin);
        s >> ','; read_array(s, 3, x.detector_direction);
        s >> ','; read_array(s, 3, x.mirror_axis_origin);
        s >> ','; read_array(s, 3, x.mirror_axis_direction);
        s >> ',' >> x.line_angle_0;
        s >> ',' >> x.num_facets;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.facet_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.facet_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.facet[x.facet_size-1].nx)
            >> ',' >> (x.facet[x.facet_size-1].ny)
            >> ',' >> (x.facet[x.facet_size-1].nz)
            >> ',' >> (x.facet[x.facet_size-1].d)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! geometrical parameters of external devices

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct device_mounting
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef device_mounting<rebind_it> type;
    };

    typedef it iterator_type;

    device_mounting(it begin, it end, bool dirty=false)
        : base_ofs(begin)
        , bat_ofs(begin)
        , gps_ofs(begin)
        , socnb_ofs(begin)
        , soc_ofs(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 30, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 160};
    it begin() const { return base_ofs.begin(); }
    it end() const { return soc_ofs.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float base_ofs;//!<  height of tripod base plate over soil or pavement [m] 
    #else
    binary::field<float, sc_float32, 0, it> base_ofs;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float bat_ofs;//!<  INTERNAL ONLY  the thickness of the battery pack [m] 
    #else
    binary::field<float, sc_float32, 32, it> bat_ofs;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gps_ofs;//!<  position of GPS antenna in z-axis direction in scanners coordinate system [m] 
    #else
    binary::field<float, sc_float32, 64, it> gps_ofs;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float socnb_ofs;//!<  INTERNAL ONLY  z-axis distance between scanner base plate (WITHOUT BATTERY PACK) and SOC origin in [m] 
    #else
    binary::field<float, sc_float32, 96, it> socnb_ofs;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float soc_ofs;//!<  height of scanners coordinate system origin over tripod base plate [m] 
    #else
    binary::field<float, sc_float32, 128, it> soc_ofs;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    device_mounting& operator=(const device_mounting<ito>& o) {
        base_ofs = o.base_ofs;
        bat_ofs = o.bat_ofs;
        gps_ofs = o.gps_ofs;
        socnb_ofs = o.socnb_ofs;
        soc_ofs = o.soc_ofs;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct device_mounting<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef device_mounting<rebind_it> type;
    };

    enum { id_main = 30, id_sub = 0};

    float            base_ofs;
    float            bat_ofs;
    float            gps_ofs;
    float            socnb_ofs;
    float            soc_ofs;

    device_mounting()
        : base_ofs()
        , bat_ofs()
        , gps_ofs()
        , socnb_ofs()
        , soc_ofs()
    {}

    template<class it>
    device_mounting(const device_mounting<it>& o) {
        base_ofs = o.base_ofs;
        bat_ofs = o.bat_ofs;
        gps_ofs = o.gps_ofs;
        socnb_ofs = o.socnb_ofs;
        soc_ofs = o.soc_ofs;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const device_mounting<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.base_ofs;
        s << ", " << x.bat_ofs;
        s << ", " << x.gps_ofs;
        s << ", " << x.socnb_ofs;
        s << ", " << x.soc_ofs;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, device_mounting<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.base_ofs;
        s >> ',' >> x.bat_ofs;
        s >> ',' >> x.gps_ofs;
        s >> ',' >> x.socnb_ofs;
        s >> ',' >> x.soc_ofs;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct dyntrig
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef dyntrig<rebind_it> type;
    };

    typedef it iterator_type;

    dyntrig(it begin, it end, bool dirty=false)
        : offset(begin)
        , scale(begin)
        , trigtab(begin, end, trigtab_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 75, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 24640};
    it begin() const { return offset.begin(); }
    it end() const { return trigtab.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float offset;
    #else
    binary::field<float, sc_float32, 0, it> offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float scale;
    #else
    binary::field<float, sc_float32, 32, it> scale;
    #endif //DOXYGEN

    std::size_t trigtab_size;
    enum { trigtab_max_size = 128 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : thra1(begin, begin_bit)
            , del1(begin, begin_bit)
            , dec1(begin, begin_bit)
            , thra2(begin, begin_bit)
            , del2(begin, begin_bit)
            , dec2(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float thra1;
        #else
        binary::field<float, sc_float32, 0, it> thra1;
        #endif
        #ifdef DOXYGEN
        float del1;
        #else
        binary::field<float, sc_float32, 32, it> del1;
        #endif
        #ifdef DOXYGEN
        float dec1;
        #else
        binary::field<float, sc_float32, 64, it> dec1;
        #endif
        #ifdef DOXYGEN
        float thra2;
        #else
        binary::field<float, sc_float32, 96, it> thra2;
        #endif
        #ifdef DOXYGEN
        float del2;
        #else
        binary::field<float, sc_float32, 128, it> del2;
        #endif
        #ifdef DOXYGEN
        float dec2;
        #else
        binary::field<float, sc_float32, 160, it> dec2;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition trigtab[128];
    #else
    sequence<dyntrig, 192, 64, it> trigtab;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    dyntrig& operator=(const dyntrig<ito>& o) {
        offset = o.offset;
        scale = o.scale;
        trigtab_size = o.trigtab_size;
        trigtab.clean();
        for(unsigned n=0; n<trigtab_size; ++n){
            trigtab[n].thra1 = o.trigtab[n].thra1;
            trigtab[n].del1 = o.trigtab[n].del1;
            trigtab[n].dec1 = o.trigtab[n].dec1;
            trigtab[n].thra2 = o.trigtab[n].thra2;
            trigtab[n].del2 = o.trigtab[n].del2;
            trigtab[n].dec2 = o.trigtab[n].dec2;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct dyntrig<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef dyntrig<rebind_it> type;
    };

    enum { id_main = 75, id_sub = 0};

    float            offset;
    float            scale;
    std::size_t trigtab_size;
    enum { trigtab_max_size = 128 };
    struct sequence_definition {
        float            thra1;
        float            del1;
        float            dec1;
        float            thra2;
        float            del2;
        float            dec2;
    } trigtab[128];

    dyntrig()
        : offset()
        , scale()
    {}

    template<class it>
    dyntrig(const dyntrig<it>& o) {
        offset = o.offset;
        scale = o.scale;
        trigtab_size = o.trigtab.size();
        for(unsigned n=0; n<trigtab_size; ++n){
            trigtab[n].thra1 = o.trigtab[n].thra1;
            trigtab[n].del1 = o.trigtab[n].del1;
            trigtab[n].dec1 = o.trigtab[n].dec1;
            trigtab[n].thra2 = o.trigtab[n].thra2;
            trigtab[n].del2 = o.trigtab[n].del2;
            trigtab[n].dec2 = o.trigtab[n].dec2;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const dyntrig<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.offset;
        s << ", " << x.scale;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.trigtab_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.trigtab[n].thra1
            << ", " << x.trigtab[n].del1
            << ", " << x.trigtab[n].dec1
            << ", " << x.trigtab[n].thra2
            << ", " << x.trigtab[n].del2
            << ", " << x.trigtab[n].dec2
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, dyntrig<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.offset;
        s >> ',' >> x.scale;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.trigtab_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.trigtab_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.trigtab[x.trigtab_size-1].thra1)
            >> ',' >> (x.trigtab[x.trigtab_size-1].del1)
            >> ',' >> (x.trigtab[x.trigtab_size-1].dec1)
            >> ',' >> (x.trigtab[x.trigtab_size-1].thra2)
            >> ',' >> (x.trigtab[x.trigtab_size-1].del2)
            >> ',' >> (x.trigtab[x.trigtab_size-1].dec2)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct echo
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef echo<rebind_it> type;
    };

    typedef it iterator_type;

    echo(it begin, it end, bool dirty=false)
        : range(begin)
        , ampl(begin)
        , refl(begin)
        , flags(begin)
        , dev(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 42, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return range.begin(); }
    it end() const { return dev.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t range;
    #else
    binary::field<int32_t, sc_int32, 0, it> range;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t refl;
    #else
    binary::field<int16_t, sc_int16, 48, it> refl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t flags;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t dev;
    #else
    binary::field<int16_t, sc_int16, 80, it> dev;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    echo& operator=(const echo<ito>& o) {
        range = o.range;
        ampl = o.ampl;
        refl = o.refl;
        flags = o.flags;
        dev = o.dev;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct echo<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef echo<rebind_it> type;
    };

    enum { id_main = 42, id_sub = 0};

    int32_t          range;
    uint16_t         ampl;
    int16_t          refl;
    uint16_t         flags;
    int16_t          dev;

    echo()
        : range()
        , ampl()
        , refl()
        , flags()
        , dev()
    {}

    template<class it>
    echo(const echo<it>& o) {
        range = o.range;
        ampl = o.ampl;
        refl = o.refl;
        flags = o.flags;
        dev = o.dev;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const echo<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range;
        s << ", " << x.ampl;
        s << ", " << x.refl;
        s << ", " << x.flags;
        s << ", " << x.dev;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, echo<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range;
        s >> ',' >> x.ampl;
        s >> ',' >> x.refl;
        s >> ',' >> x.flags;
        s >> ',' >> x.dev;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct echo_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef echo_1<rebind_it> type;
    };

    typedef it iterator_type;

    echo_1(it begin, it end, bool dirty=false)
        : range(begin)
        , ampl(begin)
        , gain(begin)
        , flags(begin)
        , dev(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 94, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return range.begin(); }
    it end() const { return dev.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t range;
    #else
    binary::field<int32_t, sc_int32, 0, it> range;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t gain;
    #else
    binary::field<int16_t, sc_int16, 48, it> gain;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t flags;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t dev;
    #else
    binary::field<int16_t, sc_int16, 80, it> dev;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    echo_1& operator=(const echo_1<ito>& o) {
        range = o.range;
        ampl = o.ampl;
        gain = o.gain;
        flags = o.flags;
        dev = o.dev;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct echo_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef echo_1<rebind_it> type;
    };

    enum { id_main = 94, id_sub = 0};

    int32_t          range;
    uint16_t         ampl;
    int16_t          gain;
    uint16_t         flags;
    int16_t          dev;

    echo_1()
        : range()
        , ampl()
        , gain()
        , flags()
        , dev()
    {}

    template<class it>
    echo_1(const echo_1<it>& o) {
        range = o.range;
        ampl = o.ampl;
        gain = o.gain;
        flags = o.flags;
        dev = o.dev;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const echo_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range;
        s << ", " << x.ampl;
        s << ", " << x.gain;
        s << ", " << x.flags;
        s << ", " << x.dev;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, echo_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range;
        s >> ',' >> x.ampl;
        s >> ',' >> x.gain;
        s >> ',' >> x.flags;
        s >> ',' >> x.dev;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! extents of various data fields

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct extents
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef extents<rebind_it> type;
    };

    typedef it iterator_type;

    extents(it begin, it end, bool dirty=false)
        : range_min(begin)
        , range_max(begin)
        , amplitude_min(begin)
        , amplitude_max(begin)
        , reflectance_min(begin)
        , reflectance_max(begin)
        , systime_bits(begin)
        , backgnd_rad_min(begin)
        , backgnd_rad_max(begin)
        , dev_min(begin)
        , dev_max(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 57, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 272};
    it begin() const { return range_min.begin(); }
    it end() const { return dev_max.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_min;//!<  minimum and maximum possible 
    #else
    binary::field<float, sc_float32, 0, it> range_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_max;//!<  range in meter 
    #else
    binary::field<float, sc_float32, 32, it> range_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_min;//!<  minimum and maximum possible 
    #else
    binary::field<float, sc_float32, 64, it> amplitude_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_max;//!<  amplitudes in dB 
    #else
    binary::field<float, sc_float32, 96, it> amplitude_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float reflectance_min;//!<  minimum and maximum possible 
    #else
    binary::field<float, sc_float32, 128, it> reflectance_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float reflectance_max;//!<  reflectance in dB 
    #else
    binary::field<float, sc_float32, 160, it> reflectance_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t systime_bits;//!<  significant bits of systime stamp 
    #else
    binary::field<uint16_t, sc_uint16, 192, it> systime_bits;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t backgnd_rad_min;//!<  minimum and maximum possible 
    #else
    binary::field<uint16_t, sc_uint16, 208, it> backgnd_rad_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t backgnd_rad_max;//!<  background radiation 
    #else
    binary::field<uint16_t, sc_uint16, 224, it> backgnd_rad_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t dev_min;//!<  minimum and maximum possible 
    #else
    binary::field<int16_t, sc_int16, 240, it> dev_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t dev_max;//!<  deviation from echo shape 
    #else
    binary::field<int16_t, sc_int16, 256, it> dev_max;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    extents& operator=(const extents<ito>& o) {
        range_min = o.range_min;
        range_max = o.range_max;
        amplitude_min = o.amplitude_min;
        amplitude_max = o.amplitude_max;
        reflectance_min = o.reflectance_min;
        reflectance_max = o.reflectance_max;
        systime_bits = o.systime_bits;
        backgnd_rad_min = o.backgnd_rad_min;
        backgnd_rad_max = o.backgnd_rad_max;
        dev_min = o.dev_min;
        dev_max = o.dev_max;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct extents<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef extents<rebind_it> type;
    };

    enum { id_main = 57, id_sub = 0};

    float            range_min;
    float            range_max;
    float            amplitude_min;
    float            amplitude_max;
    float            reflectance_min;
    float            reflectance_max;
    uint16_t         systime_bits;
    uint16_t         backgnd_rad_min;
    uint16_t         backgnd_rad_max;
    int16_t          dev_min;
    int16_t          dev_max;

    extents()
        : range_min()
        , range_max()
        , amplitude_min()
        , amplitude_max()
        , reflectance_min()
        , reflectance_max()
        , systime_bits()
        , backgnd_rad_min()
        , backgnd_rad_max()
        , dev_min()
        , dev_max()
    {}

    template<class it>
    extents(const extents<it>& o) {
        range_min = o.range_min;
        range_max = o.range_max;
        amplitude_min = o.amplitude_min;
        amplitude_max = o.amplitude_max;
        reflectance_min = o.reflectance_min;
        reflectance_max = o.reflectance_max;
        systime_bits = o.systime_bits;
        backgnd_rad_min = o.backgnd_rad_min;
        backgnd_rad_max = o.backgnd_rad_max;
        dev_min = o.dev_min;
        dev_max = o.dev_max;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const extents<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range_min;
        s << ", " << x.range_max;
        s << ", " << x.amplitude_min;
        s << ", " << x.amplitude_max;
        s << ", " << x.reflectance_min;
        s << ", " << x.reflectance_max;
        s << ", " << x.systime_bits;
        s << ", " << x.backgnd_rad_min;
        s << ", " << x.backgnd_rad_max;
        s << ", " << x.dev_min;
        s << ", " << x.dev_max;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, extents<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range_min;
        s >> ',' >> x.range_max;
        s >> ',' >> x.amplitude_min;
        s >> ',' >> x.amplitude_max;
        s >> ',' >> x.reflectance_min;
        s >> ',' >> x.reflectance_max;
        s >> ',' >> x.systime_bits;
        s >> ',' >> x.backgnd_rad_min;
        s >> ',' >> x.backgnd_rad_max;
        s >> ',' >> x.dev_min;
        s >> ',' >> x.dev_max;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! extents of various data fields

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct extents_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef extents_1<rebind_it> type;
    };

    typedef it iterator_type;

    extents_1(it begin, it end, bool dirty=false)
        : range_min(begin)
        , range_max(begin)
        , amplitude_min(begin)
        , amplitude_max(begin)
        , reflectance_min(begin)
        , reflectance_max(begin)
        , systime_bits(begin)
        , backgnd_rad_min(begin)
        , backgnd_rad_max(begin)
        , dev_min(begin)
        , dev_max(begin)
        , max_num_echoes(begin)
        , max_LPS(begin)
        , max_frame_speed(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 57, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 352};
    it begin() const { return range_min.begin(); }
    it end() const { return max_frame_speed.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_min;//!<  minimum and maximum possible 
    #else
    binary::field<float, sc_float32, 0, it> range_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_max;//!<  range in meter 
    #else
    binary::field<float, sc_float32, 32, it> range_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_min;//!<  minimum and maximum possible 
    #else
    binary::field<float, sc_float32, 64, it> amplitude_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_max;//!<  amplitudes in dB 
    #else
    binary::field<float, sc_float32, 96, it> amplitude_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float reflectance_min;//!<  minimum and maximum possible 
    #else
    binary::field<float, sc_float32, 128, it> reflectance_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float reflectance_max;//!<  reflectance in dB 
    #else
    binary::field<float, sc_float32, 160, it> reflectance_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t systime_bits;//!<  significant bits of systime stamp 
    #else
    binary::field<uint16_t, sc_uint16, 192, it> systime_bits;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t backgnd_rad_min;//!<  minimum and maximum possible 
    #else
    binary::field<uint16_t, sc_uint16, 208, it> backgnd_rad_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t backgnd_rad_max;//!<  background radiation 
    #else
    binary::field<uint16_t, sc_uint16, 224, it> backgnd_rad_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t dev_min;//!<  minimum and maximum possible 
    #else
    binary::field<int16_t, sc_int16, 240, it> dev_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t dev_max;//!<  deviation from echo shape 
    #else
    binary::field<int16_t, sc_int16, 256, it> dev_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t max_num_echoes;//!<  maximum number of echoes per laser shot 
    #else
    binary::field<uint16_t, sc_uint16, 272, it> max_num_echoes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float max_LPS;//!<  maximum lines per second in 1/s 
    #else
    binary::field<float, sc_float32, 288, it> max_LPS;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float max_frame_speed;//!<  maximum frame speed in deg/s 
    #else
    binary::field<float, sc_float32, 320, it> max_frame_speed;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    extents_1& operator=(const extents_1<ito>& o) {
        range_min = o.range_min;
        range_max = o.range_max;
        amplitude_min = o.amplitude_min;
        amplitude_max = o.amplitude_max;
        reflectance_min = o.reflectance_min;
        reflectance_max = o.reflectance_max;
        systime_bits = o.systime_bits;
        backgnd_rad_min = o.backgnd_rad_min;
        backgnd_rad_max = o.backgnd_rad_max;
        dev_min = o.dev_min;
        dev_max = o.dev_max;
        max_num_echoes = o.max_num_echoes;
        max_LPS = o.max_LPS;
        max_frame_speed = o.max_frame_speed;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct extents_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef extents_1<rebind_it> type;
    };

    enum { id_main = 57, id_sub = 1};

    float            range_min;
    float            range_max;
    float            amplitude_min;
    float            amplitude_max;
    float            reflectance_min;
    float            reflectance_max;
    uint16_t         systime_bits;
    uint16_t         backgnd_rad_min;
    uint16_t         backgnd_rad_max;
    int16_t          dev_min;
    int16_t          dev_max;
    uint16_t         max_num_echoes;
    float            max_LPS;
    float            max_frame_speed;

    extents_1()
        : range_min()
        , range_max()
        , amplitude_min()
        , amplitude_max()
        , reflectance_min()
        , reflectance_max()
        , systime_bits()
        , backgnd_rad_min()
        , backgnd_rad_max()
        , dev_min()
        , dev_max()
        , max_num_echoes()
        , max_LPS()
        , max_frame_speed()
    {}

    template<class it>
    extents_1(const extents_1<it>& o) {
        range_min = o.range_min;
        range_max = o.range_max;
        amplitude_min = o.amplitude_min;
        amplitude_max = o.amplitude_max;
        reflectance_min = o.reflectance_min;
        reflectance_max = o.reflectance_max;
        systime_bits = o.systime_bits;
        backgnd_rad_min = o.backgnd_rad_min;
        backgnd_rad_max = o.backgnd_rad_max;
        dev_min = o.dev_min;
        dev_max = o.dev_max;
        max_num_echoes = o.max_num_echoes;
        max_LPS = o.max_LPS;
        max_frame_speed = o.max_frame_speed;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const extents_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range_min;
        s << ", " << x.range_max;
        s << ", " << x.amplitude_min;
        s << ", " << x.amplitude_max;
        s << ", " << x.reflectance_min;
        s << ", " << x.reflectance_max;
        s << ", " << x.systime_bits;
        s << ", " << x.backgnd_rad_min;
        s << ", " << x.backgnd_rad_max;
        s << ", " << x.dev_min;
        s << ", " << x.dev_max;
        s << ", " << x.max_num_echoes;
        s << ", " << x.max_LPS;
        s << ", " << x.max_frame_speed;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, extents_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range_min;
        s >> ',' >> x.range_max;
        s >> ',' >> x.amplitude_min;
        s >> ',' >> x.amplitude_max;
        s >> ',' >> x.reflectance_min;
        s >> ',' >> x.reflectance_max;
        s >> ',' >> x.systime_bits;
        s >> ',' >> x.backgnd_rad_min;
        s >> ',' >> x.backgnd_rad_max;
        s >> ',' >> x.dev_min;
        s >> ',' >> x.dev_max;
        s >> ',' >> x.max_num_echoes;
        s >> ',' >> x.max_LPS;
        s >> ',' >> x.max_frame_speed;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct external_gnss_cfg
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef external_gnss_cfg<rebind_it> type;
    };

    typedef it iterator_type;

    external_gnss_cfg(it begin, it end, bool dirty=false)
        : mode(begin)
        , format(begin)
        , com_baudrate(begin)
        , com_protocol(begin)
        , udp_port_number(begin)
        , edge(begin)
        , sequence(begin)
        , sequence_timeout(begin)
        , off_detect_timeout(begin)
        , antenna_mount_name(begin)
        , antenna_mount(begin)
        , ucs_rot_angle(begin)
        , supply_voltage(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 73, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 808};
    it begin() const { return mode.begin(); }
    it end() const { return supply_voltage.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t mode;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> mode;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t format;
    #else
    binary::field<uint8_t, sc_uint8, 8, it> format;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t com_baudrate;
    #else
    binary::field<uint8_t, sc_uint8, 16, it> com_baudrate;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t com_protocol;
    #else
    binary::field<uint8_t, sc_uint8, 24, it> com_protocol;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t udp_port_number;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> udp_port_number;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t edge;
    #else
    binary::field<uint8_t, sc_uint8, 48, it> edge;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t sequence;
    #else
    binary::field<uint8_t, sc_uint8, 56, it> sequence;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float sequence_timeout;
    #else
    binary::field<float, sc_float32, 64, it> sequence_timeout;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float off_detect_timeout;
    #else
    binary::field<float, sc_float32, 96, it> off_detect_timeout;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char antenna_mount_name[65];
    #else
    binary::array<char, 65, sc_char, 128, it> antenna_mount_name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float antenna_mount[3];
    #else
    binary::array<float, 3, sc_float32, 648, it> antenna_mount;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float ucs_rot_angle;
    #else
    binary::field<float, sc_float32, 744, it> ucs_rot_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float supply_voltage;
    #else
    binary::field<float, sc_float32, 776, it> supply_voltage;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    external_gnss_cfg& operator=(const external_gnss_cfg<ito>& o) {
        mode = o.mode;
        format = o.format;
        com_baudrate = o.com_baudrate;
        com_protocol = o.com_protocol;
        udp_port_number = o.udp_port_number;
        edge = o.edge;
        sequence = o.sequence;
        sequence_timeout = o.sequence_timeout;
        off_detect_timeout = o.off_detect_timeout;
        for(unsigned n=0; n<65; ++n) antenna_mount_name[n] = o.antenna_mount_name[n];
        for(unsigned n=0; n<3; ++n) antenna_mount[n] = o.antenna_mount[n];
        ucs_rot_angle = o.ucs_rot_angle;
        supply_voltage = o.supply_voltage;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct external_gnss_cfg<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef external_gnss_cfg<rebind_it> type;
    };

    enum { id_main = 73, id_sub = 0};

    uint8_t          mode;
    uint8_t          format;
    uint8_t          com_baudrate;
    uint8_t          com_protocol;
    uint16_t         udp_port_number;
    uint8_t          edge;
    uint8_t          sequence;
    float            sequence_timeout;
    float            off_detect_timeout;
    char             antenna_mount_name[65];
    float            antenna_mount[3];
    float            ucs_rot_angle;
    float            supply_voltage;

    external_gnss_cfg()
        : mode()
        , format()
        , com_baudrate()
        , com_protocol()
        , udp_port_number()
        , edge()
        , sequence()
        , sequence_timeout()
        , off_detect_timeout()
        , antenna_mount_name()
        , antenna_mount()
        , ucs_rot_angle()
        , supply_voltage()
    {}

    template<class it>
    external_gnss_cfg(const external_gnss_cfg<it>& o) {
        mode = o.mode;
        format = o.format;
        com_baudrate = o.com_baudrate;
        com_protocol = o.com_protocol;
        udp_port_number = o.udp_port_number;
        edge = o.edge;
        sequence = o.sequence;
        sequence_timeout = o.sequence_timeout;
        off_detect_timeout = o.off_detect_timeout;
        for(unsigned n=0; n<65; ++n) antenna_mount_name[n] = o.antenna_mount_name[n];
        for(unsigned n=0; n<3; ++n) antenna_mount[n] = o.antenna_mount[n];
        ucs_rot_angle = o.ucs_rot_angle;
        supply_voltage = o.supply_voltage;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const external_gnss_cfg<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.mode;
        s << ", " << x.format;
        s << ", " << x.com_baudrate;
        s << ", " << x.com_protocol;
        s << ", " << x.udp_port_number;
        s << ", " << x.edge;
        s << ", " << x.sequence;
        s << ", " << x.sequence_timeout;
        s << ", " << x.off_detect_timeout;
        s << ", "; write_array(s, 65, x.antenna_mount_name);
        s << ", "; write_array(s, 3, x.antenna_mount);
        s << ", " << x.ucs_rot_angle;
        s << ", " << x.supply_voltage;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, external_gnss_cfg<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.mode;
        s >> ',' >> x.format;
        s >> ',' >> x.com_baudrate;
        s >> ',' >> x.com_protocol;
        s >> ',' >> x.udp_port_number;
        s >> ',' >> x.edge;
        s >> ',' >> x.sequence;
        s >> ',' >> x.sequence_timeout;
        s >> ',' >> x.off_detect_timeout;
        s >> ','; read_array(s, 65, x.antenna_mount_name);
        s >> ','; read_array(s, 3, x.antenna_mount);
        s >> ',' >> x.ucs_rot_angle;
        s >> ',' >> x.supply_voltage;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct external_gnss_cfg_ext
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef external_gnss_cfg_ext<rebind_it> type;
    };

    typedef it iterator_type;

    external_gnss_cfg_ext(it begin, it end, bool dirty=false)
        : mode(begin)
        , format(begin)
        , com_baudrate(begin)
        , com_protocol(begin)
        , udp_port_number(begin)
        , edge(begin)
        , sequence(begin)
        , sequence_timeout(begin)
        , off_detect_timeout(begin)
        , antenna_mount_name(begin)
        , antenna_mount(begin)
        , ucs_rot_angle(begin)
        , supply_voltage(begin)
        , antenna_user_offset(begin)
        , fix_pos_switch(begin)
        , fix_pos_latitude(begin)
        , fix_pos_longitude(begin)
        , fix_pos_height(begin)
        , fix_pos_hmsl(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 73, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 1104};
    it begin() const { return mode.begin(); }
    it end() const { return fix_pos_hmsl.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t mode;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> mode;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t format;
    #else
    binary::field<uint8_t, sc_uint8, 8, it> format;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t com_baudrate;
    #else
    binary::field<uint8_t, sc_uint8, 16, it> com_baudrate;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t com_protocol;
    #else
    binary::field<uint8_t, sc_uint8, 24, it> com_protocol;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t udp_port_number;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> udp_port_number;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t edge;
    #else
    binary::field<uint8_t, sc_uint8, 48, it> edge;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t sequence;
    #else
    binary::field<uint8_t, sc_uint8, 56, it> sequence;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float sequence_timeout;
    #else
    binary::field<float, sc_float32, 64, it> sequence_timeout;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float off_detect_timeout;
    #else
    binary::field<float, sc_float32, 96, it> off_detect_timeout;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char antenna_mount_name[65];
    #else
    binary::array<char, 65, sc_char, 128, it> antenna_mount_name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float antenna_mount[3];
    #else
    binary::array<float, 3, sc_float32, 648, it> antenna_mount;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float ucs_rot_angle;
    #else
    binary::field<float, sc_float32, 744, it> ucs_rot_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float supply_voltage;
    #else
    binary::field<float, sc_float32, 776, it> supply_voltage;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float antenna_user_offset;
    #else
    binary::field<float, sc_float32, 808, it> antenna_user_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t fix_pos_switch;
    #else
    binary::field<uint8_t, sc_uint8, 840, it> fix_pos_switch;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double fix_pos_latitude;
    #else
    binary::field<double, sc_float64, 848, it> fix_pos_latitude;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double fix_pos_longitude;
    #else
    binary::field<double, sc_float64, 912, it> fix_pos_longitude;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double fix_pos_height;
    #else
    binary::field<double, sc_float64, 976, it> fix_pos_height;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double fix_pos_hmsl;
    #else
    binary::field<double, sc_float64, 1040, it> fix_pos_hmsl;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    external_gnss_cfg_ext& operator=(const external_gnss_cfg_ext<ito>& o) {
        mode = o.mode;
        format = o.format;
        com_baudrate = o.com_baudrate;
        com_protocol = o.com_protocol;
        udp_port_number = o.udp_port_number;
        edge = o.edge;
        sequence = o.sequence;
        sequence_timeout = o.sequence_timeout;
        off_detect_timeout = o.off_detect_timeout;
        for(unsigned n=0; n<65; ++n) antenna_mount_name[n] = o.antenna_mount_name[n];
        for(unsigned n=0; n<3; ++n) antenna_mount[n] = o.antenna_mount[n];
        ucs_rot_angle = o.ucs_rot_angle;
        supply_voltage = o.supply_voltage;
        antenna_user_offset = o.antenna_user_offset;
        fix_pos_switch = o.fix_pos_switch;
        fix_pos_latitude = o.fix_pos_latitude;
        fix_pos_longitude = o.fix_pos_longitude;
        fix_pos_height = o.fix_pos_height;
        fix_pos_hmsl = o.fix_pos_hmsl;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct external_gnss_cfg_ext<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef external_gnss_cfg_ext<rebind_it> type;
    };

    enum { id_main = 73, id_sub = 1};

    uint8_t          mode;
    uint8_t          format;
    uint8_t          com_baudrate;
    uint8_t          com_protocol;
    uint16_t         udp_port_number;
    uint8_t          edge;
    uint8_t          sequence;
    float            sequence_timeout;
    float            off_detect_timeout;
    char             antenna_mount_name[65];
    float            antenna_mount[3];
    float            ucs_rot_angle;
    float            supply_voltage;
    float            antenna_user_offset;
    uint8_t          fix_pos_switch;
    double           fix_pos_latitude;
    double           fix_pos_longitude;
    double           fix_pos_height;
    double           fix_pos_hmsl;

    external_gnss_cfg_ext()
        : mode()
        , format()
        , com_baudrate()
        , com_protocol()
        , udp_port_number()
        , edge()
        , sequence()
        , sequence_timeout()
        , off_detect_timeout()
        , antenna_mount_name()
        , antenna_mount()
        , ucs_rot_angle()
        , supply_voltage()
        , antenna_user_offset()
        , fix_pos_switch()
        , fix_pos_latitude()
        , fix_pos_longitude()
        , fix_pos_height()
        , fix_pos_hmsl()
    {}

    template<class it>
    external_gnss_cfg_ext(const external_gnss_cfg_ext<it>& o) {
        mode = o.mode;
        format = o.format;
        com_baudrate = o.com_baudrate;
        com_protocol = o.com_protocol;
        udp_port_number = o.udp_port_number;
        edge = o.edge;
        sequence = o.sequence;
        sequence_timeout = o.sequence_timeout;
        off_detect_timeout = o.off_detect_timeout;
        for(unsigned n=0; n<65; ++n) antenna_mount_name[n] = o.antenna_mount_name[n];
        for(unsigned n=0; n<3; ++n) antenna_mount[n] = o.antenna_mount[n];
        ucs_rot_angle = o.ucs_rot_angle;
        supply_voltage = o.supply_voltage;
        antenna_user_offset = o.antenna_user_offset;
        fix_pos_switch = o.fix_pos_switch;
        fix_pos_latitude = o.fix_pos_latitude;
        fix_pos_longitude = o.fix_pos_longitude;
        fix_pos_height = o.fix_pos_height;
        fix_pos_hmsl = o.fix_pos_hmsl;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const external_gnss_cfg_ext<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.mode;
        s << ", " << x.format;
        s << ", " << x.com_baudrate;
        s << ", " << x.com_protocol;
        s << ", " << x.udp_port_number;
        s << ", " << x.edge;
        s << ", " << x.sequence;
        s << ", " << x.sequence_timeout;
        s << ", " << x.off_detect_timeout;
        s << ", "; write_array(s, 65, x.antenna_mount_name);
        s << ", "; write_array(s, 3, x.antenna_mount);
        s << ", " << x.ucs_rot_angle;
        s << ", " << x.supply_voltage;
        s << ", " << x.antenna_user_offset;
        s << ", " << x.fix_pos_switch;
        s << ", " << x.fix_pos_latitude;
        s << ", " << x.fix_pos_longitude;
        s << ", " << x.fix_pos_height;
        s << ", " << x.fix_pos_hmsl;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, external_gnss_cfg_ext<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.mode;
        s >> ',' >> x.format;
        s >> ',' >> x.com_baudrate;
        s >> ',' >> x.com_protocol;
        s >> ',' >> x.udp_port_number;
        s >> ',' >> x.edge;
        s >> ',' >> x.sequence;
        s >> ',' >> x.sequence_timeout;
        s >> ',' >> x.off_detect_timeout;
        s >> ','; read_array(s, 65, x.antenna_mount_name);
        s >> ','; read_array(s, 3, x.antenna_mount);
        s >> ',' >> x.ucs_rot_angle;
        s >> ',' >> x.supply_voltage;
        s >> ',' >> x.antenna_user_offset;
        s >> ',' >> x.fix_pos_switch;
        s >> ',' >> x.fix_pos_latitude;
        s >> ',' >> x.fix_pos_longitude;
        s >> ',' >> x.fix_pos_height;
        s >> ',' >> x.fix_pos_hmsl;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct firmware
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef firmware<rebind_it> type;
    };

    typedef it iterator_type;

    firmware(it begin, it end, bool dirty=false)
        : id(begin)
        , v_uboot(begin)
        , v_linux(begin)
        , v_ctrlproc(begin)
        , v_scnproc(begin)
        , v_rcvpic(begin)
        , v_eslpic(begin)
        , v_mb_fpga(begin)
        , v_acq_fpga(begin)
        , v_acq_commpb(begin)
        , v_acq_rprpb(begin)
        , v_acq_dlec(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 8, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 3072};
    it begin() const { return id.begin(); }
    it end() const { return v_acq_dlec.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char id[64];
    #else
    binary::array<char, 64, sc_char, 0, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_uboot[64];
    #else
    binary::array<char, 64, sc_char, 512, it> v_uboot;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_linux[16];
    #else
    binary::array<char, 16, sc_char, 1024, it> v_linux;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_ctrlproc[64];
    #else
    binary::array<char, 64, sc_char, 1152, it> v_ctrlproc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_scnproc[64];
    #else
    binary::array<char, 64, sc_char, 1664, it> v_scnproc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_rcvpic[16];
    #else
    binary::array<char, 16, sc_char, 2176, it> v_rcvpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_eslpic[16];
    #else
    binary::array<char, 16, sc_char, 2304, it> v_eslpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_mb_fpga[16];
    #else
    binary::array<char, 16, sc_char, 2432, it> v_mb_fpga;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_fpga[16];
    #else
    binary::array<char, 16, sc_char, 2560, it> v_acq_fpga;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_commpb[16];
    #else
    binary::array<char, 16, sc_char, 2688, it> v_acq_commpb;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_rprpb[16];
    #else
    binary::array<char, 16, sc_char, 2816, it> v_acq_rprpb;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_dlec[16];
    #else
    binary::array<char, 16, sc_char, 2944, it> v_acq_dlec;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    firmware& operator=(const firmware<ito>& o) {
        for(unsigned n=0; n<64; ++n) id[n] = o.id[n];
        for(unsigned n=0; n<64; ++n) v_uboot[n] = o.v_uboot[n];
        for(unsigned n=0; n<16; ++n) v_linux[n] = o.v_linux[n];
        for(unsigned n=0; n<64; ++n) v_ctrlproc[n] = o.v_ctrlproc[n];
        for(unsigned n=0; n<64; ++n) v_scnproc[n] = o.v_scnproc[n];
        for(unsigned n=0; n<16; ++n) v_rcvpic[n] = o.v_rcvpic[n];
        for(unsigned n=0; n<16; ++n) v_eslpic[n] = o.v_eslpic[n];
        for(unsigned n=0; n<16; ++n) v_mb_fpga[n] = o.v_mb_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_fpga[n] = o.v_acq_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_commpb[n] = o.v_acq_commpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_rprpb[n] = o.v_acq_rprpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_dlec[n] = o.v_acq_dlec[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct firmware<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef firmware<rebind_it> type;
    };

    enum { id_main = 8, id_sub = 0};

    char             id[64];
    char             v_uboot[64];
    char             v_linux[16];
    char             v_ctrlproc[64];
    char             v_scnproc[64];
    char             v_rcvpic[16];
    char             v_eslpic[16];
    char             v_mb_fpga[16];
    char             v_acq_fpga[16];
    char             v_acq_commpb[16];
    char             v_acq_rprpb[16];
    char             v_acq_dlec[16];

    firmware()
        : id()
        , v_uboot()
        , v_linux()
        , v_ctrlproc()
        , v_scnproc()
        , v_rcvpic()
        , v_eslpic()
        , v_mb_fpga()
        , v_acq_fpga()
        , v_acq_commpb()
        , v_acq_rprpb()
        , v_acq_dlec()
    {}

    template<class it>
    firmware(const firmware<it>& o) {
        for(unsigned n=0; n<64; ++n) id[n] = o.id[n];
        for(unsigned n=0; n<64; ++n) v_uboot[n] = o.v_uboot[n];
        for(unsigned n=0; n<16; ++n) v_linux[n] = o.v_linux[n];
        for(unsigned n=0; n<64; ++n) v_ctrlproc[n] = o.v_ctrlproc[n];
        for(unsigned n=0; n<64; ++n) v_scnproc[n] = o.v_scnproc[n];
        for(unsigned n=0; n<16; ++n) v_rcvpic[n] = o.v_rcvpic[n];
        for(unsigned n=0; n<16; ++n) v_eslpic[n] = o.v_eslpic[n];
        for(unsigned n=0; n<16; ++n) v_mb_fpga[n] = o.v_mb_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_fpga[n] = o.v_acq_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_commpb[n] = o.v_acq_commpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_rprpb[n] = o.v_acq_rprpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_dlec[n] = o.v_acq_dlec[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const firmware<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 64, x.id);
        s << ", "; write_array(s, 64, x.v_uboot);
        s << ", "; write_array(s, 16, x.v_linux);
        s << ", "; write_array(s, 64, x.v_ctrlproc);
        s << ", "; write_array(s, 64, x.v_scnproc);
        s << ", "; write_array(s, 16, x.v_rcvpic);
        s << ", "; write_array(s, 16, x.v_eslpic);
        s << ", "; write_array(s, 16, x.v_mb_fpga);
        s << ", "; write_array(s, 16, x.v_acq_fpga);
        s << ", "; write_array(s, 16, x.v_acq_commpb);
        s << ", "; write_array(s, 16, x.v_acq_rprpb);
        s << ", "; write_array(s, 16, x.v_acq_dlec);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, firmware<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 64, x.id);
        s >> ','; read_array(s, 64, x.v_uboot);
        s >> ','; read_array(s, 16, x.v_linux);
        s >> ','; read_array(s, 64, x.v_ctrlproc);
        s >> ','; read_array(s, 64, x.v_scnproc);
        s >> ','; read_array(s, 16, x.v_rcvpic);
        s >> ','; read_array(s, 16, x.v_eslpic);
        s >> ','; read_array(s, 16, x.v_mb_fpga);
        s >> ','; read_array(s, 16, x.v_acq_fpga);
        s >> ','; read_array(s, 16, x.v_acq_commpb);
        s >> ','; read_array(s, 16, x.v_acq_rprpb);
        s >> ','; read_array(s, 16, x.v_acq_dlec);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct firmware_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef firmware_1<rebind_it> type;
    };

    typedef it iterator_type;

    firmware_1(it begin, it end, bool dirty=false)
        : id(begin)
        , v_uboot(begin)
        , v_linux(begin)
        , v_ctrlproc(begin)
        , v_scnproc(begin)
        , v_rcvpic(begin)
        , v_eslpic(begin)
        , v_mb_fpga(begin)
        , v_acq_fpga(begin)
        , v_acq_commpb(begin)
        , v_acq_rprpb(begin)
        , v_acq_dlec(begin)
        , v_inclpic(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 8, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 3200};
    it begin() const { return id.begin(); }
    it end() const { return v_inclpic.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char id[64];
    #else
    binary::array<char, 64, sc_char, 0, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_uboot[64];
    #else
    binary::array<char, 64, sc_char, 512, it> v_uboot;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_linux[16];
    #else
    binary::array<char, 16, sc_char, 1024, it> v_linux;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_ctrlproc[64];
    #else
    binary::array<char, 64, sc_char, 1152, it> v_ctrlproc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_scnproc[64];
    #else
    binary::array<char, 64, sc_char, 1664, it> v_scnproc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_rcvpic[16];
    #else
    binary::array<char, 16, sc_char, 2176, it> v_rcvpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_eslpic[16];
    #else
    binary::array<char, 16, sc_char, 2304, it> v_eslpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_mb_fpga[16];
    #else
    binary::array<char, 16, sc_char, 2432, it> v_mb_fpga;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_fpga[16];
    #else
    binary::array<char, 16, sc_char, 2560, it> v_acq_fpga;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_commpb[16];
    #else
    binary::array<char, 16, sc_char, 2688, it> v_acq_commpb;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_rprpb[16];
    #else
    binary::array<char, 16, sc_char, 2816, it> v_acq_rprpb;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_dlec[16];
    #else
    binary::array<char, 16, sc_char, 2944, it> v_acq_dlec;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_inclpic[16];
    #else
    binary::array<char, 16, sc_char, 3072, it> v_inclpic;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    firmware_1& operator=(const firmware_1<ito>& o) {
        for(unsigned n=0; n<64; ++n) id[n] = o.id[n];
        for(unsigned n=0; n<64; ++n) v_uboot[n] = o.v_uboot[n];
        for(unsigned n=0; n<16; ++n) v_linux[n] = o.v_linux[n];
        for(unsigned n=0; n<64; ++n) v_ctrlproc[n] = o.v_ctrlproc[n];
        for(unsigned n=0; n<64; ++n) v_scnproc[n] = o.v_scnproc[n];
        for(unsigned n=0; n<16; ++n) v_rcvpic[n] = o.v_rcvpic[n];
        for(unsigned n=0; n<16; ++n) v_eslpic[n] = o.v_eslpic[n];
        for(unsigned n=0; n<16; ++n) v_mb_fpga[n] = o.v_mb_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_fpga[n] = o.v_acq_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_commpb[n] = o.v_acq_commpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_rprpb[n] = o.v_acq_rprpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_dlec[n] = o.v_acq_dlec[n];
        for(unsigned n=0; n<16; ++n) v_inclpic[n] = o.v_inclpic[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct firmware_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef firmware_1<rebind_it> type;
    };

    enum { id_main = 8, id_sub = 1};

    char             id[64];
    char             v_uboot[64];
    char             v_linux[16];
    char             v_ctrlproc[64];
    char             v_scnproc[64];
    char             v_rcvpic[16];
    char             v_eslpic[16];
    char             v_mb_fpga[16];
    char             v_acq_fpga[16];
    char             v_acq_commpb[16];
    char             v_acq_rprpb[16];
    char             v_acq_dlec[16];
    char             v_inclpic[16];

    firmware_1()
        : id()
        , v_uboot()
        , v_linux()
        , v_ctrlproc()
        , v_scnproc()
        , v_rcvpic()
        , v_eslpic()
        , v_mb_fpga()
        , v_acq_fpga()
        , v_acq_commpb()
        , v_acq_rprpb()
        , v_acq_dlec()
        , v_inclpic()
    {}

    template<class it>
    firmware_1(const firmware_1<it>& o) {
        for(unsigned n=0; n<64; ++n) id[n] = o.id[n];
        for(unsigned n=0; n<64; ++n) v_uboot[n] = o.v_uboot[n];
        for(unsigned n=0; n<16; ++n) v_linux[n] = o.v_linux[n];
        for(unsigned n=0; n<64; ++n) v_ctrlproc[n] = o.v_ctrlproc[n];
        for(unsigned n=0; n<64; ++n) v_scnproc[n] = o.v_scnproc[n];
        for(unsigned n=0; n<16; ++n) v_rcvpic[n] = o.v_rcvpic[n];
        for(unsigned n=0; n<16; ++n) v_eslpic[n] = o.v_eslpic[n];
        for(unsigned n=0; n<16; ++n) v_mb_fpga[n] = o.v_mb_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_fpga[n] = o.v_acq_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_commpb[n] = o.v_acq_commpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_rprpb[n] = o.v_acq_rprpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_dlec[n] = o.v_acq_dlec[n];
        for(unsigned n=0; n<16; ++n) v_inclpic[n] = o.v_inclpic[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const firmware_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 64, x.id);
        s << ", "; write_array(s, 64, x.v_uboot);
        s << ", "; write_array(s, 16, x.v_linux);
        s << ", "; write_array(s, 64, x.v_ctrlproc);
        s << ", "; write_array(s, 64, x.v_scnproc);
        s << ", "; write_array(s, 16, x.v_rcvpic);
        s << ", "; write_array(s, 16, x.v_eslpic);
        s << ", "; write_array(s, 16, x.v_mb_fpga);
        s << ", "; write_array(s, 16, x.v_acq_fpga);
        s << ", "; write_array(s, 16, x.v_acq_commpb);
        s << ", "; write_array(s, 16, x.v_acq_rprpb);
        s << ", "; write_array(s, 16, x.v_acq_dlec);
        s << ", "; write_array(s, 16, x.v_inclpic);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, firmware_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 64, x.id);
        s >> ','; read_array(s, 64, x.v_uboot);
        s >> ','; read_array(s, 16, x.v_linux);
        s >> ','; read_array(s, 64, x.v_ctrlproc);
        s >> ','; read_array(s, 64, x.v_scnproc);
        s >> ','; read_array(s, 16, x.v_rcvpic);
        s >> ','; read_array(s, 16, x.v_eslpic);
        s >> ','; read_array(s, 16, x.v_mb_fpga);
        s >> ','; read_array(s, 16, x.v_acq_fpga);
        s >> ','; read_array(s, 16, x.v_acq_commpb);
        s >> ','; read_array(s, 16, x.v_acq_rprpb);
        s >> ','; read_array(s, 16, x.v_acq_dlec);
        s >> ','; read_array(s, 16, x.v_inclpic);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct firmware_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef firmware_2<rebind_it> type;
    };

    typedef it iterator_type;

    firmware_2(it begin, it end, bool dirty=false)
        : id(begin)
        , v_uboot(begin)
        , v_linux(begin)
        , v_ctrlproc(begin)
        , v_scnproc(begin)
        , v_rcvpic(begin)
        , v_eslpic(begin)
        , v_mb_fpga(begin)
        , v_acq_fpga(begin)
        , v_acq_commpb(begin)
        , v_acq_rprpb(begin)
        , v_acq_dlec(begin)
        , v_inclpic(begin)
        , v_disppic(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 8, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 3328};
    it begin() const { return id.begin(); }
    it end() const { return v_disppic.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char id[64];
    #else
    binary::array<char, 64, sc_char, 0, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_uboot[64];
    #else
    binary::array<char, 64, sc_char, 512, it> v_uboot;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_linux[16];
    #else
    binary::array<char, 16, sc_char, 1024, it> v_linux;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_ctrlproc[64];
    #else
    binary::array<char, 64, sc_char, 1152, it> v_ctrlproc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_scnproc[64];
    #else
    binary::array<char, 64, sc_char, 1664, it> v_scnproc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_rcvpic[16];
    #else
    binary::array<char, 16, sc_char, 2176, it> v_rcvpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_eslpic[16];
    #else
    binary::array<char, 16, sc_char, 2304, it> v_eslpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_mb_fpga[16];
    #else
    binary::array<char, 16, sc_char, 2432, it> v_mb_fpga;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_fpga[16];
    #else
    binary::array<char, 16, sc_char, 2560, it> v_acq_fpga;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_commpb[16];
    #else
    binary::array<char, 16, sc_char, 2688, it> v_acq_commpb;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_rprpb[16];
    #else
    binary::array<char, 16, sc_char, 2816, it> v_acq_rprpb;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_dlec[16];
    #else
    binary::array<char, 16, sc_char, 2944, it> v_acq_dlec;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_inclpic[16];
    #else
    binary::array<char, 16, sc_char, 3072, it> v_inclpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_disppic[16];
    #else
    binary::array<char, 16, sc_char, 3200, it> v_disppic;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    firmware_2& operator=(const firmware_2<ito>& o) {
        for(unsigned n=0; n<64; ++n) id[n] = o.id[n];
        for(unsigned n=0; n<64; ++n) v_uboot[n] = o.v_uboot[n];
        for(unsigned n=0; n<16; ++n) v_linux[n] = o.v_linux[n];
        for(unsigned n=0; n<64; ++n) v_ctrlproc[n] = o.v_ctrlproc[n];
        for(unsigned n=0; n<64; ++n) v_scnproc[n] = o.v_scnproc[n];
        for(unsigned n=0; n<16; ++n) v_rcvpic[n] = o.v_rcvpic[n];
        for(unsigned n=0; n<16; ++n) v_eslpic[n] = o.v_eslpic[n];
        for(unsigned n=0; n<16; ++n) v_mb_fpga[n] = o.v_mb_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_fpga[n] = o.v_acq_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_commpb[n] = o.v_acq_commpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_rprpb[n] = o.v_acq_rprpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_dlec[n] = o.v_acq_dlec[n];
        for(unsigned n=0; n<16; ++n) v_inclpic[n] = o.v_inclpic[n];
        for(unsigned n=0; n<16; ++n) v_disppic[n] = o.v_disppic[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct firmware_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef firmware_2<rebind_it> type;
    };

    enum { id_main = 8, id_sub = 2};

    char             id[64];
    char             v_uboot[64];
    char             v_linux[16];
    char             v_ctrlproc[64];
    char             v_scnproc[64];
    char             v_rcvpic[16];
    char             v_eslpic[16];
    char             v_mb_fpga[16];
    char             v_acq_fpga[16];
    char             v_acq_commpb[16];
    char             v_acq_rprpb[16];
    char             v_acq_dlec[16];
    char             v_inclpic[16];
    char             v_disppic[16];

    firmware_2()
        : id()
        , v_uboot()
        , v_linux()
        , v_ctrlproc()
        , v_scnproc()
        , v_rcvpic()
        , v_eslpic()
        , v_mb_fpga()
        , v_acq_fpga()
        , v_acq_commpb()
        , v_acq_rprpb()
        , v_acq_dlec()
        , v_inclpic()
        , v_disppic()
    {}

    template<class it>
    firmware_2(const firmware_2<it>& o) {
        for(unsigned n=0; n<64; ++n) id[n] = o.id[n];
        for(unsigned n=0; n<64; ++n) v_uboot[n] = o.v_uboot[n];
        for(unsigned n=0; n<16; ++n) v_linux[n] = o.v_linux[n];
        for(unsigned n=0; n<64; ++n) v_ctrlproc[n] = o.v_ctrlproc[n];
        for(unsigned n=0; n<64; ++n) v_scnproc[n] = o.v_scnproc[n];
        for(unsigned n=0; n<16; ++n) v_rcvpic[n] = o.v_rcvpic[n];
        for(unsigned n=0; n<16; ++n) v_eslpic[n] = o.v_eslpic[n];
        for(unsigned n=0; n<16; ++n) v_mb_fpga[n] = o.v_mb_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_fpga[n] = o.v_acq_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_commpb[n] = o.v_acq_commpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_rprpb[n] = o.v_acq_rprpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_dlec[n] = o.v_acq_dlec[n];
        for(unsigned n=0; n<16; ++n) v_inclpic[n] = o.v_inclpic[n];
        for(unsigned n=0; n<16; ++n) v_disppic[n] = o.v_disppic[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const firmware_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 64, x.id);
        s << ", "; write_array(s, 64, x.v_uboot);
        s << ", "; write_array(s, 16, x.v_linux);
        s << ", "; write_array(s, 64, x.v_ctrlproc);
        s << ", "; write_array(s, 64, x.v_scnproc);
        s << ", "; write_array(s, 16, x.v_rcvpic);
        s << ", "; write_array(s, 16, x.v_eslpic);
        s << ", "; write_array(s, 16, x.v_mb_fpga);
        s << ", "; write_array(s, 16, x.v_acq_fpga);
        s << ", "; write_array(s, 16, x.v_acq_commpb);
        s << ", "; write_array(s, 16, x.v_acq_rprpb);
        s << ", "; write_array(s, 16, x.v_acq_dlec);
        s << ", "; write_array(s, 16, x.v_inclpic);
        s << ", "; write_array(s, 16, x.v_disppic);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, firmware_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 64, x.id);
        s >> ','; read_array(s, 64, x.v_uboot);
        s >> ','; read_array(s, 16, x.v_linux);
        s >> ','; read_array(s, 64, x.v_ctrlproc);
        s >> ','; read_array(s, 64, x.v_scnproc);
        s >> ','; read_array(s, 16, x.v_rcvpic);
        s >> ','; read_array(s, 16, x.v_eslpic);
        s >> ','; read_array(s, 16, x.v_mb_fpga);
        s >> ','; read_array(s, 16, x.v_acq_fpga);
        s >> ','; read_array(s, 16, x.v_acq_commpb);
        s >> ','; read_array(s, 16, x.v_acq_rprpb);
        s >> ','; read_array(s, 16, x.v_acq_dlec);
        s >> ','; read_array(s, 16, x.v_inclpic);
        s >> ','; read_array(s, 16, x.v_disppic);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct firmware_3
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef firmware_3<rebind_it> type;
    };

    typedef it iterator_type;

    firmware_3(it begin, it end, bool dirty=false)
        : id(begin)
        , v_uboot(begin)
        , v_linux(begin)
        , v_ctrlproc(begin)
        , v_scnproc(begin)
        , v_rcvpic(begin)
        , v_eslpic(begin)
        , v_mb_fpga(begin)
        , v_acq_fpga(begin)
        , v_acq_commpb(begin)
        , v_acq_rprpb(begin)
        , v_acq_dlec(begin)
        , v_inclpic(begin)
        , v_disppic(begin)
        , v_inclpic2(begin)
        , v_HTRpic(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 8, id_sub = 3};
    #ifndef DOXYGEN
    enum { max_bit_width = 3584};
    it begin() const { return id.begin(); }
    it end() const { return v_HTRpic.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char id[64];
    #else
    binary::array<char, 64, sc_char, 0, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_uboot[64];
    #else
    binary::array<char, 64, sc_char, 512, it> v_uboot;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_linux[16];
    #else
    binary::array<char, 16, sc_char, 1024, it> v_linux;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_ctrlproc[64];
    #else
    binary::array<char, 64, sc_char, 1152, it> v_ctrlproc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_scnproc[64];
    #else
    binary::array<char, 64, sc_char, 1664, it> v_scnproc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_rcvpic[16];
    #else
    binary::array<char, 16, sc_char, 2176, it> v_rcvpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_eslpic[16];
    #else
    binary::array<char, 16, sc_char, 2304, it> v_eslpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_mb_fpga[16];
    #else
    binary::array<char, 16, sc_char, 2432, it> v_mb_fpga;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_fpga[16];
    #else
    binary::array<char, 16, sc_char, 2560, it> v_acq_fpga;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_commpb[16];
    #else
    binary::array<char, 16, sc_char, 2688, it> v_acq_commpb;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_rprpb[16];
    #else
    binary::array<char, 16, sc_char, 2816, it> v_acq_rprpb;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_acq_dlec[16];
    #else
    binary::array<char, 16, sc_char, 2944, it> v_acq_dlec;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_inclpic[16];
    #else
    binary::array<char, 16, sc_char, 3072, it> v_inclpic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_disppic[16];
    #else
    binary::array<char, 16, sc_char, 3200, it> v_disppic;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_inclpic2[16];
    #else
    binary::array<char, 16, sc_char, 3328, it> v_inclpic2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char v_HTRpic[16];
    #else
    binary::array<char, 16, sc_char, 3456, it> v_HTRpic;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    firmware_3& operator=(const firmware_3<ito>& o) {
        for(unsigned n=0; n<64; ++n) id[n] = o.id[n];
        for(unsigned n=0; n<64; ++n) v_uboot[n] = o.v_uboot[n];
        for(unsigned n=0; n<16; ++n) v_linux[n] = o.v_linux[n];
        for(unsigned n=0; n<64; ++n) v_ctrlproc[n] = o.v_ctrlproc[n];
        for(unsigned n=0; n<64; ++n) v_scnproc[n] = o.v_scnproc[n];
        for(unsigned n=0; n<16; ++n) v_rcvpic[n] = o.v_rcvpic[n];
        for(unsigned n=0; n<16; ++n) v_eslpic[n] = o.v_eslpic[n];
        for(unsigned n=0; n<16; ++n) v_mb_fpga[n] = o.v_mb_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_fpga[n] = o.v_acq_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_commpb[n] = o.v_acq_commpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_rprpb[n] = o.v_acq_rprpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_dlec[n] = o.v_acq_dlec[n];
        for(unsigned n=0; n<16; ++n) v_inclpic[n] = o.v_inclpic[n];
        for(unsigned n=0; n<16; ++n) v_disppic[n] = o.v_disppic[n];
        for(unsigned n=0; n<16; ++n) v_inclpic2[n] = o.v_inclpic2[n];
        for(unsigned n=0; n<16; ++n) v_HTRpic[n] = o.v_HTRpic[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct firmware_3<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef firmware_3<rebind_it> type;
    };

    enum { id_main = 8, id_sub = 3};

    char             id[64];
    char             v_uboot[64];
    char             v_linux[16];
    char             v_ctrlproc[64];
    char             v_scnproc[64];
    char             v_rcvpic[16];
    char             v_eslpic[16];
    char             v_mb_fpga[16];
    char             v_acq_fpga[16];
    char             v_acq_commpb[16];
    char             v_acq_rprpb[16];
    char             v_acq_dlec[16];
    char             v_inclpic[16];
    char             v_disppic[16];
    char             v_inclpic2[16];
    char             v_HTRpic[16];

    firmware_3()
        : id()
        , v_uboot()
        , v_linux()
        , v_ctrlproc()
        , v_scnproc()
        , v_rcvpic()
        , v_eslpic()
        , v_mb_fpga()
        , v_acq_fpga()
        , v_acq_commpb()
        , v_acq_rprpb()
        , v_acq_dlec()
        , v_inclpic()
        , v_disppic()
        , v_inclpic2()
        , v_HTRpic()
    {}

    template<class it>
    firmware_3(const firmware_3<it>& o) {
        for(unsigned n=0; n<64; ++n) id[n] = o.id[n];
        for(unsigned n=0; n<64; ++n) v_uboot[n] = o.v_uboot[n];
        for(unsigned n=0; n<16; ++n) v_linux[n] = o.v_linux[n];
        for(unsigned n=0; n<64; ++n) v_ctrlproc[n] = o.v_ctrlproc[n];
        for(unsigned n=0; n<64; ++n) v_scnproc[n] = o.v_scnproc[n];
        for(unsigned n=0; n<16; ++n) v_rcvpic[n] = o.v_rcvpic[n];
        for(unsigned n=0; n<16; ++n) v_eslpic[n] = o.v_eslpic[n];
        for(unsigned n=0; n<16; ++n) v_mb_fpga[n] = o.v_mb_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_fpga[n] = o.v_acq_fpga[n];
        for(unsigned n=0; n<16; ++n) v_acq_commpb[n] = o.v_acq_commpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_rprpb[n] = o.v_acq_rprpb[n];
        for(unsigned n=0; n<16; ++n) v_acq_dlec[n] = o.v_acq_dlec[n];
        for(unsigned n=0; n<16; ++n) v_inclpic[n] = o.v_inclpic[n];
        for(unsigned n=0; n<16; ++n) v_disppic[n] = o.v_disppic[n];
        for(unsigned n=0; n<16; ++n) v_inclpic2[n] = o.v_inclpic2[n];
        for(unsigned n=0; n<16; ++n) v_HTRpic[n] = o.v_HTRpic[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const firmware_3<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 64, x.id);
        s << ", "; write_array(s, 64, x.v_uboot);
        s << ", "; write_array(s, 16, x.v_linux);
        s << ", "; write_array(s, 64, x.v_ctrlproc);
        s << ", "; write_array(s, 64, x.v_scnproc);
        s << ", "; write_array(s, 16, x.v_rcvpic);
        s << ", "; write_array(s, 16, x.v_eslpic);
        s << ", "; write_array(s, 16, x.v_mb_fpga);
        s << ", "; write_array(s, 16, x.v_acq_fpga);
        s << ", "; write_array(s, 16, x.v_acq_commpb);
        s << ", "; write_array(s, 16, x.v_acq_rprpb);
        s << ", "; write_array(s, 16, x.v_acq_dlec);
        s << ", "; write_array(s, 16, x.v_inclpic);
        s << ", "; write_array(s, 16, x.v_disppic);
        s << ", "; write_array(s, 16, x.v_inclpic2);
        s << ", "; write_array(s, 16, x.v_HTRpic);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, firmware_3<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 64, x.id);
        s >> ','; read_array(s, 64, x.v_uboot);
        s >> ','; read_array(s, 16, x.v_linux);
        s >> ','; read_array(s, 64, x.v_ctrlproc);
        s >> ','; read_array(s, 64, x.v_scnproc);
        s >> ','; read_array(s, 16, x.v_rcvpic);
        s >> ','; read_array(s, 16, x.v_eslpic);
        s >> ','; read_array(s, 16, x.v_mb_fpga);
        s >> ','; read_array(s, 16, x.v_acq_fpga);
        s >> ','; read_array(s, 16, x.v_acq_commpb);
        s >> ','; read_array(s, 16, x.v_acq_rprpb);
        s >> ','; read_array(s, 16, x.v_acq_dlec);
        s >> ','; read_array(s, 16, x.v_inclpic);
        s >> ','; read_array(s, 16, x.v_disppic);
        s >> ','; read_array(s, 16, x.v_inclpic2);
        s >> ','; read_array(s, 16, x.v_HTRpic);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct fp_samples
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef fp_samples<rebind_it> type;
    };

    typedef it iterator_type;

    fp_samples(it begin, it end, bool dirty=false)
        : sample_rate(begin)
        , id(begin)
        , num_traces(begin)
        , num_samples(begin)
        , hw_start(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 128, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8388672};
    it begin() const { return sample_rate.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float sample_rate;
    #else
    binary::field<float, sc_float32, 0, it> sample_rate;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t id;
    #else
    binary::field<uint8_t, sc_uint4, 32, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_traces;
    #else
    binary::field<uint8_t, sc_uint8, 36, it> num_traces;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t num_samples;
    #else
    binary::field<uint16_t, sc_uint12, 44, it> num_samples;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hw_start;
    #else
    binary::field<uint8_t, sc_uint8, 56, it> hw_start;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : val(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float val;
        #else
        binary::field<float, sc_float32, 0, it> val;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[262144];
    #else
    sequence<fp_samples, 32, 64, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    fp_samples& operator=(const fp_samples<ito>& o) {
        sample_rate = o.sample_rate;
        id = o.id;
        num_traces = o.num_traces;
        num_samples = o.num_samples;
        hw_start = o.hw_start;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct fp_samples<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef fp_samples<rebind_it> type;
    };

    enum { id_main = 128, id_sub = 0};

    float            sample_rate;
    uint8_t          id;
    uint8_t          num_traces;
    uint16_t         num_samples;
    uint8_t          hw_start;
    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition {
        float            val;
    } data[262144];

    fp_samples()
        : sample_rate()
        , id()
        , num_traces()
        , num_samples()
        , hw_start()
    {}

    template<class it>
    fp_samples(const fp_samples<it>& o) {
        sample_rate = o.sample_rate;
        id = o.id;
        num_traces = o.num_traces;
        num_samples = o.num_samples;
        hw_start = o.hw_start;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const fp_samples<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.sample_rate;
        s << ", " << x.id;
        s << ", " << x.num_traces;
        s << ", " << x.num_samples;
        s << ", " << x.hw_start;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].val
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, fp_samples<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.sample_rate;
        s >> ',' >> x.id;
        s >> ',' >> x.num_traces;
        s >> ',' >> x.num_samples;
        s >> ',' >> x.hw_start;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].val)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct fp_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef fp_table<rebind_it> type;
    };

    typedef it iterator_type;

    fp_table(it begin, it end, bool dirty=false)
        : table_type(begin)
        , id(begin)
        , dp(begin)
        , num_x(begin)
        , num_y(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 141, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 65600};
    it begin() const { return table_type.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t table_type;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> table_type;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t id;
    #else
    binary::field<uint8_t, sc_uint8, 8, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t dp;
    #else
    binary::field<int16_t, sc_int16, 16, it> dp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t num_x;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> num_x;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t num_y;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> num_y;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : val(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int32_t val;
        #else
        binary::field<int32_t, sc_int32, 0, it> val;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[2048];
    #else
    sequence<fp_table, 32, 64, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    fp_table& operator=(const fp_table<ito>& o) {
        table_type = o.table_type;
        id = o.id;
        dp = o.dp;
        num_x = o.num_x;
        num_y = o.num_y;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct fp_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef fp_table<rebind_it> type;
    };

    enum { id_main = 141, id_sub = 0};

    uint8_t          table_type;
    uint8_t          id;
    int16_t          dp;
    uint16_t         num_x;
    uint16_t         num_y;
    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition {
        int32_t          val;
    } data[2048];

    fp_table()
        : table_type()
        , id()
        , dp()
        , num_x()
        , num_y()
    {}

    template<class it>
    fp_table(const fp_table<it>& o) {
        table_type = o.table_type;
        id = o.id;
        dp = o.dp;
        num_x = o.num_x;
        num_y = o.num_y;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const fp_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.table_type;
        s << ", " << x.id;
        s << ", " << x.dp;
        s << ", " << x.num_x;
        s << ", " << x.num_y;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].val
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, fp_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.table_type;
        s >> ',' >> x.id;
        s >> ',' >> x.dp;
        s >> ',' >> x.num_x;
        s >> ',' >> x.num_y;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].val)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct fp_trace2ampl
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef fp_trace2ampl<rebind_it> type;
    };

    typedef it iterator_type;

    fp_trace2ampl(it begin, it end, bool dirty=false)
        : num_traces(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 130, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8200};
    it begin() const { return num_traces.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_traces;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> num_traces;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : val(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float val;
        #else
        binary::field<float, sc_float32, 0, it> val;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[256];
    #else
    sequence<fp_trace2ampl, 32, 8, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    fp_trace2ampl& operator=(const fp_trace2ampl<ito>& o) {
        num_traces = o.num_traces;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct fp_trace2ampl<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef fp_trace2ampl<rebind_it> type;
    };

    enum { id_main = 130, id_sub = 0};

    uint8_t          num_traces;
    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition {
        float            val;
    } data[256];

    fp_trace2ampl()
        : num_traces()
    {}

    template<class it>
    fp_trace2ampl(const fp_trace2ampl<it>& o) {
        num_traces = o.num_traces;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const fp_trace2ampl<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.num_traces;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].val
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, fp_trace2ampl<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.num_traces;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].val)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct fp_wghts
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef fp_wghts<rebind_it> type;
    };

    typedef it iterator_type;

    fp_wghts(it begin, it end, bool dirty=false)
        : sample_rate(begin)
        , id(begin)
        , num_traces(begin)
        , max_wght(begin)
        , hw_start(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 129, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 16448};
    it begin() const { return sample_rate.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float sample_rate;
    #else
    binary::field<float, sc_float32, 0, it> sample_rate;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t id;
    #else
    binary::field<uint8_t, sc_uint4, 32, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_traces;
    #else
    binary::field<uint8_t, sc_uint8, 36, it> num_traces;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t max_wght;
    #else
    binary::field<uint16_t, sc_uint12, 44, it> max_wght;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hw_start;
    #else
    binary::field<uint8_t, sc_uint8, 56, it> hw_start;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : s_idx_0(begin, begin_bit)
            , s_idx_1(begin, begin_bit)
            , s_idx_2(begin, begin_bit)
            , s_idx_3(begin, begin_bit)
            , top(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t s_idx_0;
        #else
        binary::field<uint16_t, sc_uint12, 0, it> s_idx_0;
        #endif
        #ifdef DOXYGEN
        uint16_t s_idx_1;
        #else
        binary::field<uint16_t, sc_uint12, 12, it> s_idx_1;
        #endif
        #ifdef DOXYGEN
        uint16_t s_idx_2;
        #else
        binary::field<uint16_t, sc_uint12, 24, it> s_idx_2;
        #endif
        #ifdef DOXYGEN
        uint16_t s_idx_3;
        #else
        binary::field<uint16_t, sc_uint12, 36, it> s_idx_3;
        #endif
        #ifdef DOXYGEN
        uint16_t top;
        #else
        binary::field<uint16_t, sc_uint16, 48, it> top;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[256];
    #else
    sequence<fp_wghts, 64, 64, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    fp_wghts& operator=(const fp_wghts<ito>& o) {
        sample_rate = o.sample_rate;
        id = o.id;
        num_traces = o.num_traces;
        max_wght = o.max_wght;
        hw_start = o.hw_start;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].s_idx_0 = o.data[n].s_idx_0;
            data[n].s_idx_1 = o.data[n].s_idx_1;
            data[n].s_idx_2 = o.data[n].s_idx_2;
            data[n].s_idx_3 = o.data[n].s_idx_3;
            data[n].top = o.data[n].top;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct fp_wghts<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef fp_wghts<rebind_it> type;
    };

    enum { id_main = 129, id_sub = 0};

    float            sample_rate;
    uint8_t          id;
    uint8_t          num_traces;
    uint16_t         max_wght;
    uint8_t          hw_start;
    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition {
        uint16_t         s_idx_0;
        uint16_t         s_idx_1;
        uint16_t         s_idx_2;
        uint16_t         s_idx_3;
        uint16_t         top;
    } data[256];

    fp_wghts()
        : sample_rate()
        , id()
        , num_traces()
        , max_wght()
        , hw_start()
    {}

    template<class it>
    fp_wghts(const fp_wghts<it>& o) {
        sample_rate = o.sample_rate;
        id = o.id;
        num_traces = o.num_traces;
        max_wght = o.max_wght;
        hw_start = o.hw_start;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].s_idx_0 = o.data[n].s_idx_0;
            data[n].s_idx_1 = o.data[n].s_idx_1;
            data[n].s_idx_2 = o.data[n].s_idx_2;
            data[n].s_idx_3 = o.data[n].s_idx_3;
            data[n].top = o.data[n].top;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const fp_wghts<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.sample_rate;
        s << ", " << x.id;
        s << ", " << x.num_traces;
        s << ", " << x.max_wght;
        s << ", " << x.hw_start;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].s_idx_0
            << ", " << x.data[n].s_idx_1
            << ", " << x.data[n].s_idx_2
            << ", " << x.data[n].s_idx_3
            << ", " << x.data[n].top
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, fp_wghts<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.sample_rate;
        s >> ',' >> x.id;
        s >> ',' >> x.num_traces;
        s >> ',' >> x.max_wght;
        s >> ',' >> x.hw_start;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].s_idx_0)
            >> ',' >> (x.data[x.data_size-1].s_idx_1)
            >> ',' >> (x.data[x.data_size-1].s_idx_2)
            >> ',' >> (x.data[x.data_size-1].s_idx_3)
            >> ',' >> (x.data[x.data_size-1].top)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct frame_start
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef frame_start<rebind_it> type;
    };

    typedef it iterator_type;

    frame_start(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 14, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    frame_start& operator=(const frame_start<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct frame_start<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef frame_start<rebind_it> type;
    };

    enum { id_main = 14, id_sub = 0};


    frame_start()
    {}

    template<class it>
    frame_start(const frame_start<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const frame_start<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, frame_start<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! start of a scan frame in down direction.

//! Sent, when a scan with changing frame angle enters
//! the specified frame range in negative (decreasing angle) direction
//! before data packets belonging to this frame
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct frame_start_dn
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef frame_start_dn<rebind_it> type;
    };

    typedef it iterator_type;

    frame_start_dn(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 23, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    frame_start_dn& operator=(const frame_start_dn<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct frame_start_dn<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef frame_start_dn<rebind_it> type;
    };

    enum { id_main = 23, id_sub = 0};


    frame_start_dn()
    {}

    template<class it>
    frame_start_dn(const frame_start_dn<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const frame_start_dn<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, frame_start_dn<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! Start of a scan frame in up direction.

//! Sent, when a scan with changing frame angle enters
//! the specified frame range in positive (increasing angle) direction
//! before data packets belonging to this frame
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct frame_start_up
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef frame_start_up<rebind_it> type;
    };

    typedef it iterator_type;

    frame_start_up(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 22, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    frame_start_up& operator=(const frame_start_up<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct frame_start_up<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef frame_start_up<rebind_it> type;
    };

    enum { id_main = 22, id_sub = 0};


    frame_start_up()
    {}

    template<class it>
    frame_start_up(const frame_start_up<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const frame_start_up<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, frame_start_up<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! end of a scan frame

//! after data packets belonging to this frame
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct frame_stop
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef frame_stop<rebind_it> type;
    };

    typedef it iterator_type;

    frame_stop(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 15, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    frame_stop& operator=(const frame_stop<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct frame_stop<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef frame_stop<rebind_it> type;
    };

    enum { id_main = 15, id_sub = 0};


    frame_stop()
    {}

    template<class it>
    frame_stop(const frame_stop<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const frame_stop<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, frame_stop<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct generic_end
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef generic_end<rebind_it> type;
    };

    typedef it iterator_type;

    generic_end(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 21, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    generic_end& operator=(const generic_end<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct generic_end<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef generic_end<rebind_it> type;
    };

    enum { id_main = 21, id_sub = 0};


    generic_end()
    {}

    template<class it>
    generic_end(const generic_end<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const generic_end<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, generic_end<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! gravity information  in SOCS

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct gravity_socs
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef gravity_socs<rebind_it> type;
    };

    typedef it iterator_type;

    gravity_socs(it begin, it end, bool dirty=false)
        : systime(begin)
        , temperature(begin)
        , gravity(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 145, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 144};
    it begin() const { return systime.begin(); }
    it end() const { return gravity.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  systime when the sample was taken in units of uints.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t temperature;
    #else
    binary::field<int16_t, sc_int16, 32, it> temperature;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gravity[3];
    #else
    binary::array<float, 3, sc_float32, 48, it> gravity;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    gravity_socs& operator=(const gravity_socs<ito>& o) {
        systime = o.systime;
        temperature = o.temperature;
        for(unsigned n=0; n<3; ++n) gravity[n] = o.gravity[n];
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct gravity_socs<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef gravity_socs<rebind_it> type;
    };

    enum { id_main = 145, id_sub = 0};

    uint32_t         systime;
    int16_t          temperature;
    float            gravity[3];

    gravity_socs()
        : systime()
        , temperature()
        , gravity()
    {}

    template<class it>
    gravity_socs(const gravity_socs<it>& o) {
        systime = o.systime;
        temperature = o.temperature;
        for(unsigned n=0; n<3; ++n) gravity[n] = o.gravity[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const gravity_socs<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.temperature;
        s << ", "; write_array(s, 3, x.gravity);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, gravity_socs<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.temperature;
        s >> ','; read_array(s, 3, x.gravity);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! The mandatory header package.

//! Basic information to identify the scanning device and short id definition.
//! Handling of the short IDs is mostly automatic, i.e. you do not normally
//! need to care about the short ID mechanism.
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct header
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef header<rebind_it> type;
    };

    typedef it iterator_type;

    header(it begin, it end, bool dirty=false)
        : type_id(begin)
        , build(begin)
        , serial(begin)
        , id_lookup(begin, end, id_lookup_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 1, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8512};
    it begin() const { return type_id.begin(); }
    it end() const { return id_lookup.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char type_id[16];//!< instrument type 
    #else
    binary::array<char, 16, sc_char, 0, it> type_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char build[16];//!< build variant 
    #else
    binary::array<char, 16, sc_char, 128, it> build;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char serial[16];//!< serial number 
    #else
    binary::array<char, 16, sc_char, 256, it> serial;
    #endif //DOXYGEN

    std::size_t id_lookup_size;
    enum { id_lookup_max_size = 254 };
    //! id lookup table for short-id's

    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sub(begin, begin_bit)
            , main(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t sub;//!< sub id 
        #else
        binary::field<uint16_t, sc_uint16, 0, it> sub;
        #endif
        #ifdef DOXYGEN
        uint16_t main;//!< main id 
        #else
        binary::field<uint16_t, sc_uint16, 16, it> main;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition id_lookup[254];
    #else
    sequence<header, 32, 384, it> id_lookup;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    header& operator=(const header<ito>& o) {
        for(unsigned n=0; n<16; ++n) type_id[n] = o.type_id[n];
        for(unsigned n=0; n<16; ++n) build[n] = o.build[n];
        for(unsigned n=0; n<16; ++n) serial[n] = o.serial[n];
        id_lookup_size = o.id_lookup_size;
        id_lookup.clean();
        for(unsigned n=0; n<id_lookup_size; ++n){
            id_lookup[n].sub = o.id_lookup[n].sub;
            id_lookup[n].main = o.id_lookup[n].main;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct header<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef header<rebind_it> type;
    };

    enum { id_main = 1, id_sub = 0};

    char             type_id[16];
    char             build[16];
    char             serial[16];
    std::size_t id_lookup_size;
    enum { id_lookup_max_size = 254 };
    struct sequence_definition {
        uint16_t         sub;
        uint16_t         main;
    } id_lookup[254];

    header()
        : type_id()
        , build()
        , serial()
    {}

    template<class it>
    header(const header<it>& o) {
        for(unsigned n=0; n<16; ++n) type_id[n] = o.type_id[n];
        for(unsigned n=0; n<16; ++n) build[n] = o.build[n];
        for(unsigned n=0; n<16; ++n) serial[n] = o.serial[n];
        id_lookup_size = o.id_lookup.size();
        for(unsigned n=0; n<id_lookup_size; ++n){
            id_lookup[n].sub = o.id_lookup[n].sub;
            id_lookup[n].main = o.id_lookup[n].main;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const header<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 16, x.type_id);
        s << ", "; write_array(s, 16, x.build);
        s << ", "; write_array(s, 16, x.serial);

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.id_lookup_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.id_lookup[n].sub
            << ", " << x.id_lookup[n].main
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, header<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 16, x.type_id);
        s >> ','; read_array(s, 16, x.build);
        s >> ','; read_array(s, 16, x.serial);

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.id_lookup_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.id_lookup_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.id_lookup[x.id_lookup_size-1].sub)
            >> ',' >> (x.id_lookup[x.id_lookup_size-1].main)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct header_device
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef header_device<rebind_it> type;
    };

    typedef it iterator_type;

    header_device(it begin, it end, bool dirty=false)
        : sub_id(begin)
        , main_id(begin)
        , label(begin)
        , help(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 111, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 672};
    it begin() const { return sub_id.begin(); }
    it end() const { return help.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sub_id;//!<  sub device id 
    #else
    binary::field<uint16_t, sc_uint16, 0, it> sub_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t main_id;//!<  main device id 
    #else
    binary::field<uint16_t, sc_uint16, 16, it> main_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char label[16];//!<  identifier, regexp: [_A-Za-z][_A-Za-z0-9]* 
    #else
    binary::array<char, 16, sc_char, 32, it> label;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char help[64];//!<  English help string for user display 
    #else
    binary::array<char, 64, sc_char, 160, it> help;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    header_device& operator=(const header_device<ito>& o) {
        sub_id = o.sub_id;
        main_id = o.main_id;
        for(unsigned n=0; n<16; ++n) label[n] = o.label[n];
        for(unsigned n=0; n<64; ++n) help[n] = o.help[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct header_device<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef header_device<rebind_it> type;
    };

    enum { id_main = 111, id_sub = 0};

    uint16_t         sub_id;
    uint16_t         main_id;
    char             label[16];
    char             help[64];

    header_device()
        : sub_id()
        , main_id()
        , label()
        , help()
    {}

    template<class it>
    header_device(const header_device<it>& o) {
        sub_id = o.sub_id;
        main_id = o.main_id;
        for(unsigned n=0; n<16; ++n) label[n] = o.label[n];
        for(unsigned n=0; n<64; ++n) help[n] = o.help[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const header_device<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.sub_id;
        s << ", " << x.main_id;
        s << ", "; write_array(s, 16, x.label);
        s << ", "; write_array(s, 64, x.help);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, header_device<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.sub_id;
        s >> ',' >> x.main_id;
        s >> ','; read_array(s, 16, x.label);
        s >> ','; read_array(s, 64, x.help);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! Extension header

//! The extension header lists all major and minor numbers of packages
//! which might be actual present in the current data stream
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct header_ext
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef header_ext<rebind_it> type;
    };

    typedef it iterator_type;

    header_ext(it begin, it end, bool dirty=false)
        : id(begin, end, id_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 43, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8128};
    it begin() const { return id.begin(); }
    it end() const { return id.end(); }

    #endif //DOXYGEN

    std::size_t id_size;
    enum { id_max_size = 254 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sub(begin, begin_bit)
            , main(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t sub;//!<  sub id 
        #else
        binary::field<uint16_t, sc_uint16, 0, it> sub;
        #endif
        #ifdef DOXYGEN
        uint16_t main;//!<  main id 
        #else
        binary::field<uint16_t, sc_uint16, 16, it> main;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition id[254];
    #else
    sequence<header_ext, 32, 0, it> id;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    header_ext& operator=(const header_ext<ito>& o) {
        id_size = o.id_size;
        id.clean();
        for(unsigned n=0; n<id_size; ++n){
            id[n].sub = o.id[n].sub;
            id[n].main = o.id[n].main;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct header_ext<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef header_ext<rebind_it> type;
    };

    enum { id_main = 43, id_sub = 0};

    std::size_t id_size;
    enum { id_max_size = 254 };
    struct sequence_definition {
        uint16_t         sub;
        uint16_t         main;
    } id[254];

    header_ext()
    {}

    template<class it>
    header_ext(const header_ext<it>& o) {
        id_size = o.id.size();
        for(unsigned n=0; n<id_size; ++n){
            id[n].sub = o.id[n].sub;
            id[n].main = o.id[n].main;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const header_ext<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.id_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.id[n].sub
            << ", " << x.id[n].main
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, header_ext<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.id_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.id_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.id[x.id_size-1].sub)
            >> ',' >> (x.id[x.id_size-1].main)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! power supply unit (24 Bytes)

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status, deprecated</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_bat
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_bat<rebind_it> type;
    };

    typedef it iterator_type;

    hk_bat(it begin, it end, bool dirty=false)
        : V_IN_1(begin)
        , V_IN_2(begin)
        , V_IN_3(begin)
        , V_IN_SEL(begin)
        , A_IN_SEL(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
        , RESERVED_25(begin)
        , RESERVED_26(begin)
        , RESERVED_27(begin)
        , RESERVED_28(begin)
        , RESERVED_29(begin)
        , RESERVED_30(begin)
        , level(begin)
        , RESERVED_32(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10003, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 384};
    it begin() const { return V_IN_1.begin(); }
    it end() const { return RESERVED_32.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_1;//!<  power supply unit, input voltage port 1       [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 0, it> V_IN_1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_2;//!<  power supply unit, input voltage port 2       [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 16, it> V_IN_2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_3;//!<  power supply unit, input voltage battery port [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 32, it> V_IN_3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t V_IN_SEL;//!<  power supply unit, selected input voltage     [10 mV] 
    #else
    binary::field<uint16_t, sc_uint16, 48, it> V_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t A_IN_SEL;//!<  power supply unit, input current              [ 1 mA] 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> A_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_05;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_06;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_10;
    #else
    binary::field<uint8_t, sc_uint8, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_11[3];
    #else
    binary::array<uint8_t, 3, sc_uint8, 168, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_20;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_21;
    #else
    binary::field<uint16_t, sc_uint16, 208, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 224, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 240, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_24;
    #else
    binary::field<uint16_t, sc_uint16, 256, it> RESERVED_24;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_25;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_25;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_26;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_26;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_27;
    #else
    binary::field<uint16_t, sc_uint16, 304, it> RESERVED_27;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_28;
    #else
    binary::field<int16_t, sc_int16, 320, it> RESERVED_28;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_29;
    #else
    binary::field<int16_t, sc_int16, 336, it> RESERVED_29;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_30;
    #else
    binary::field<int16_t, sc_int16, 352, it> RESERVED_30;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t level;//!<  battery unit, charge level              [  1 %] 
    #else
    binary::field<uint8_t, sc_uint8, 368, it> level;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_32;
    #else
    binary::field<uint8_t, sc_uint8, 376, it> RESERVED_32;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_bat& operator=(const hk_bat<ito>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        level = o.level;
        RESERVED_32 = o.RESERVED_32;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_bat<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_bat<rebind_it> type;
    };

    enum { id_main = 10003, id_sub = 1};

    int16_t          V_IN_1;
    int16_t          V_IN_2;
    int16_t          V_IN_3;
    uint16_t         V_IN_SEL;
    uint16_t         A_IN_SEL;
    uint16_t         RESERVED_05;
    uint16_t         RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    uint8_t          RESERVED_10;
    uint8_t          RESERVED_11[3];
    uint16_t         RESERVED_20;
    uint16_t         RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint16_t         RESERVED_24;
    uint16_t         RESERVED_25;
    uint16_t         RESERVED_26;
    uint16_t         RESERVED_27;
    int16_t          RESERVED_28;
    int16_t          RESERVED_29;
    int16_t          RESERVED_30;
    uint8_t          level;
    uint8_t          RESERVED_32;

    hk_bat()
        : V_IN_1()
        , V_IN_2()
        , V_IN_3()
        , V_IN_SEL()
        , A_IN_SEL()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
        , RESERVED_25()
        , RESERVED_26()
        , RESERVED_27()
        , RESERVED_28()
        , RESERVED_29()
        , RESERVED_30()
        , level()
        , RESERVED_32()
    {}

    template<class it>
    hk_bat(const hk_bat<it>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        level = o.level;
        RESERVED_32 = o.RESERVED_32;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_bat<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.V_IN_1;
        s << ", " << x.V_IN_2;
        s << ", " << x.V_IN_3;
        s << ", " << x.V_IN_SEL;
        s << ", " << x.A_IN_SEL;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", "; write_array(s, 3, x.RESERVED_11);
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
        s << ", " << x.RESERVED_25;
        s << ", " << x.RESERVED_26;
        s << ", " << x.RESERVED_27;
        s << ", " << x.RESERVED_28;
        s << ", " << x.RESERVED_29;
        s << ", " << x.RESERVED_30;
        s << ", " << x.level;
        s << ", " << x.RESERVED_32;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_bat<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.V_IN_1;
        s >> ',' >> x.V_IN_2;
        s >> ',' >> x.V_IN_3;
        s >> ',' >> x.V_IN_SEL;
        s >> ',' >> x.A_IN_SEL;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ','; read_array(s, 3, x.RESERVED_11);
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
        s >> ',' >> x.RESERVED_25;
        s >> ',' >> x.RESERVED_26;
        s >> ',' >> x.RESERVED_27;
        s >> ',' >> x.RESERVED_28;
        s >> ',' >> x.RESERVED_29;
        s >> ',' >> x.RESERVED_30;
        s >> ',' >> x.level;
        s >> ',' >> x.RESERVED_32;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! power supply unit (24 Bytes)

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_bat_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_bat_1<rebind_it> type;
    };

    typedef it iterator_type;

    hk_bat_1(it begin, it end, bool dirty=false)
        : V_IN_1(begin)
        , V_IN_2(begin)
        , V_IN_3(begin)
        , V_IN_SEL(begin)
        , A_IN_SEL(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
        , RESERVED_25(begin)
        , RESERVED_26(begin)
        , RESERVED_27(begin)
        , RESERVED_28(begin)
        , RESERVED_29(begin)
        , RESERVED_30(begin)
        , level(begin)
        , RESERVED_32(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10007, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 392};
    it begin() const { return V_IN_1.begin(); }
    it end() const { return RESERVED_32.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_1;//!<  power supply unit, input voltage port 1       [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 0, it> V_IN_1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_2;//!<  power supply unit, input voltage port 2       [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 16, it> V_IN_2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_3;//!<  power supply unit, input voltage battery port [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 32, it> V_IN_3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t V_IN_SEL;//!<  power supply unit, selected input voltage     [10 mV] 
    #else
    binary::field<uint16_t, sc_uint16, 48, it> V_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t A_IN_SEL;//!<  power supply unit, input current              [ 1 mA] 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> A_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_05;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_06;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_10;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_11[3];//!<  battery unit (optionally attached) (22 Bytes) 
    #else
    binary::array<uint8_t, 3, sc_uint8, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_20;
    #else
    binary::field<uint16_t, sc_uint16, 200, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_21;
    #else
    binary::field<uint16_t, sc_uint16, 216, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 232, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 248, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_24;
    #else
    binary::field<uint16_t, sc_uint16, 264, it> RESERVED_24;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_25;
    #else
    binary::field<uint16_t, sc_uint16, 280, it> RESERVED_25;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_26;
    #else
    binary::field<uint16_t, sc_uint16, 296, it> RESERVED_26;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_27;
    #else
    binary::field<uint16_t, sc_uint16, 312, it> RESERVED_27;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_28;
    #else
    binary::field<int16_t, sc_int16, 328, it> RESERVED_28;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_29;
    #else
    binary::field<int16_t, sc_int16, 344, it> RESERVED_29;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_30;
    #else
    binary::field<int16_t, sc_int16, 360, it> RESERVED_30;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t level;//!<  battery unit, charge level               [  1 %] 
    #else
    binary::field<uint8_t, sc_uint8, 376, it> level;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_32;
    #else
    binary::field<uint8_t, sc_uint8, 384, it> RESERVED_32;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_bat_1& operator=(const hk_bat_1<ito>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        level = o.level;
        RESERVED_32 = o.RESERVED_32;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_bat_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_bat_1<rebind_it> type;
    };

    enum { id_main = 10007, id_sub = 1};

    int16_t          V_IN_1;
    int16_t          V_IN_2;
    int16_t          V_IN_3;
    uint16_t         V_IN_SEL;
    uint16_t         A_IN_SEL;
    uint16_t         RESERVED_05;
    uint16_t         RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    uint16_t         RESERVED_10;
    uint8_t          RESERVED_11[3];
    uint16_t         RESERVED_20;
    uint16_t         RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint16_t         RESERVED_24;
    uint16_t         RESERVED_25;
    uint16_t         RESERVED_26;
    uint16_t         RESERVED_27;
    int16_t          RESERVED_28;
    int16_t          RESERVED_29;
    int16_t          RESERVED_30;
    uint8_t          level;
    uint8_t          RESERVED_32;

    hk_bat_1()
        : V_IN_1()
        , V_IN_2()
        , V_IN_3()
        , V_IN_SEL()
        , A_IN_SEL()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
        , RESERVED_25()
        , RESERVED_26()
        , RESERVED_27()
        , RESERVED_28()
        , RESERVED_29()
        , RESERVED_30()
        , level()
        , RESERVED_32()
    {}

    template<class it>
    hk_bat_1(const hk_bat_1<it>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        level = o.level;
        RESERVED_32 = o.RESERVED_32;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_bat_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.V_IN_1;
        s << ", " << x.V_IN_2;
        s << ", " << x.V_IN_3;
        s << ", " << x.V_IN_SEL;
        s << ", " << x.A_IN_SEL;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", "; write_array(s, 3, x.RESERVED_11);
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
        s << ", " << x.RESERVED_25;
        s << ", " << x.RESERVED_26;
        s << ", " << x.RESERVED_27;
        s << ", " << x.RESERVED_28;
        s << ", " << x.RESERVED_29;
        s << ", " << x.RESERVED_30;
        s << ", " << x.level;
        s << ", " << x.RESERVED_32;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_bat_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.V_IN_1;
        s >> ',' >> x.V_IN_2;
        s >> ',' >> x.V_IN_3;
        s >> ',' >> x.V_IN_SEL;
        s >> ',' >> x.A_IN_SEL;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ','; read_array(s, 3, x.RESERVED_11);
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
        s >> ',' >> x.RESERVED_25;
        s >> ',' >> x.RESERVED_26;
        s >> ',' >> x.RESERVED_27;
        s >> ',' >> x.RESERVED_28;
        s >> ',' >> x.RESERVED_29;
        s >> ',' >> x.RESERVED_30;
        s >> ',' >> x.level;
        s >> ',' >> x.RESERVED_32;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! power supply unit (24 Bytes)

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_bat_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_bat_2<rebind_it> type;
    };

    typedef it iterator_type;

    hk_bat_2(it begin, it end, bool dirty=false)
        : V_IN_1(begin)
        , V_IN_2(begin)
        , V_IN_3(begin)
        , V_IN_SEL(begin)
        , A_IN_SEL(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
        , RESERVED_25(begin)
        , RESERVED_26(begin)
        , RESERVED_27(begin)
        , RESERVED_28(begin)
        , RESERVED_29(begin)
        , RESERVED_30(begin)
        , level(begin)
        , RESERVED_32(begin)
        , RESERVED_33(begin)
        , RESERVED_34(begin)
        , RESERVED_35(begin)
        , RESERVED_36(begin)
        , RESERVED_37(begin)
        , RESERVED_38(begin)
        , RESERVED_39(begin)
        , RESERVED_40(begin)
        , RESERVED_41(begin)
        , RESERVED_42(begin)
        , RESERVED_43(begin)
        , RESERVED_44(begin)
        , RESERVED_45(begin)
        , RESERVED_46(begin)
        , RESERVED_47(begin)
        , RESERVED_48(begin)
        , RESERVED_49(begin)
        , RESERVED_50(begin)
        , RESERVED_51(begin)
        , RESERVED_52(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10007, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 728};
    it begin() const { return V_IN_1.begin(); }
    it end() const { return RESERVED_52.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_1;//!<  power supply unit, input voltage port 1       [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 0, it> V_IN_1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_2;//!<  power supply unit, input voltage port 2       [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 16, it> V_IN_2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_3;//!<  power supply unit, input voltage battery port [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 32, it> V_IN_3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t V_IN_SEL;//!<  power supply unit, selected input voltage     [10 mV] 
    #else
    binary::field<uint16_t, sc_uint16, 48, it> V_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t A_IN_SEL;//!<  power supply unit, input current              [ 1 mA] 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> A_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_05;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_06;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_10;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_11[3];//!<  battery unit (optionally attached) (22 Bytes) 
    #else
    binary::array<uint8_t, 3, sc_uint8, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_20;
    #else
    binary::field<uint16_t, sc_uint16, 200, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_21;
    #else
    binary::field<uint16_t, sc_uint16, 216, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 232, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 248, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_24;
    #else
    binary::field<uint16_t, sc_uint16, 264, it> RESERVED_24;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_25;
    #else
    binary::field<uint16_t, sc_uint16, 280, it> RESERVED_25;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_26;
    #else
    binary::field<uint16_t, sc_uint16, 296, it> RESERVED_26;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_27;
    #else
    binary::field<uint16_t, sc_uint16, 312, it> RESERVED_27;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_28;
    #else
    binary::field<int16_t, sc_int16, 328, it> RESERVED_28;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_29;
    #else
    binary::field<int16_t, sc_int16, 344, it> RESERVED_29;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_30;
    #else
    binary::field<int16_t, sc_int16, 360, it> RESERVED_30;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t level;//!<  battery unit, charge level               [  1 %] 
    #else
    binary::field<uint8_t, sc_uint8, 376, it> level;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_32;
    #else
    binary::field<uint8_t, sc_uint8, 384, it> RESERVED_32;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_33;
    #else
    binary::field<uint8_t, sc_uint8, 392, it> RESERVED_33;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_34;
    #else
    binary::field<uint16_t, sc_uint16, 400, it> RESERVED_34;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_35;
    #else
    binary::field<uint32_t, sc_uint32, 416, it> RESERVED_35;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_36;
    #else
    binary::field<uint8_t, sc_uint8, 448, it> RESERVED_36;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_37;
    #else
    binary::field<uint8_t, sc_uint8, 456, it> RESERVED_37;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_38;
    #else
    binary::field<uint16_t, sc_uint16, 464, it> RESERVED_38;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_39;
    #else
    binary::field<uint16_t, sc_uint16, 480, it> RESERVED_39;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_40;
    #else
    binary::field<uint16_t, sc_uint16, 496, it> RESERVED_40;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_41;
    #else
    binary::field<uint16_t, sc_uint16, 512, it> RESERVED_41;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_42;
    #else
    binary::field<uint16_t, sc_uint16, 528, it> RESERVED_42;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_43;
    #else
    binary::field<uint16_t, sc_uint16, 544, it> RESERVED_43;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_44;
    #else
    binary::field<uint16_t, sc_uint16, 560, it> RESERVED_44;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_45;
    #else
    binary::field<uint16_t, sc_uint16, 576, it> RESERVED_45;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_46;
    #else
    binary::field<uint32_t, sc_uint32, 592, it> RESERVED_46;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_47;
    #else
    binary::field<uint32_t, sc_uint32, 624, it> RESERVED_47;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_48;
    #else
    binary::field<uint16_t, sc_uint16, 656, it> RESERVED_48;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_49;
    #else
    binary::field<uint16_t, sc_uint16, 672, it> RESERVED_49;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_50;
    #else
    binary::field<uint8_t, sc_uint8, 688, it> RESERVED_50;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_51;
    #else
    binary::field<uint16_t, sc_uint16, 696, it> RESERVED_51;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_52;
    #else
    binary::field<uint16_t, sc_uint16, 712, it> RESERVED_52;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_bat_2& operator=(const hk_bat_2<ito>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        level = o.level;
        RESERVED_32 = o.RESERVED_32;
        RESERVED_33 = o.RESERVED_33;
        RESERVED_34 = o.RESERVED_34;
        RESERVED_35 = o.RESERVED_35;
        RESERVED_36 = o.RESERVED_36;
        RESERVED_37 = o.RESERVED_37;
        RESERVED_38 = o.RESERVED_38;
        RESERVED_39 = o.RESERVED_39;
        RESERVED_40 = o.RESERVED_40;
        RESERVED_41 = o.RESERVED_41;
        RESERVED_42 = o.RESERVED_42;
        RESERVED_43 = o.RESERVED_43;
        RESERVED_44 = o.RESERVED_44;
        RESERVED_45 = o.RESERVED_45;
        RESERVED_46 = o.RESERVED_46;
        RESERVED_47 = o.RESERVED_47;
        RESERVED_48 = o.RESERVED_48;
        RESERVED_49 = o.RESERVED_49;
        RESERVED_50 = o.RESERVED_50;
        RESERVED_51 = o.RESERVED_51;
        RESERVED_52 = o.RESERVED_52;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_bat_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_bat_2<rebind_it> type;
    };

    enum { id_main = 10007, id_sub = 2};

    int16_t          V_IN_1;
    int16_t          V_IN_2;
    int16_t          V_IN_3;
    uint16_t         V_IN_SEL;
    uint16_t         A_IN_SEL;
    uint16_t         RESERVED_05;
    uint16_t         RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    uint16_t         RESERVED_10;
    uint8_t          RESERVED_11[3];
    uint16_t         RESERVED_20;
    uint16_t         RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint16_t         RESERVED_24;
    uint16_t         RESERVED_25;
    uint16_t         RESERVED_26;
    uint16_t         RESERVED_27;
    int16_t          RESERVED_28;
    int16_t          RESERVED_29;
    int16_t          RESERVED_30;
    uint8_t          level;
    uint8_t          RESERVED_32;
    uint8_t          RESERVED_33;
    uint16_t         RESERVED_34;
    uint32_t         RESERVED_35;
    uint8_t          RESERVED_36;
    uint8_t          RESERVED_37;
    uint16_t         RESERVED_38;
    uint16_t         RESERVED_39;
    uint16_t         RESERVED_40;
    uint16_t         RESERVED_41;
    uint16_t         RESERVED_42;
    uint16_t         RESERVED_43;
    uint16_t         RESERVED_44;
    uint16_t         RESERVED_45;
    uint32_t         RESERVED_46;
    uint32_t         RESERVED_47;
    uint16_t         RESERVED_48;
    uint16_t         RESERVED_49;
    uint8_t          RESERVED_50;
    uint16_t         RESERVED_51;
    uint16_t         RESERVED_52;

    hk_bat_2()
        : V_IN_1()
        , V_IN_2()
        , V_IN_3()
        , V_IN_SEL()
        , A_IN_SEL()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
        , RESERVED_25()
        , RESERVED_26()
        , RESERVED_27()
        , RESERVED_28()
        , RESERVED_29()
        , RESERVED_30()
        , level()
        , RESERVED_32()
        , RESERVED_33()
        , RESERVED_34()
        , RESERVED_35()
        , RESERVED_36()
        , RESERVED_37()
        , RESERVED_38()
        , RESERVED_39()
        , RESERVED_40()
        , RESERVED_41()
        , RESERVED_42()
        , RESERVED_43()
        , RESERVED_44()
        , RESERVED_45()
        , RESERVED_46()
        , RESERVED_47()
        , RESERVED_48()
        , RESERVED_49()
        , RESERVED_50()
        , RESERVED_51()
        , RESERVED_52()
    {}

    template<class it>
    hk_bat_2(const hk_bat_2<it>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        level = o.level;
        RESERVED_32 = o.RESERVED_32;
        RESERVED_33 = o.RESERVED_33;
        RESERVED_34 = o.RESERVED_34;
        RESERVED_35 = o.RESERVED_35;
        RESERVED_36 = o.RESERVED_36;
        RESERVED_37 = o.RESERVED_37;
        RESERVED_38 = o.RESERVED_38;
        RESERVED_39 = o.RESERVED_39;
        RESERVED_40 = o.RESERVED_40;
        RESERVED_41 = o.RESERVED_41;
        RESERVED_42 = o.RESERVED_42;
        RESERVED_43 = o.RESERVED_43;
        RESERVED_44 = o.RESERVED_44;
        RESERVED_45 = o.RESERVED_45;
        RESERVED_46 = o.RESERVED_46;
        RESERVED_47 = o.RESERVED_47;
        RESERVED_48 = o.RESERVED_48;
        RESERVED_49 = o.RESERVED_49;
        RESERVED_50 = o.RESERVED_50;
        RESERVED_51 = o.RESERVED_51;
        RESERVED_52 = o.RESERVED_52;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_bat_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.V_IN_1;
        s << ", " << x.V_IN_2;
        s << ", " << x.V_IN_3;
        s << ", " << x.V_IN_SEL;
        s << ", " << x.A_IN_SEL;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", "; write_array(s, 3, x.RESERVED_11);
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
        s << ", " << x.RESERVED_25;
        s << ", " << x.RESERVED_26;
        s << ", " << x.RESERVED_27;
        s << ", " << x.RESERVED_28;
        s << ", " << x.RESERVED_29;
        s << ", " << x.RESERVED_30;
        s << ", " << x.level;
        s << ", " << x.RESERVED_32;
        s << ", " << x.RESERVED_33;
        s << ", " << x.RESERVED_34;
        s << ", " << x.RESERVED_35;
        s << ", " << x.RESERVED_36;
        s << ", " << x.RESERVED_37;
        s << ", " << x.RESERVED_38;
        s << ", " << x.RESERVED_39;
        s << ", " << x.RESERVED_40;
        s << ", " << x.RESERVED_41;
        s << ", " << x.RESERVED_42;
        s << ", " << x.RESERVED_43;
        s << ", " << x.RESERVED_44;
        s << ", " << x.RESERVED_45;
        s << ", " << x.RESERVED_46;
        s << ", " << x.RESERVED_47;
        s << ", " << x.RESERVED_48;
        s << ", " << x.RESERVED_49;
        s << ", " << x.RESERVED_50;
        s << ", " << x.RESERVED_51;
        s << ", " << x.RESERVED_52;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_bat_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.V_IN_1;
        s >> ',' >> x.V_IN_2;
        s >> ',' >> x.V_IN_3;
        s >> ',' >> x.V_IN_SEL;
        s >> ',' >> x.A_IN_SEL;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ','; read_array(s, 3, x.RESERVED_11);
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
        s >> ',' >> x.RESERVED_25;
        s >> ',' >> x.RESERVED_26;
        s >> ',' >> x.RESERVED_27;
        s >> ',' >> x.RESERVED_28;
        s >> ',' >> x.RESERVED_29;
        s >> ',' >> x.RESERVED_30;
        s >> ',' >> x.level;
        s >> ',' >> x.RESERVED_32;
        s >> ',' >> x.RESERVED_33;
        s >> ',' >> x.RESERVED_34;
        s >> ',' >> x.RESERVED_35;
        s >> ',' >> x.RESERVED_36;
        s >> ',' >> x.RESERVED_37;
        s >> ',' >> x.RESERVED_38;
        s >> ',' >> x.RESERVED_39;
        s >> ',' >> x.RESERVED_40;
        s >> ',' >> x.RESERVED_41;
        s >> ',' >> x.RESERVED_42;
        s >> ',' >> x.RESERVED_43;
        s >> ',' >> x.RESERVED_44;
        s >> ',' >> x.RESERVED_45;
        s >> ',' >> x.RESERVED_46;
        s >> ',' >> x.RESERVED_47;
        s >> ',' >> x.RESERVED_48;
        s >> ',' >> x.RESERVED_49;
        s >> ',' >> x.RESERVED_50;
        s >> ',' >> x.RESERVED_51;
        s >> ',' >> x.RESERVED_52;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_cam
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_cam<rebind_it> type;
    };

    typedef it iterator_type;

    hk_cam(it begin, it end, bool dirty=false)
        : RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10011, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1096};
    it begin() const { return RESERVED_01.begin(); }
    it end() const { return RESERVED_07.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_01;
    #else
    binary::field<int8_t, sc_int8, 0, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_02;
    #else
    binary::field<uint8_t, sc_uint8, 8, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_04;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_05;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_06;
    #else
    binary::field<int8_t, sc_int8, 64, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char RESERVED_07[128];
    #else
    binary::array<char, 128, sc_char, 72, it> RESERVED_07;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_cam& operator=(const hk_cam<ito>& o) {
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        for(unsigned n=0; n<128; ++n) RESERVED_07[n] = o.RESERVED_07[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_cam<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_cam<rebind_it> type;
    };

    enum { id_main = 10011, id_sub = 0};

    int8_t           RESERVED_01;
    uint8_t          RESERVED_02;
    uint16_t         RESERVED_03;
    uint16_t         RESERVED_04;
    uint16_t         RESERVED_05;
    int8_t           RESERVED_06;
    char             RESERVED_07[128];

    hk_cam()
        : RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
    {}

    template<class it>
    hk_cam(const hk_cam<it>& o) {
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        for(unsigned n=0; n<128; ++n) RESERVED_07[n] = o.RESERVED_07[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_cam<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", "; write_array(s, 128, x.RESERVED_07);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_cam<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ','; read_array(s, 128, x.RESERVED_07);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! control unit, i.e., mother board, including storage levels, info on attached equipment (60 Bytes)

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_ctr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ctr<rebind_it> type;
    };

    typedef it iterator_type;

    hk_ctr(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , LINK_STAT(begin)
        , WLAN_QUAL(begin)
        , SCN_PROG(begin)
        , USED_FLASH(begin)
        , TOTAL_FLASH(begin)
        , USED_USBM(begin)
        , TOTAL_USBM(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10004, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 352};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return TOTAL_USBM.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_00;
    #else
    binary::field<int16_t, sc_int16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_02;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_04;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_05;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_06;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_09;
    #else
    binary::field<uint16_t, sc_uint16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_10;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_12;
    #else
    binary::field<uint8_t, sc_uint8, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t LINK_STAT;//!<  control unit, link 
    #else
    binary::field<uint8_t, sc_uint8, 200, it> LINK_STAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t WLAN_QUAL;//!<  control unit, wlan channel quality                 [  1 %] 
    #else
    binary::field<uint8_t, sc_uint8, 208, it> WLAN_QUAL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t SCN_PROG;//!<  control unit, scan progress                        [  1 %] 
    #else
    binary::field<uint8_t, sc_uint8, 216, it> SCN_PROG;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float USED_FLASH;//!<  control unit, memory usage of int. compact flash   [  1 %] 
    #else
    binary::field<float, sc_float32, 224, it> USED_FLASH;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOTAL_FLASH;//!<  control unit, capacity of int. compact flash       [  1MB] 
    #else
    binary::field<uint32_t, sc_uint32, 256, it> TOTAL_FLASH;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float USED_USBM;//!<  control unit, memory usage of external USB device  [  1 %] 
    #else
    binary::field<float, sc_float32, 288, it> USED_USBM;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOTAL_USBM;//!<  control unit, capacity of external USB device      [  1MB] 
    #else
    binary::field<uint32_t, sc_uint32, 320, it> TOTAL_USBM;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_ctr& operator=(const hk_ctr<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        LINK_STAT = o.LINK_STAT;
        WLAN_QUAL = o.WLAN_QUAL;
        SCN_PROG = o.SCN_PROG;
        USED_FLASH = o.USED_FLASH;
        TOTAL_FLASH = o.TOTAL_FLASH;
        USED_USBM = o.USED_USBM;
        TOTAL_USBM = o.TOTAL_USBM;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_ctr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ctr<rebind_it> type;
    };

    enum { id_main = 10004, id_sub = 0};

    int16_t          RESERVED_00;
    uint16_t         RESERVED_01;
    uint16_t         RESERVED_02;
    uint16_t         RESERVED_03;
    uint16_t         RESERVED_04;
    uint16_t         RESERVED_05;
    uint16_t         RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    uint16_t         RESERVED_09;
    uint16_t         RESERVED_10;
    uint16_t         RESERVED_11;
    uint8_t          RESERVED_12;
    uint8_t          LINK_STAT;
    uint8_t          WLAN_QUAL;
    uint8_t          SCN_PROG;
    float            USED_FLASH;
    uint32_t         TOTAL_FLASH;
    float            USED_USBM;
    uint32_t         TOTAL_USBM;

    hk_ctr()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , LINK_STAT()
        , WLAN_QUAL()
        , SCN_PROG()
        , USED_FLASH()
        , TOTAL_FLASH()
        , USED_USBM()
        , TOTAL_USBM()
    {}

    template<class it>
    hk_ctr(const hk_ctr<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        LINK_STAT = o.LINK_STAT;
        WLAN_QUAL = o.WLAN_QUAL;
        SCN_PROG = o.SCN_PROG;
        USED_FLASH = o.USED_FLASH;
        TOTAL_FLASH = o.TOTAL_FLASH;
        USED_USBM = o.USED_USBM;
        TOTAL_USBM = o.TOTAL_USBM;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_ctr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.LINK_STAT;
        s << ", " << x.WLAN_QUAL;
        s << ", " << x.SCN_PROG;
        s << ", " << x.USED_FLASH;
        s << ", " << x.TOTAL_FLASH;
        s << ", " << x.USED_USBM;
        s << ", " << x.TOTAL_USBM;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_ctr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.LINK_STAT;
        s >> ',' >> x.WLAN_QUAL;
        s >> ',' >> x.SCN_PROG;
        s >> ',' >> x.USED_FLASH;
        s >> ',' >> x.TOTAL_FLASH;
        s >> ',' >> x.USED_USBM;
        s >> ',' >> x.TOTAL_USBM;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! control unit, i.e., mother board, including storage levels, info on attached equipment (60 Bytes)

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_ctr_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ctr_1<rebind_it> type;
    };

    typedef it iterator_type;

    hk_ctr_1(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , LINK_STAT(begin)
        , WLAN_QUAL(begin)
        , SCN_PROG(begin)
        , USED_FLASH(begin)
        , TOTAL_FLASH(begin)
        , USED_USBM(begin)
        , TOTAL_USBM(begin)
        , MEAS_BUF_UTIL(begin)
        , MON_BUF_UTIL(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10004, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 416};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return MON_BUF_UTIL.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_00;
    #else
    binary::field<int16_t, sc_int16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_02;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_04;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_05;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_06;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_09;
    #else
    binary::field<uint16_t, sc_uint16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_10;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_12;
    #else
    binary::field<uint8_t, sc_uint8, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t LINK_STAT;//!<  control unit, link                B0: usb memory detect (mass storage device)                B1: usb camera detect                B2: lan0 link                B3: lan1 link 
    #else
    binary::field<uint8_t, sc_uint8, 200, it> LINK_STAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t WLAN_QUAL;//!<  control unit, wlan channel quality                 [  1 %] 
    #else
    binary::field<uint8_t, sc_uint8, 208, it> WLAN_QUAL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t SCN_PROG;//!<  control unit, scan progress                        [  1 %] 
    #else
    binary::field<uint8_t, sc_uint8, 216, it> SCN_PROG;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float USED_FLASH;//!<  control unit, memory usage of int. compact flash   [  1 %] 
    #else
    binary::field<float, sc_float32, 224, it> USED_FLASH;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOTAL_FLASH;//!<  control unit, capacity of int. compact flash       [  1MB] 
    #else
    binary::field<uint32_t, sc_uint32, 256, it> TOTAL_FLASH;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float USED_USBM;//!<  control unit, memory usage of external USB device  [  1 %] 
    #else
    binary::field<float, sc_float32, 288, it> USED_USBM;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOTAL_USBM;//!<  control unit, capacity of external USB device        [  1MB] 
    #else
    binary::field<uint32_t, sc_uint32, 320, it> TOTAL_USBM;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float MEAS_BUF_UTIL;//!<  control unit, measurement bufferutilization          [  1 %] 
    #else
    binary::field<float, sc_float32, 352, it> MEAS_BUF_UTIL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float MON_BUF_UTIL;//!<  control unit, monitor measurement buffer utilization [  1 %] 
    #else
    binary::field<float, sc_float32, 384, it> MON_BUF_UTIL;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_ctr_1& operator=(const hk_ctr_1<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        LINK_STAT = o.LINK_STAT;
        WLAN_QUAL = o.WLAN_QUAL;
        SCN_PROG = o.SCN_PROG;
        USED_FLASH = o.USED_FLASH;
        TOTAL_FLASH = o.TOTAL_FLASH;
        USED_USBM = o.USED_USBM;
        TOTAL_USBM = o.TOTAL_USBM;
        MEAS_BUF_UTIL = o.MEAS_BUF_UTIL;
        MON_BUF_UTIL = o.MON_BUF_UTIL;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_ctr_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ctr_1<rebind_it> type;
    };

    enum { id_main = 10004, id_sub = 1};

    int16_t          RESERVED_00;
    uint16_t         RESERVED_01;
    uint16_t         RESERVED_02;
    uint16_t         RESERVED_03;
    uint16_t         RESERVED_04;
    uint16_t         RESERVED_05;
    uint16_t         RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    uint16_t         RESERVED_09;
    uint16_t         RESERVED_10;
    uint16_t         RESERVED_11;
    uint8_t          RESERVED_12;
    uint8_t          LINK_STAT;
    uint8_t          WLAN_QUAL;
    uint8_t          SCN_PROG;
    float            USED_FLASH;
    uint32_t         TOTAL_FLASH;
    float            USED_USBM;
    uint32_t         TOTAL_USBM;
    float            MEAS_BUF_UTIL;
    float            MON_BUF_UTIL;

    hk_ctr_1()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , LINK_STAT()
        , WLAN_QUAL()
        , SCN_PROG()
        , USED_FLASH()
        , TOTAL_FLASH()
        , USED_USBM()
        , TOTAL_USBM()
        , MEAS_BUF_UTIL()
        , MON_BUF_UTIL()
    {}

    template<class it>
    hk_ctr_1(const hk_ctr_1<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        LINK_STAT = o.LINK_STAT;
        WLAN_QUAL = o.WLAN_QUAL;
        SCN_PROG = o.SCN_PROG;
        USED_FLASH = o.USED_FLASH;
        TOTAL_FLASH = o.TOTAL_FLASH;
        USED_USBM = o.USED_USBM;
        TOTAL_USBM = o.TOTAL_USBM;
        MEAS_BUF_UTIL = o.MEAS_BUF_UTIL;
        MON_BUF_UTIL = o.MON_BUF_UTIL;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_ctr_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.LINK_STAT;
        s << ", " << x.WLAN_QUAL;
        s << ", " << x.SCN_PROG;
        s << ", " << x.USED_FLASH;
        s << ", " << x.TOTAL_FLASH;
        s << ", " << x.USED_USBM;
        s << ", " << x.TOTAL_USBM;
        s << ", " << x.MEAS_BUF_UTIL;
        s << ", " << x.MON_BUF_UTIL;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_ctr_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.LINK_STAT;
        s >> ',' >> x.WLAN_QUAL;
        s >> ',' >> x.SCN_PROG;
        s >> ',' >> x.USED_FLASH;
        s >> ',' >> x.TOTAL_FLASH;
        s >> ',' >> x.USED_USBM;
        s >> ',' >> x.TOTAL_USBM;
        s >> ',' >> x.MEAS_BUF_UTIL;
        s >> ',' >> x.MON_BUF_UTIL;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_extended_external
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_extended_external<rebind_it> type;
    };

    typedef it iterator_type;

    hk_extended_external(it begin, it end, bool dirty=false)
        : RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10009, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32};
    it begin() const { return RESERVED_01.begin(); }
    it end() const { return RESERVED_04.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_01;
    #else
    binary::field<int8_t, sc_int8, 0, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_02;
    #else
    binary::field<int8_t, sc_int8, 8, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_03;
    #else
    binary::field<uint8_t, sc_uint8, 16, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_04;
    #else
    binary::field<uint8_t, sc_uint8, 24, it> RESERVED_04;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_extended_external& operator=(const hk_extended_external<ito>& o) {
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_extended_external<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_extended_external<rebind_it> type;
    };

    enum { id_main = 10009, id_sub = 0};

    int8_t           RESERVED_01;
    int8_t           RESERVED_02;
    uint8_t          RESERVED_03;
    uint8_t          RESERVED_04;

    hk_extended_external()
        : RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
    {}

    template<class it>
    hk_extended_external(const hk_extended_external<it>& o) {
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_extended_external<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_extended_external<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_extended_internal
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_extended_internal<rebind_it> type;
    };

    typedef it iterator_type;

    hk_extended_internal(it begin, it end, bool dirty=false)
        : RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10008, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 104};
    it begin() const { return RESERVED_01.begin(); }
    it end() const { return RESERVED_11.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_02;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_03;
    #else
    binary::field<int8_t, sc_int8, 32, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_04;
    #else
    binary::field<int8_t, sc_int8, 40, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_05;
    #else
    binary::field<int8_t, sc_int8, 48, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_06;
    #else
    binary::field<int8_t, sc_int8, 56, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_07;
    #else
    binary::field<int8_t, sc_int8, 64, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_08;
    #else
    binary::field<int8_t, sc_int8, 72, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_09;
    #else
    binary::field<int8_t, sc_int8, 80, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_10;
    #else
    binary::field<int8_t, sc_int8, 88, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t RESERVED_11;
    #else
    binary::field<int8_t, sc_int8, 96, it> RESERVED_11;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_extended_internal& operator=(const hk_extended_internal<ito>& o) {
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_extended_internal<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_extended_internal<rebind_it> type;
    };

    enum { id_main = 10008, id_sub = 0};

    uint16_t         RESERVED_01;
    uint16_t         RESERVED_02;
    int8_t           RESERVED_03;
    int8_t           RESERVED_04;
    int8_t           RESERVED_05;
    int8_t           RESERVED_06;
    int8_t           RESERVED_07;
    int8_t           RESERVED_08;
    int8_t           RESERVED_09;
    int8_t           RESERVED_10;
    int8_t           RESERVED_11;

    hk_extended_internal()
        : RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
    {}

    template<class it>
    hk_extended_internal(const hk_extended_internal<it>& o) {
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_extended_internal<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_extended_internal<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_float64_param
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_float64_param<rebind_it> type;
    };

    typedef it iterator_type;

    hk_float64_param(it begin, it end, bool dirty=false)
        : data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 10021, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 20480};
    it begin() const { return data.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : param_id(begin, begin_bit)
            , value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t param_id;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> param_id;
        #endif
        #ifdef DOXYGEN
        double value;
        #else
        binary::field<double, sc_float64, 16, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[256];
    #else
    sequence<hk_float64_param, 80, 0, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    hk_float64_param& operator=(const hk_float64_param<ito>& o) {
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].param_id = o.data[n].param_id;
            data[n].value = o.data[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_float64_param<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_float64_param<rebind_it> type;
    };

    enum { id_main = 10021, id_sub = 0};

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition {
        uint16_t         param_id;
        double           value;
    } data[256];

    hk_float64_param()
    {}

    template<class it>
    hk_float64_param(const hk_float64_param<it>& o) {
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].param_id = o.data[n].param_id;
            data[n].value = o.data[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_float64_param<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].param_id
            << ", " << x.data[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_float64_param<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].param_id)
            >> ',' >> (x.data[x.data_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_float_param
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_float_param<rebind_it> type;
    };

    typedef it iterator_type;

    hk_float_param(it begin, it end, bool dirty=false)
        : data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 10018, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 12288};
    it begin() const { return data.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : param_id(begin, begin_bit)
            , value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t param_id;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> param_id;
        #endif
        #ifdef DOXYGEN
        float value;
        #else
        binary::field<float, sc_float32, 16, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[256];
    #else
    sequence<hk_float_param, 48, 0, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    hk_float_param& operator=(const hk_float_param<ito>& o) {
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].param_id = o.data[n].param_id;
            data[n].value = o.data[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_float_param<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_float_param<rebind_it> type;
    };

    enum { id_main = 10018, id_sub = 0};

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition {
        uint16_t         param_id;
        float            value;
    } data[256];

    hk_float_param()
    {}

    template<class it>
    hk_float_param(const hk_float_param<it>& o) {
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].param_id = o.data[n].param_id;
            data[n].value = o.data[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_float_param<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].param_id
            << ", " << x.data[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_float_param<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].param_id)
            >> ',' >> (x.data[x.data_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! GPS data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_gps
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps<rebind_it> type;
    };

    typedef it iterator_type;

    hk_gps(it begin, it end, bool dirty=false)
        : TOWms(begin)
        , ECEFX(begin)
        , ECEFY(begin)
        , ECEFZ(begin)
        , POS_ACC(begin)
        , LONG(begin)
        , LAT(begin)
        , HGT_ELL(begin)
        , HGT_SEA(begin)
        , HOR_ACC(begin)
        , VERT_ACC(begin)
        , STATUS1(begin)
        , STATUS2(begin)
        , STATUS3(begin)
        , LEAP_SEC(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10005, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 384};
    it begin() const { return TOWms.begin(); }
    it end() const { return LEAP_SEC.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOWms;//!<  GPS data, GPS Time of Week                         [ 1 ms] 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> TOWms;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFX;//!<  GPS data, ECEF X coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 32, it> ECEFX;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFY;//!<  GPS data, ECEF Y coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 64, it> ECEFY;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFZ;//!<  GPS data, ECEF Z coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 96, it> ECEFZ;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t POS_ACC;//!<  GPS data, position accuracy estimate               [ 1 cm] 
    #else
    binary::field<uint32_t, sc_uint32, 128, it> POS_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LONG;//!<  GPS data, longitude                                [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 160, it> LONG;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LAT;//!<  GPS data, latitude                                 [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 192, it> LAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_ELL;//!<  GPS data, height above ellipsoid                   [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 224, it> HGT_ELL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_SEA;//!<  GPS data, height above mean sea level              [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 256, it> HGT_SEA;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t HOR_ACC;//!<  GPS data, horizontal accuracy estimate             [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 288, it> HOR_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t VERT_ACC;//!<  GPS data, vertical accuracy estimate               [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 320, it> VERT_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS1;//!<  GPS data, 0=no fix; 1=dead reckoning; 2=2D-fix;  3=3D-fix; 4=GPS+dead reckoning;5=Time only fix;255=undefined fix 
    #else
    binary::field<uint8_t, sc_uint8, 352, it> STATUS1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS2;//!<  GPS data, 1 .. gpsfixOK; 2 .. diffSoln;  4 .. wknSet; 8 .. towSet 
    #else
    binary::field<uint8_t, sc_uint8, 360, it> STATUS2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS3;//!<  GPS data, 0= no DGPS; 1=PR+PRR Correction;  2=PR+PRR+CP Correction;  3=high accuracy PR+PRR+CP Correction 
    #else
    binary::field<uint8_t, sc_uint8, 368, it> STATUS3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t LEAP_SEC;//!<  GPS data, leap seconds (GPS-UTC)                   [ 1 s ] 
    #else
    binary::field<int8_t, sc_int8, 376, it> LEAP_SEC;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_gps& operator=(const hk_gps<ito>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_gps<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps<rebind_it> type;
    };

    enum { id_main = 10005, id_sub = 0};

    uint32_t         TOWms;
    int32_t          ECEFX;
    int32_t          ECEFY;
    int32_t          ECEFZ;
    uint32_t         POS_ACC;
    int32_t          LONG;
    int32_t          LAT;
    int32_t          HGT_ELL;
    int32_t          HGT_SEA;
    uint32_t         HOR_ACC;
    uint32_t         VERT_ACC;
    uint8_t          STATUS1;
    uint8_t          STATUS2;
    uint8_t          STATUS3;
    int8_t           LEAP_SEC;

    hk_gps()
        : TOWms()
        , ECEFX()
        , ECEFY()
        , ECEFZ()
        , POS_ACC()
        , LONG()
        , LAT()
        , HGT_ELL()
        , HGT_SEA()
        , HOR_ACC()
        , VERT_ACC()
        , STATUS1()
        , STATUS2()
        , STATUS3()
        , LEAP_SEC()
    {}

    template<class it>
    hk_gps(const hk_gps<it>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_gps<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.TOWms;
        s << ", " << x.ECEFX;
        s << ", " << x.ECEFY;
        s << ", " << x.ECEFZ;
        s << ", " << x.POS_ACC;
        s << ", " << x.LONG;
        s << ", " << x.LAT;
        s << ", " << x.HGT_ELL;
        s << ", " << x.HGT_SEA;
        s << ", " << x.HOR_ACC;
        s << ", " << x.VERT_ACC;
        s << ", " << x.STATUS1;
        s << ", " << x.STATUS2;
        s << ", " << x.STATUS3;
        s << ", " << x.LEAP_SEC;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_gps<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.TOWms;
        s >> ',' >> x.ECEFX;
        s >> ',' >> x.ECEFY;
        s >> ',' >> x.ECEFZ;
        s >> ',' >> x.POS_ACC;
        s >> ',' >> x.LONG;
        s >> ',' >> x.LAT;
        s >> ',' >> x.HGT_ELL;
        s >> ',' >> x.HGT_SEA;
        s >> ',' >> x.HOR_ACC;
        s >> ',' >> x.VERT_ACC;
        s >> ',' >> x.STATUS1;
        s >> ',' >> x.STATUS2;
        s >> ',' >> x.STATUS3;
        s >> ',' >> x.LEAP_SEC;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! GPS data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_gps_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_hr<rebind_it> type;
    };

    typedef it iterator_type;

    hk_gps_hr(it begin, it end, bool dirty=false)
        : TOWms(begin)
        , ECEFX(begin)
        , ECEFY(begin)
        , ECEFZ(begin)
        , POS_ACC(begin)
        , LONG(begin)
        , LAT(begin)
        , HGT_ELL(begin)
        , HGT_SEA(begin)
        , HOR_ACC(begin)
        , VERT_ACC(begin)
        , STATUS1(begin)
        , STATUS2(begin)
        , STATUS3(begin)
        , LEAP_SEC(begin)
        , systime(begin)
        , SYNC_STATUS(begin)
        , SAT_NUM(begin)
        , GEOM_DILUT(begin)
        , TIME_DILUT(begin)
        , VERT_DILUT(begin)
        , HOR_DILUT(begin)
        , POS_DILUT(begin)
        , NORTHING(begin)
        , EASTING(begin)
        , HEIGHT(begin)
        , FRAME_ANGLE(begin)
        , PPS_TIME(begin)
        , PPS_CNT(begin)
        , RCV_TIME(begin)
        , VALID_MASK(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10020, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1024};
    it begin() const { return TOWms.begin(); }
    it end() const { return VALID_MASK.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOWms;//!<  GPS data, GPS Time of Week                         [ 1 ms] 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> TOWms;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t ECEFX;//!<  GPS data, ECEF X coordinate                        [ 1 mm] 
    #else
    binary::field<int64_t, sc_int64, 32, it> ECEFX;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t ECEFY;//!<  GPS data, ECEF Y coordinate                        [ 1 mm] 
    #else
    binary::field<int64_t, sc_int64, 96, it> ECEFY;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t ECEFZ;//!<  GPS data, ECEF Z coordinate                        [ 1 mm] 
    #else
    binary::field<int64_t, sc_int64, 160, it> ECEFZ;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t POS_ACC;//!<  GPS data, position accuracy estimate               [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 224, it> POS_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t LONG;//!<  GPS data, longitude                                [1e-9deg] 
    #else
    binary::field<int64_t, sc_int64, 256, it> LONG;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t LAT;//!<  GPS data, latitude                                 [1e-9deg] 
    #else
    binary::field<int64_t, sc_int64, 320, it> LAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_ELL;//!<  GPS data, height above ellipsoid                   [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 384, it> HGT_ELL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_SEA;//!<  GPS data, height above mean sea level              [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 416, it> HGT_SEA;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t HOR_ACC;//!<  GPS data, horizontal accuracy estimate             [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 448, it> HOR_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t VERT_ACC;//!<  GPS data, vertical accuracy estimate               [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 480, it> VERT_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS1;//!<  GPS data, 0=no fix; 1=dead reckoning; 2=2D-fix;  3=3D-fix; 4=GPS+dead reckoning;5=Time only fix;255=undefined fix 
    #else
    binary::field<uint8_t, sc_uint8, 512, it> STATUS1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS2;//!<  GPS data, 1 .. gpsfixOK; 2 .. diffSoln;  4 .. wknSet; 8 .. towSet 
    #else
    binary::field<uint8_t, sc_uint8, 520, it> STATUS2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS3;//!<  GPS data, 0= no DGPS; 1=PR+PRR Correction;  2=PR+PRR+CP Correction;  3=high accuracy PR+PRR+CP Correction 
    #else
    binary::field<uint8_t, sc_uint8, 528, it> STATUS3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t LEAP_SEC;//!<  GPS data, leap seconds (GPS-UTC)                   [ 1 s ] 
    #else
    binary::field<int8_t, sc_int8, 536, it> LEAP_SEC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 544, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t SYNC_STATUS;//!<  PPS pulse and GPS data receive indicator  bit 0: at least one valid gps information seen  bit 1: valid gps information seen during last second  bit 7: gps detected, gps data received within last second 
    #else
    binary::field<uint8_t, sc_uint8, 576, it> SYNC_STATUS;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t SAT_NUM;//!<  GPS data, number of satelites used 
    #else
    binary::field<uint8_t, sc_uint8, 584, it> SAT_NUM;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t GEOM_DILUT;//!<  GPS data, geometric dilution of position           [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 592, it> GEOM_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t TIME_DILUT;//!<  GPS data, time dilution                            [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 608, it> TIME_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t VERT_DILUT;//!<  GPS data, vertical dilution (1D)                   [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 624, it> VERT_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t HOR_DILUT;//!<  GPS data, horizontal dilution (2D)                 [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 640, it> HOR_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t POS_DILUT;//!<  GPS data, position dilution (3D)                   [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 656, it> POS_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t NORTHING;//!<  GPS data, northing                                 [ 1 mm] 
    #else
    binary::field<int64_t, sc_int64, 672, it> NORTHING;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t EASTING;//!<  GPS data, easting                                  [ 1 mm] 
    #else
    binary::field<int64_t, sc_int64, 736, it> EASTING;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t HEIGHT;//!<  GPS data, height                                   [ 1 mm] 
    #else
    binary::field<int64_t, sc_int64, 800, it> HEIGHT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t FRAME_ANGLE;//!<  GPS data, frame angle, unit see units.frame_circle_count 
    #else
    binary::field<uint32_t, sc_uint32, 864, it> FRAME_ANGLE;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t PPS_TIME;//!<  GPS data, internal time of PPS trigger edge in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 896, it> PPS_TIME;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t PPS_CNT;//!<  GPS data, counter of PPS, increments with each detected PPS trigger edge 
    #else
    binary::field<uint32_t, sc_uint32, 928, it> PPS_CNT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RCV_TIME;//!<  GPS data, internal time of receiving the time information in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 960, it> RCV_TIME;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t VALID_MASK;//!<  GPS data, valid mask 
    #else
    binary::field<uint32_t, sc_uint32, 992, it> VALID_MASK;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_gps_hr& operator=(const hk_gps_hr<ito>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
        SYNC_STATUS = o.SYNC_STATUS;
        SAT_NUM = o.SAT_NUM;
        GEOM_DILUT = o.GEOM_DILUT;
        TIME_DILUT = o.TIME_DILUT;
        VERT_DILUT = o.VERT_DILUT;
        HOR_DILUT = o.HOR_DILUT;
        POS_DILUT = o.POS_DILUT;
        NORTHING = o.NORTHING;
        EASTING = o.EASTING;
        HEIGHT = o.HEIGHT;
        FRAME_ANGLE = o.FRAME_ANGLE;
        PPS_TIME = o.PPS_TIME;
        PPS_CNT = o.PPS_CNT;
        RCV_TIME = o.RCV_TIME;
        VALID_MASK = o.VALID_MASK;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_gps_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_hr<rebind_it> type;
    };

    enum { id_main = 10020, id_sub = 0};

    uint32_t         TOWms;
    int64_t          ECEFX;
    int64_t          ECEFY;
    int64_t          ECEFZ;
    uint32_t         POS_ACC;
    int64_t          LONG;
    int64_t          LAT;
    int32_t          HGT_ELL;
    int32_t          HGT_SEA;
    uint32_t         HOR_ACC;
    uint32_t         VERT_ACC;
    uint8_t          STATUS1;
    uint8_t          STATUS2;
    uint8_t          STATUS3;
    int8_t           LEAP_SEC;
    uint32_t         systime;
    uint8_t          SYNC_STATUS;
    uint8_t          SAT_NUM;
    uint16_t         GEOM_DILUT;
    uint16_t         TIME_DILUT;
    uint16_t         VERT_DILUT;
    uint16_t         HOR_DILUT;
    uint16_t         POS_DILUT;
    int64_t          NORTHING;
    int64_t          EASTING;
    int64_t          HEIGHT;
    uint32_t         FRAME_ANGLE;
    uint32_t         PPS_TIME;
    uint32_t         PPS_CNT;
    uint32_t         RCV_TIME;
    uint32_t         VALID_MASK;

    hk_gps_hr()
        : TOWms()
        , ECEFX()
        , ECEFY()
        , ECEFZ()
        , POS_ACC()
        , LONG()
        , LAT()
        , HGT_ELL()
        , HGT_SEA()
        , HOR_ACC()
        , VERT_ACC()
        , STATUS1()
        , STATUS2()
        , STATUS3()
        , LEAP_SEC()
        , systime()
        , SYNC_STATUS()
        , SAT_NUM()
        , GEOM_DILUT()
        , TIME_DILUT()
        , VERT_DILUT()
        , HOR_DILUT()
        , POS_DILUT()
        , NORTHING()
        , EASTING()
        , HEIGHT()
        , FRAME_ANGLE()
        , PPS_TIME()
        , PPS_CNT()
        , RCV_TIME()
        , VALID_MASK()
    {}

    template<class it>
    hk_gps_hr(const hk_gps_hr<it>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
        SYNC_STATUS = o.SYNC_STATUS;
        SAT_NUM = o.SAT_NUM;
        GEOM_DILUT = o.GEOM_DILUT;
        TIME_DILUT = o.TIME_DILUT;
        VERT_DILUT = o.VERT_DILUT;
        HOR_DILUT = o.HOR_DILUT;
        POS_DILUT = o.POS_DILUT;
        NORTHING = o.NORTHING;
        EASTING = o.EASTING;
        HEIGHT = o.HEIGHT;
        FRAME_ANGLE = o.FRAME_ANGLE;
        PPS_TIME = o.PPS_TIME;
        PPS_CNT = o.PPS_CNT;
        RCV_TIME = o.RCV_TIME;
        VALID_MASK = o.VALID_MASK;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_gps_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.TOWms;
        s << ", " << x.ECEFX;
        s << ", " << x.ECEFY;
        s << ", " << x.ECEFZ;
        s << ", " << x.POS_ACC;
        s << ", " << x.LONG;
        s << ", " << x.LAT;
        s << ", " << x.HGT_ELL;
        s << ", " << x.HGT_SEA;
        s << ", " << x.HOR_ACC;
        s << ", " << x.VERT_ACC;
        s << ", " << x.STATUS1;
        s << ", " << x.STATUS2;
        s << ", " << x.STATUS3;
        s << ", " << x.LEAP_SEC;
        s << ", " << x.systime;
        s << ", " << x.SYNC_STATUS;
        s << ", " << x.SAT_NUM;
        s << ", " << x.GEOM_DILUT;
        s << ", " << x.TIME_DILUT;
        s << ", " << x.VERT_DILUT;
        s << ", " << x.HOR_DILUT;
        s << ", " << x.POS_DILUT;
        s << ", " << x.NORTHING;
        s << ", " << x.EASTING;
        s << ", " << x.HEIGHT;
        s << ", " << x.FRAME_ANGLE;
        s << ", " << x.PPS_TIME;
        s << ", " << x.PPS_CNT;
        s << ", " << x.RCV_TIME;
        s << ", " << x.VALID_MASK;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_gps_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.TOWms;
        s >> ',' >> x.ECEFX;
        s >> ',' >> x.ECEFY;
        s >> ',' >> x.ECEFZ;
        s >> ',' >> x.POS_ACC;
        s >> ',' >> x.LONG;
        s >> ',' >> x.LAT;
        s >> ',' >> x.HGT_ELL;
        s >> ',' >> x.HGT_SEA;
        s >> ',' >> x.HOR_ACC;
        s >> ',' >> x.VERT_ACC;
        s >> ',' >> x.STATUS1;
        s >> ',' >> x.STATUS2;
        s >> ',' >> x.STATUS3;
        s >> ',' >> x.LEAP_SEC;
        s >> ',' >> x.systime;
        s >> ',' >> x.SYNC_STATUS;
        s >> ',' >> x.SAT_NUM;
        s >> ',' >> x.GEOM_DILUT;
        s >> ',' >> x.TIME_DILUT;
        s >> ',' >> x.VERT_DILUT;
        s >> ',' >> x.HOR_DILUT;
        s >> ',' >> x.POS_DILUT;
        s >> ',' >> x.NORTHING;
        s >> ',' >> x.EASTING;
        s >> ',' >> x.HEIGHT;
        s >> ',' >> x.FRAME_ANGLE;
        s >> ',' >> x.PPS_TIME;
        s >> ',' >> x.PPS_CNT;
        s >> ',' >> x.RCV_TIME;
        s >> ',' >> x.VALID_MASK;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! GPS data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_gps_ts
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_ts<rebind_it> type;
    };

    typedef it iterator_type;

    hk_gps_ts(it begin, it end, bool dirty=false)
        : TOWms(begin)
        , ECEFX(begin)
        , ECEFY(begin)
        , ECEFZ(begin)
        , POS_ACC(begin)
        , LONG(begin)
        , LAT(begin)
        , HGT_ELL(begin)
        , HGT_SEA(begin)
        , HOR_ACC(begin)
        , VERT_ACC(begin)
        , STATUS1(begin)
        , STATUS2(begin)
        , STATUS3(begin)
        , LEAP_SEC(begin)
        , systime(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10005, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 416};
    it begin() const { return TOWms.begin(); }
    it end() const { return systime.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOWms;//!<  GPS data, GPS Time of Week                         [ 1 ms] 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> TOWms;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFX;//!<  GPS data, ECEF X coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 32, it> ECEFX;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFY;//!<  GPS data, ECEF Y coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 64, it> ECEFY;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFZ;//!<  GPS data, ECEF Z coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 96, it> ECEFZ;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t POS_ACC;//!<  GPS data, position accuracy estimate               [ 1 cm] 
    #else
    binary::field<uint32_t, sc_uint32, 128, it> POS_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LONG;//!<  GPS data, longitude                                [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 160, it> LONG;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LAT;//!<  GPS data, latitude                                 [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 192, it> LAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_ELL;//!<  GPS data, height above ellipsoid                   [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 224, it> HGT_ELL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_SEA;//!<  GPS data, height above mean sea level              [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 256, it> HGT_SEA;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t HOR_ACC;//!<  GPS data, horizontal accuracy estimate             [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 288, it> HOR_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t VERT_ACC;//!<  GPS data, vertical accuracy estimate               [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 320, it> VERT_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS1;//!<  GPS data, 0=no fix; 1=dead reckoning; 2=2D-fix;  3=3D-fix; 4=GPS+dead reckoning;5=Time only fix;255=undefined fix 
    #else
    binary::field<uint8_t, sc_uint8, 352, it> STATUS1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS2;//!<  GPS data, 1 .. gpsfixOK; 2 .. diffSoln;  4 .. wknSet; 8 .. towSet 
    #else
    binary::field<uint8_t, sc_uint8, 360, it> STATUS2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS3;//!<  GPS data, 0= no DGPS; 1=PR+PRR Correction;  2=PR+PRR+CP Correction;  3=high accuracy PR+PRR+CP Correction 
    #else
    binary::field<uint8_t, sc_uint8, 368, it> STATUS3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t LEAP_SEC;//!<  GPS data, leap seconds (GPS-UTC)                   [ 1 s ] 
    #else
    binary::field<int8_t, sc_int8, 376, it> LEAP_SEC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  time stamp of PPS signal measured with internal clock in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 384, it> systime;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_gps_ts& operator=(const hk_gps_ts<ito>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_gps_ts<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_ts<rebind_it> type;
    };

    enum { id_main = 10005, id_sub = 1};

    uint32_t         TOWms;
    int32_t          ECEFX;
    int32_t          ECEFY;
    int32_t          ECEFZ;
    uint32_t         POS_ACC;
    int32_t          LONG;
    int32_t          LAT;
    int32_t          HGT_ELL;
    int32_t          HGT_SEA;
    uint32_t         HOR_ACC;
    uint32_t         VERT_ACC;
    uint8_t          STATUS1;
    uint8_t          STATUS2;
    uint8_t          STATUS3;
    int8_t           LEAP_SEC;
    uint32_t         systime;

    hk_gps_ts()
        : TOWms()
        , ECEFX()
        , ECEFY()
        , ECEFZ()
        , POS_ACC()
        , LONG()
        , LAT()
        , HGT_ELL()
        , HGT_SEA()
        , HOR_ACC()
        , VERT_ACC()
        , STATUS1()
        , STATUS2()
        , STATUS3()
        , LEAP_SEC()
        , systime()
    {}

    template<class it>
    hk_gps_ts(const hk_gps_ts<it>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_gps_ts<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.TOWms;
        s << ", " << x.ECEFX;
        s << ", " << x.ECEFY;
        s << ", " << x.ECEFZ;
        s << ", " << x.POS_ACC;
        s << ", " << x.LONG;
        s << ", " << x.LAT;
        s << ", " << x.HGT_ELL;
        s << ", " << x.HGT_SEA;
        s << ", " << x.HOR_ACC;
        s << ", " << x.VERT_ACC;
        s << ", " << x.STATUS1;
        s << ", " << x.STATUS2;
        s << ", " << x.STATUS3;
        s << ", " << x.LEAP_SEC;
        s << ", " << x.systime;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_gps_ts<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.TOWms;
        s >> ',' >> x.ECEFX;
        s >> ',' >> x.ECEFY;
        s >> ',' >> x.ECEFZ;
        s >> ',' >> x.POS_ACC;
        s >> ',' >> x.LONG;
        s >> ',' >> x.LAT;
        s >> ',' >> x.HGT_ELL;
        s >> ',' >> x.HGT_SEA;
        s >> ',' >> x.HOR_ACC;
        s >> ',' >> x.VERT_ACC;
        s >> ',' >> x.STATUS1;
        s >> ',' >> x.STATUS2;
        s >> ',' >> x.STATUS3;
        s >> ',' >> x.LEAP_SEC;
        s >> ',' >> x.systime;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! GPS data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_gps_ts_status
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_ts_status<rebind_it> type;
    };

    typedef it iterator_type;

    hk_gps_ts_status(it begin, it end, bool dirty=false)
        : TOWms(begin)
        , ECEFX(begin)
        , ECEFY(begin)
        , ECEFZ(begin)
        , POS_ACC(begin)
        , LONG(begin)
        , LAT(begin)
        , HGT_ELL(begin)
        , HGT_SEA(begin)
        , HOR_ACC(begin)
        , VERT_ACC(begin)
        , STATUS1(begin)
        , STATUS2(begin)
        , STATUS3(begin)
        , LEAP_SEC(begin)
        , systime(begin)
        , SYNC_STATUS(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10005, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 424};
    it begin() const { return TOWms.begin(); }
    it end() const { return SYNC_STATUS.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOWms;//!<  GPS data, GPS Time of Week                         [ 1 ms] 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> TOWms;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFX;//!<  GPS data, ECEF X coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 32, it> ECEFX;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFY;//!<  GPS data, ECEF Y coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 64, it> ECEFY;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFZ;//!<  GPS data, ECEF Z coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 96, it> ECEFZ;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t POS_ACC;//!<  GPS data, position accuracy estimate               [ 1 cm] 
    #else
    binary::field<uint32_t, sc_uint32, 128, it> POS_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LONG;//!<  GPS data, longitude                                [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 160, it> LONG;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LAT;//!<  GPS data, latitude                                 [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 192, it> LAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_ELL;//!<  GPS data, height above ellipsoid                   [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 224, it> HGT_ELL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_SEA;//!<  GPS data, height above mean sea level              [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 256, it> HGT_SEA;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t HOR_ACC;//!<  GPS data, horizontal accuracy estimate             [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 288, it> HOR_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t VERT_ACC;//!<  GPS data, vertical accuracy estimate               [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 320, it> VERT_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS1;//!<  GPS data, 0=no fix; 1=dead reckoning; 2=2D-fix;  3=3D-fix; 4=GPS+dead reckoning;5=Time only fix;255=undefined fix 
    #else
    binary::field<uint8_t, sc_uint8, 352, it> STATUS1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS2;//!<  GPS data, 1 .. gpsfixOK; 2 .. diffSoln;  4 .. wknSet; 8 .. towSet 
    #else
    binary::field<uint8_t, sc_uint8, 360, it> STATUS2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS3;//!<  GPS data, 0= no DGPS; 1=PR+PRR Correction;  2=PR+PRR+CP Correction;  3=high accuracy PR+PRR+CP Correction 
    #else
    binary::field<uint8_t, sc_uint8, 368, it> STATUS3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t LEAP_SEC;//!<  GPS data, leap seconds (GPS-UTC)                   [ 1 s ] 
    #else
    binary::field<int8_t, sc_int8, 376, it> LEAP_SEC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 384, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t SYNC_STATUS;//!<  PPS pulse and GPS data receive indicator  bit 0: at least one valid gps information seen  bit 1: valid gps information seen during last second 
    #else
    binary::field<uint8_t, sc_uint8, 416, it> SYNC_STATUS;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_gps_ts_status& operator=(const hk_gps_ts_status<ito>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
        SYNC_STATUS = o.SYNC_STATUS;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_gps_ts_status<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_ts_status<rebind_it> type;
    };

    enum { id_main = 10005, id_sub = 2};

    uint32_t         TOWms;
    int32_t          ECEFX;
    int32_t          ECEFY;
    int32_t          ECEFZ;
    uint32_t         POS_ACC;
    int32_t          LONG;
    int32_t          LAT;
    int32_t          HGT_ELL;
    int32_t          HGT_SEA;
    uint32_t         HOR_ACC;
    uint32_t         VERT_ACC;
    uint8_t          STATUS1;
    uint8_t          STATUS2;
    uint8_t          STATUS3;
    int8_t           LEAP_SEC;
    uint32_t         systime;
    uint8_t          SYNC_STATUS;

    hk_gps_ts_status()
        : TOWms()
        , ECEFX()
        , ECEFY()
        , ECEFZ()
        , POS_ACC()
        , LONG()
        , LAT()
        , HGT_ELL()
        , HGT_SEA()
        , HOR_ACC()
        , VERT_ACC()
        , STATUS1()
        , STATUS2()
        , STATUS3()
        , LEAP_SEC()
        , systime()
        , SYNC_STATUS()
    {}

    template<class it>
    hk_gps_ts_status(const hk_gps_ts_status<it>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
        SYNC_STATUS = o.SYNC_STATUS;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_gps_ts_status<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.TOWms;
        s << ", " << x.ECEFX;
        s << ", " << x.ECEFY;
        s << ", " << x.ECEFZ;
        s << ", " << x.POS_ACC;
        s << ", " << x.LONG;
        s << ", " << x.LAT;
        s << ", " << x.HGT_ELL;
        s << ", " << x.HGT_SEA;
        s << ", " << x.HOR_ACC;
        s << ", " << x.VERT_ACC;
        s << ", " << x.STATUS1;
        s << ", " << x.STATUS2;
        s << ", " << x.STATUS3;
        s << ", " << x.LEAP_SEC;
        s << ", " << x.systime;
        s << ", " << x.SYNC_STATUS;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_gps_ts_status<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.TOWms;
        s >> ',' >> x.ECEFX;
        s >> ',' >> x.ECEFY;
        s >> ',' >> x.ECEFZ;
        s >> ',' >> x.POS_ACC;
        s >> ',' >> x.LONG;
        s >> ',' >> x.LAT;
        s >> ',' >> x.HGT_ELL;
        s >> ',' >> x.HGT_SEA;
        s >> ',' >> x.HOR_ACC;
        s >> ',' >> x.VERT_ACC;
        s >> ',' >> x.STATUS1;
        s >> ',' >> x.STATUS2;
        s >> ',' >> x.STATUS3;
        s >> ',' >> x.LEAP_SEC;
        s >> ',' >> x.systime;
        s >> ',' >> x.SYNC_STATUS;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! GPS data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_gps_ts_status_dop
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_ts_status_dop<rebind_it> type;
    };

    typedef it iterator_type;

    hk_gps_ts_status_dop(it begin, it end, bool dirty=false)
        : TOWms(begin)
        , ECEFX(begin)
        , ECEFY(begin)
        , ECEFZ(begin)
        , POS_ACC(begin)
        , LONG(begin)
        , LAT(begin)
        , HGT_ELL(begin)
        , HGT_SEA(begin)
        , HOR_ACC(begin)
        , VERT_ACC(begin)
        , STATUS1(begin)
        , STATUS2(begin)
        , STATUS3(begin)
        , LEAP_SEC(begin)
        , systime(begin)
        , SYNC_STATUS(begin)
        , SAT_NUM(begin)
        , GEOM_DILUT(begin)
        , TIME_DILUT(begin)
        , VERT_DILUT(begin)
        , HOR_DILUT(begin)
        , POS_DILUT(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10005, id_sub = 3};
    #ifndef DOXYGEN
    enum { max_bit_width = 512};
    it begin() const { return TOWms.begin(); }
    it end() const { return POS_DILUT.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOWms;//!<  GPS data, GPS Time of Week                         [ 1 ms] 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> TOWms;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFX;//!<  GPS data, ECEF X coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 32, it> ECEFX;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFY;//!<  GPS data, ECEF Y coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 64, it> ECEFY;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFZ;//!<  GPS data, ECEF Z coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 96, it> ECEFZ;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t POS_ACC;//!<  GPS data, position accuracy estimate               [ 1 cm] 
    #else
    binary::field<uint32_t, sc_uint32, 128, it> POS_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LONG;//!<  GPS data, longitude                                [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 160, it> LONG;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LAT;//!<  GPS data, latitude                                 [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 192, it> LAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_ELL;//!<  GPS data, height above ellipsoid                   [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 224, it> HGT_ELL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_SEA;//!<  GPS data, height above mean sea level              [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 256, it> HGT_SEA;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t HOR_ACC;//!<  GPS data, horizontal accuracy estimate             [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 288, it> HOR_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t VERT_ACC;//!<  GPS data, vertical accuracy estimate               [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 320, it> VERT_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS1;//!<  GPS data, 0=no fix; 1=dead reckoning; 2=2D-fix;  3=3D-fix; 4=GPS+dead reckoning;5=Time only fix;255=undefined fix 
    #else
    binary::field<uint8_t, sc_uint8, 352, it> STATUS1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS2;//!<  GPS data, 1 .. gpsfixOK; 2 .. diffSoln;  4 .. wknSet; 8 .. towSet 
    #else
    binary::field<uint8_t, sc_uint8, 360, it> STATUS2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS3;//!<  GPS data, 0= no DGPS; 1=PR+PRR Correction;  2=PR+PRR+CP Correction;  3=high accuracy PR+PRR+CP Correction 
    #else
    binary::field<uint8_t, sc_uint8, 368, it> STATUS3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t LEAP_SEC;//!<  GPS data, leap seconds (GPS-UTC)                   [ 1 s ] 
    #else
    binary::field<int8_t, sc_int8, 376, it> LEAP_SEC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 384, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t SYNC_STATUS;//!<  PPS pulse and GPS data receive indicator  bit 0: at least one valid gps information seen  bit 1: valid gps information seen during last second  bit 7: gps detected, gps data received within last second 
    #else
    binary::field<uint8_t, sc_uint8, 416, it> SYNC_STATUS;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t SAT_NUM;//!<  GPS data, number of satelites used 
    #else
    binary::field<uint8_t, sc_uint8, 424, it> SAT_NUM;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t GEOM_DILUT;//!<  GPS data, geometric dilution of position        [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 432, it> GEOM_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t TIME_DILUT;//!<  GPS data, time dilution        [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 448, it> TIME_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t VERT_DILUT;//!<  GPS data, vertical dilution (1D)       [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 464, it> VERT_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t HOR_DILUT;//!<  GPS data, horizontal dilution (2D)       [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 480, it> HOR_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t POS_DILUT;//!<  GPS data, position dilution (3D)       [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 496, it> POS_DILUT;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_gps_ts_status_dop& operator=(const hk_gps_ts_status_dop<ito>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
        SYNC_STATUS = o.SYNC_STATUS;
        SAT_NUM = o.SAT_NUM;
        GEOM_DILUT = o.GEOM_DILUT;
        TIME_DILUT = o.TIME_DILUT;
        VERT_DILUT = o.VERT_DILUT;
        HOR_DILUT = o.HOR_DILUT;
        POS_DILUT = o.POS_DILUT;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_gps_ts_status_dop<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_ts_status_dop<rebind_it> type;
    };

    enum { id_main = 10005, id_sub = 3};

    uint32_t         TOWms;
    int32_t          ECEFX;
    int32_t          ECEFY;
    int32_t          ECEFZ;
    uint32_t         POS_ACC;
    int32_t          LONG;
    int32_t          LAT;
    int32_t          HGT_ELL;
    int32_t          HGT_SEA;
    uint32_t         HOR_ACC;
    uint32_t         VERT_ACC;
    uint8_t          STATUS1;
    uint8_t          STATUS2;
    uint8_t          STATUS3;
    int8_t           LEAP_SEC;
    uint32_t         systime;
    uint8_t          SYNC_STATUS;
    uint8_t          SAT_NUM;
    uint16_t         GEOM_DILUT;
    uint16_t         TIME_DILUT;
    uint16_t         VERT_DILUT;
    uint16_t         HOR_DILUT;
    uint16_t         POS_DILUT;

    hk_gps_ts_status_dop()
        : TOWms()
        , ECEFX()
        , ECEFY()
        , ECEFZ()
        , POS_ACC()
        , LONG()
        , LAT()
        , HGT_ELL()
        , HGT_SEA()
        , HOR_ACC()
        , VERT_ACC()
        , STATUS1()
        , STATUS2()
        , STATUS3()
        , LEAP_SEC()
        , systime()
        , SYNC_STATUS()
        , SAT_NUM()
        , GEOM_DILUT()
        , TIME_DILUT()
        , VERT_DILUT()
        , HOR_DILUT()
        , POS_DILUT()
    {}

    template<class it>
    hk_gps_ts_status_dop(const hk_gps_ts_status_dop<it>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
        SYNC_STATUS = o.SYNC_STATUS;
        SAT_NUM = o.SAT_NUM;
        GEOM_DILUT = o.GEOM_DILUT;
        TIME_DILUT = o.TIME_DILUT;
        VERT_DILUT = o.VERT_DILUT;
        HOR_DILUT = o.HOR_DILUT;
        POS_DILUT = o.POS_DILUT;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_gps_ts_status_dop<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.TOWms;
        s << ", " << x.ECEFX;
        s << ", " << x.ECEFY;
        s << ", " << x.ECEFZ;
        s << ", " << x.POS_ACC;
        s << ", " << x.LONG;
        s << ", " << x.LAT;
        s << ", " << x.HGT_ELL;
        s << ", " << x.HGT_SEA;
        s << ", " << x.HOR_ACC;
        s << ", " << x.VERT_ACC;
        s << ", " << x.STATUS1;
        s << ", " << x.STATUS2;
        s << ", " << x.STATUS3;
        s << ", " << x.LEAP_SEC;
        s << ", " << x.systime;
        s << ", " << x.SYNC_STATUS;
        s << ", " << x.SAT_NUM;
        s << ", " << x.GEOM_DILUT;
        s << ", " << x.TIME_DILUT;
        s << ", " << x.VERT_DILUT;
        s << ", " << x.HOR_DILUT;
        s << ", " << x.POS_DILUT;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_gps_ts_status_dop<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.TOWms;
        s >> ',' >> x.ECEFX;
        s >> ',' >> x.ECEFY;
        s >> ',' >> x.ECEFZ;
        s >> ',' >> x.POS_ACC;
        s >> ',' >> x.LONG;
        s >> ',' >> x.LAT;
        s >> ',' >> x.HGT_ELL;
        s >> ',' >> x.HGT_SEA;
        s >> ',' >> x.HOR_ACC;
        s >> ',' >> x.VERT_ACC;
        s >> ',' >> x.STATUS1;
        s >> ',' >> x.STATUS2;
        s >> ',' >> x.STATUS3;
        s >> ',' >> x.LEAP_SEC;
        s >> ',' >> x.systime;
        s >> ',' >> x.SYNC_STATUS;
        s >> ',' >> x.SAT_NUM;
        s >> ',' >> x.GEOM_DILUT;
        s >> ',' >> x.TIME_DILUT;
        s >> ',' >> x.VERT_DILUT;
        s >> ',' >> x.HOR_DILUT;
        s >> ',' >> x.POS_DILUT;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! GPS data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_gps_ts_status_dop_ucs
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_ts_status_dop_ucs<rebind_it> type;
    };

    typedef it iterator_type;

    hk_gps_ts_status_dop_ucs(it begin, it end, bool dirty=false)
        : TOWms(begin)
        , ECEFX(begin)
        , ECEFY(begin)
        , ECEFZ(begin)
        , POS_ACC(begin)
        , LONG(begin)
        , LAT(begin)
        , HGT_ELL(begin)
        , HGT_SEA(begin)
        , HOR_ACC(begin)
        , VERT_ACC(begin)
        , STATUS1(begin)
        , STATUS2(begin)
        , STATUS3(begin)
        , LEAP_SEC(begin)
        , systime(begin)
        , SYNC_STATUS(begin)
        , SAT_NUM(begin)
        , GEOM_DILUT(begin)
        , TIME_DILUT(begin)
        , VERT_DILUT(begin)
        , HOR_DILUT(begin)
        , POS_DILUT(begin)
        , NORTHING(begin)
        , EASTING(begin)
        , HEIGHT(begin)
        , FRAME_ANGLE(begin)
        , PPS_TIME(begin)
        , PPS_CNT(begin)
        , RCV_TIME(begin)
        , VALID_MASK(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10005, id_sub = 4};
    #ifndef DOXYGEN
    enum { max_bit_width = 864};
    it begin() const { return TOWms.begin(); }
    it end() const { return VALID_MASK.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t TOWms;//!<  GPS data, GPS Time of Week                         [ 1 ms] 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> TOWms;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFX;//!<  GPS data, ECEF X coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 32, it> ECEFX;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFY;//!<  GPS data, ECEF Y coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 64, it> ECEFY;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ECEFZ;//!<  GPS data, ECEF Z coordinate                        [ 1 cm] 
    #else
    binary::field<int32_t, sc_int32, 96, it> ECEFZ;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t POS_ACC;//!<  GPS data, position accuracy estimate               [ 1 cm] 
    #else
    binary::field<uint32_t, sc_uint32, 128, it> POS_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LONG;//!<  GPS data, longitude                                [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 160, it> LONG;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t LAT;//!<  GPS data, latitude                                 [1e-7deg] 
    #else
    binary::field<int32_t, sc_int32, 192, it> LAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_ELL;//!<  GPS data, height above ellipsoid                   [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 224, it> HGT_ELL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t HGT_SEA;//!<  GPS data, height above mean sea level              [ 1 mm] 
    #else
    binary::field<int32_t, sc_int32, 256, it> HGT_SEA;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t HOR_ACC;//!<  GPS data, horizontal accuracy estimate             [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 288, it> HOR_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t VERT_ACC;//!<  GPS data, vertical accuracy estimate               [ 1 mm] 
    #else
    binary::field<uint32_t, sc_uint32, 320, it> VERT_ACC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS1;//!<  GPS data, 0=no fix; 1=dead reckoning; 2=2D-fix;  3=3D-fix; 4=GPS+dead reckoning;5=Time only fix;255=undefined fix 
    #else
    binary::field<uint8_t, sc_uint8, 352, it> STATUS1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS2;//!<  GPS data, 1 .. gpsfixOK; 2 .. diffSoln;  4 .. wknSet; 8 .. towSet 
    #else
    binary::field<uint8_t, sc_uint8, 360, it> STATUS2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t STATUS3;//!<  GPS data, 0= no DGPS; 1=PR+PRR Correction;  2=PR+PRR+CP Correction;  3=high accuracy PR+PRR+CP Correction 
    #else
    binary::field<uint8_t, sc_uint8, 368, it> STATUS3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t LEAP_SEC;//!<  GPS data, leap seconds (GPS-UTC)                   [ 1 s ] 
    #else
    binary::field<int8_t, sc_int8, 376, it> LEAP_SEC;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 384, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t SYNC_STATUS;//!<  PPS pulse and GPS data receive indicator  bit 0: at least one valid gps information seen  bit 1: valid gps information seen during last second  bit 7: gps detected, gps data received within last second 
    #else
    binary::field<uint8_t, sc_uint8, 416, it> SYNC_STATUS;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t SAT_NUM;//!<  GPS data, number of satelites used 
    #else
    binary::field<uint8_t, sc_uint8, 424, it> SAT_NUM;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t GEOM_DILUT;//!<  GPS data, geometric dilution of position        [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 432, it> GEOM_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t TIME_DILUT;//!<  GPS data, time dilution        [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 448, it> TIME_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t VERT_DILUT;//!<  GPS data, vertical dilution (1D)       [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 464, it> VERT_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t HOR_DILUT;//!<  GPS data, horizontal dilution (2D)       [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 480, it> HOR_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t POS_DILUT;//!<  GPS data, position dilution (3D)       [0.01] 
    #else
    binary::field<uint16_t, sc_uint16, 496, it> POS_DILUT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t NORTHING;//!<  GPS data, northing                                [mm] 
    #else
    binary::field<int64_t, sc_int64, 512, it> NORTHING;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t EASTING;//!<  GPS data, easting                                 [mm] 
    #else
    binary::field<int64_t, sc_int64, 576, it> EASTING;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int64_t HEIGHT;//!<  GPS data, height                                  [mm] 
    #else
    binary::field<int64_t, sc_int64, 640, it> HEIGHT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t FRAME_ANGLE;//!<  GPS data, frame angle, unit see units.frame_circle_count 
    #else
    binary::field<uint32_t, sc_uint32, 704, it> FRAME_ANGLE;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t PPS_TIME;//!<  GPS data, internal time of PPS trigger edge in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 736, it> PPS_TIME;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t PPS_CNT;//!<  GPS data, counter of PPS, increments with each detected PPS trigger edge 
    #else
    binary::field<uint32_t, sc_uint32, 768, it> PPS_CNT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RCV_TIME;//!<  GPS data, internal time of receiving the time information in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 800, it> RCV_TIME;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t VALID_MASK;//!<  GPS data, valid mask 
    #else
    binary::field<uint32_t, sc_uint32, 832, it> VALID_MASK;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_gps_ts_status_dop_ucs& operator=(const hk_gps_ts_status_dop_ucs<ito>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
        SYNC_STATUS = o.SYNC_STATUS;
        SAT_NUM = o.SAT_NUM;
        GEOM_DILUT = o.GEOM_DILUT;
        TIME_DILUT = o.TIME_DILUT;
        VERT_DILUT = o.VERT_DILUT;
        HOR_DILUT = o.HOR_DILUT;
        POS_DILUT = o.POS_DILUT;
        NORTHING = o.NORTHING;
        EASTING = o.EASTING;
        HEIGHT = o.HEIGHT;
        FRAME_ANGLE = o.FRAME_ANGLE;
        PPS_TIME = o.PPS_TIME;
        PPS_CNT = o.PPS_CNT;
        RCV_TIME = o.RCV_TIME;
        VALID_MASK = o.VALID_MASK;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_gps_ts_status_dop_ucs<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_gps_ts_status_dop_ucs<rebind_it> type;
    };

    enum { id_main = 10005, id_sub = 4};

    uint32_t         TOWms;
    int32_t          ECEFX;
    int32_t          ECEFY;
    int32_t          ECEFZ;
    uint32_t         POS_ACC;
    int32_t          LONG;
    int32_t          LAT;
    int32_t          HGT_ELL;
    int32_t          HGT_SEA;
    uint32_t         HOR_ACC;
    uint32_t         VERT_ACC;
    uint8_t          STATUS1;
    uint8_t          STATUS2;
    uint8_t          STATUS3;
    int8_t           LEAP_SEC;
    uint32_t         systime;
    uint8_t          SYNC_STATUS;
    uint8_t          SAT_NUM;
    uint16_t         GEOM_DILUT;
    uint16_t         TIME_DILUT;
    uint16_t         VERT_DILUT;
    uint16_t         HOR_DILUT;
    uint16_t         POS_DILUT;
    int64_t          NORTHING;
    int64_t          EASTING;
    int64_t          HEIGHT;
    uint32_t         FRAME_ANGLE;
    uint32_t         PPS_TIME;
    uint32_t         PPS_CNT;
    uint32_t         RCV_TIME;
    uint32_t         VALID_MASK;

    hk_gps_ts_status_dop_ucs()
        : TOWms()
        , ECEFX()
        , ECEFY()
        , ECEFZ()
        , POS_ACC()
        , LONG()
        , LAT()
        , HGT_ELL()
        , HGT_SEA()
        , HOR_ACC()
        , VERT_ACC()
        , STATUS1()
        , STATUS2()
        , STATUS3()
        , LEAP_SEC()
        , systime()
        , SYNC_STATUS()
        , SAT_NUM()
        , GEOM_DILUT()
        , TIME_DILUT()
        , VERT_DILUT()
        , HOR_DILUT()
        , POS_DILUT()
        , NORTHING()
        , EASTING()
        , HEIGHT()
        , FRAME_ANGLE()
        , PPS_TIME()
        , PPS_CNT()
        , RCV_TIME()
        , VALID_MASK()
    {}

    template<class it>
    hk_gps_ts_status_dop_ucs(const hk_gps_ts_status_dop_ucs<it>& o) {
        TOWms = o.TOWms;
        ECEFX = o.ECEFX;
        ECEFY = o.ECEFY;
        ECEFZ = o.ECEFZ;
        POS_ACC = o.POS_ACC;
        LONG = o.LONG;
        LAT = o.LAT;
        HGT_ELL = o.HGT_ELL;
        HGT_SEA = o.HGT_SEA;
        HOR_ACC = o.HOR_ACC;
        VERT_ACC = o.VERT_ACC;
        STATUS1 = o.STATUS1;
        STATUS2 = o.STATUS2;
        STATUS3 = o.STATUS3;
        LEAP_SEC = o.LEAP_SEC;
        systime = o.systime;
        SYNC_STATUS = o.SYNC_STATUS;
        SAT_NUM = o.SAT_NUM;
        GEOM_DILUT = o.GEOM_DILUT;
        TIME_DILUT = o.TIME_DILUT;
        VERT_DILUT = o.VERT_DILUT;
        HOR_DILUT = o.HOR_DILUT;
        POS_DILUT = o.POS_DILUT;
        NORTHING = o.NORTHING;
        EASTING = o.EASTING;
        HEIGHT = o.HEIGHT;
        FRAME_ANGLE = o.FRAME_ANGLE;
        PPS_TIME = o.PPS_TIME;
        PPS_CNT = o.PPS_CNT;
        RCV_TIME = o.RCV_TIME;
        VALID_MASK = o.VALID_MASK;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_gps_ts_status_dop_ucs<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.TOWms;
        s << ", " << x.ECEFX;
        s << ", " << x.ECEFY;
        s << ", " << x.ECEFZ;
        s << ", " << x.POS_ACC;
        s << ", " << x.LONG;
        s << ", " << x.LAT;
        s << ", " << x.HGT_ELL;
        s << ", " << x.HGT_SEA;
        s << ", " << x.HOR_ACC;
        s << ", " << x.VERT_ACC;
        s << ", " << x.STATUS1;
        s << ", " << x.STATUS2;
        s << ", " << x.STATUS3;
        s << ", " << x.LEAP_SEC;
        s << ", " << x.systime;
        s << ", " << x.SYNC_STATUS;
        s << ", " << x.SAT_NUM;
        s << ", " << x.GEOM_DILUT;
        s << ", " << x.TIME_DILUT;
        s << ", " << x.VERT_DILUT;
        s << ", " << x.HOR_DILUT;
        s << ", " << x.POS_DILUT;
        s << ", " << x.NORTHING;
        s << ", " << x.EASTING;
        s << ", " << x.HEIGHT;
        s << ", " << x.FRAME_ANGLE;
        s << ", " << x.PPS_TIME;
        s << ", " << x.PPS_CNT;
        s << ", " << x.RCV_TIME;
        s << ", " << x.VALID_MASK;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_gps_ts_status_dop_ucs<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.TOWms;
        s >> ',' >> x.ECEFX;
        s >> ',' >> x.ECEFY;
        s >> ',' >> x.ECEFZ;
        s >> ',' >> x.POS_ACC;
        s >> ',' >> x.LONG;
        s >> ',' >> x.LAT;
        s >> ',' >> x.HGT_ELL;
        s >> ',' >> x.HGT_SEA;
        s >> ',' >> x.HOR_ACC;
        s >> ',' >> x.VERT_ACC;
        s >> ',' >> x.STATUS1;
        s >> ',' >> x.STATUS2;
        s >> ',' >> x.STATUS3;
        s >> ',' >> x.LEAP_SEC;
        s >> ',' >> x.systime;
        s >> ',' >> x.SYNC_STATUS;
        s >> ',' >> x.SAT_NUM;
        s >> ',' >> x.GEOM_DILUT;
        s >> ',' >> x.TIME_DILUT;
        s >> ',' >> x.VERT_DILUT;
        s >> ',' >> x.HOR_DILUT;
        s >> ',' >> x.POS_DILUT;
        s >> ',' >> x.NORTHING;
        s >> ',' >> x.EASTING;
        s >> ',' >> x.HEIGHT;
        s >> ',' >> x.FRAME_ANGLE;
        s >> ',' >> x.PPS_TIME;
        s >> ',' >> x.PPS_CNT;
        s >> ',' >> x.RCV_TIME;
        s >> ',' >> x.VALID_MASK;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_group_header
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_group_header<rebind_it> type;
    };

    typedef it iterator_type;

    hk_group_header(it begin, it end, bool dirty=false)
        : group_id(begin)
        , name(begin)
        , desc(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10016, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 776};
    it begin() const { return group_id.begin(); }
    it end() const { return desc.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t group_id;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> group_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t name[32];
    #else
    binary::array<uint8_t, 32, sc_uint8, 8, it> name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t desc[64];
    #else
    binary::array<uint8_t, 64, sc_uint8, 264, it> desc;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_group_header& operator=(const hk_group_header<ito>& o) {
        group_id = o.group_id;
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        for(unsigned n=0; n<64; ++n) desc[n] = o.desc[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_group_header<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_group_header<rebind_it> type;
    };

    enum { id_main = 10016, id_sub = 0};

    uint8_t          group_id;
    uint8_t          name[32];
    uint8_t          desc[64];

    hk_group_header()
        : group_id()
        , name()
        , desc()
    {}

    template<class it>
    hk_group_header(const hk_group_header<it>& o) {
        group_id = o.group_id;
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        for(unsigned n=0; n<64; ++n) desc[n] = o.desc[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_group_header<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.group_id;
        s << ", "; write_array(s, 32, x.name);
        s << ", "; write_array(s, 64, x.desc);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_group_header<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.group_id;
        s >> ','; read_array(s, 32, x.name);
        s >> ','; read_array(s, 64, x.desc);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! inclination sensor

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_incl
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_incl<rebind_it> type;
    };

    typedef it iterator_type;

    hk_incl(it begin, it end, bool dirty=false)
        : ROLL(begin)
        , PITCH(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10006, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 64};
    it begin() const { return ROLL.begin(); }
    it end() const { return RESERVED_03.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t ROLL;//!<  inclination angle along x-axis   [0.001 deg ] 
    #else
    binary::field<int16_t, sc_int16, 0, it> ROLL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t PITCH;//!<  inclination angle along y-axis   [0.001 deg ] 
    #else
    binary::field<int16_t, sc_int16, 16, it> PITCH;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;//!<  INTERNAL ONLY inclination sensor 1 temperature [ 0.1 deg C] 
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_03;//!<  INTERNAL ONLY inclination sensor 2 temperature [ 0.1 deg C] 
    #else
    binary::field<int16_t, sc_int16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_incl& operator=(const hk_incl<ito>& o) {
        ROLL = o.ROLL;
        PITCH = o.PITCH;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_incl<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_incl<rebind_it> type;
    };

    enum { id_main = 10006, id_sub = 0};

    int16_t          ROLL;
    int16_t          PITCH;
    int16_t          RESERVED_02;
    int16_t          RESERVED_03;

    hk_incl()
        : ROLL()
        , PITCH()
        , RESERVED_02()
        , RESERVED_03()
    {}

    template<class it>
    hk_incl(const hk_incl<it>& o) {
        ROLL = o.ROLL;
        PITCH = o.PITCH;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_incl<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.ROLL;
        s << ", " << x.PITCH;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_incl<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.ROLL;
        s >> ',' >> x.PITCH;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! inclination sensor

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_incl_4axes
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_incl_4axes<rebind_it> type;
    };

    typedef it iterator_type;

    hk_incl_4axes(it begin, it end, bool dirty=false)
        : ROLL(begin)
        , PITCH(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10012, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return ROLL.begin(); }
    it end() const { return RESERVED_05.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t ROLL;//!<  inclination angle along x-axis [0.001 deg ] 
    #else
    binary::field<int32_t, sc_int32, 0, it> ROLL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t PITCH;//!<  inclination angle along y-axis [0.001 deg ] 
    #else
    binary::field<int32_t, sc_int32, 32, it> PITCH;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;//!<  INTERNAL ONLY inclination sensor 1-1 temperature [ 0.1 deg C] 
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_03;//!<  INTERNAL ONLY inclination sensor 1-2 temperature [ 0.1 deg C] 
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;//!<  INTERNAL ONLY inclination sensor 2-1 temperature [ 0.1 deg C] 
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;//!<  INTERNAL ONLY inclination sensor 2-2 temperature [ 0.1 deg C] 
    #else
    binary::field<int16_t, sc_int16, 112, it> RESERVED_05;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_incl_4axes& operator=(const hk_incl_4axes<ito>& o) {
        ROLL = o.ROLL;
        PITCH = o.PITCH;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_incl_4axes<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_incl_4axes<rebind_it> type;
    };

    enum { id_main = 10012, id_sub = 0};

    int32_t          ROLL;
    int32_t          PITCH;
    int16_t          RESERVED_02;
    int16_t          RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;

    hk_incl_4axes()
        : ROLL()
        , PITCH()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
    {}

    template<class it>
    hk_incl_4axes(const hk_incl_4axes<it>& o) {
        ROLL = o.ROLL;
        PITCH = o.PITCH;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_incl_4axes<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.ROLL;
        s << ", " << x.PITCH;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_incl_4axes<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.ROLL;
        s >> ',' >> x.PITCH;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_monitor
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_monitor<rebind_it> type;
    };

    typedef it iterator_type;

    hk_monitor(it begin, it end, bool dirty=false)
        : t_instrument(begin)
        , u_supply(begin)
        , i_supply(begin)
        , status(begin)
        , optime_instrument(begin)
        , optime_laser(begin)
        , optime_line_motor(begin)
        , rel_humidity(begin)
        , u_motor_supply(begin)
        , i_motor_supply(begin)
        , mirror_speed(begin)
        , acc_min(begin)
        , acc_max(begin)
        , angle_axis_0(begin)
        , angle_axis_1(begin)
        , t_axis_0(begin)
        , t_axis_1(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 123, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 544};
    it begin() const { return t_instrument.begin(); }
    it end() const { return t_axis_1.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float t_instrument;//!<  instrument temperature					[C] 
    #else
    binary::field<float, sc_float32, 0, it> t_instrument;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float u_supply;//!<  input supply voltage  					[V] 
    #else
    binary::field<float, sc_float32, 32, it> u_supply;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float i_supply;//!<  input supply current					[A] 
    #else
    binary::field<float, sc_float32, 64, it> i_supply;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t status;//!<  status  B0: lan link detect  B1: laser on  B2: measurement active  B3: scan active 
    #else
    binary::field<uint32_t, sc_uint32, 96, it> status;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t optime_instrument;//!<  total instrument on time					[s] 
    #else
    binary::field<uint32_t, sc_uint32, 128, it> optime_instrument;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t optime_laser;//!<  total laser on time						[s] 
    #else
    binary::field<uint32_t, sc_uint32, 160, it> optime_laser;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t optime_line_motor;//!<  total line motor on time					[s] 
    #else
    binary::field<uint32_t, sc_uint32, 192, it> optime_line_motor;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rel_humidity;//!<  relative humidity						[%] 
    #else
    binary::field<float, sc_float32, 224, it> rel_humidity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float u_motor_supply;//!<  motor supply voltage  					[V] 
    #else
    binary::field<float, sc_float32, 256, it> u_motor_supply;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float i_motor_supply;//!<  motor supply current					[A] 
    #else
    binary::field<float, sc_float32, 288, it> i_motor_supply;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float mirror_speed;//!<  mirror rotation speed					[/s] 
    #else
    binary::field<float, sc_float32, 320, it> mirror_speed;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float acc_min;//!<  min. acceleration within last second			[g] 
    #else
    binary::field<float, sc_float32, 352, it> acc_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float acc_max;//!<  max. acceleration within last second			[g] 
    #else
    binary::field<float, sc_float32, 384, it> acc_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float angle_axis_0;//!<  inclination angle of first axis				[] 
    #else
    binary::field<float, sc_float32, 416, it> angle_axis_0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float angle_axis_1;//!<  inclination angle of second axis			[] 
    #else
    binary::field<float, sc_float32, 448, it> angle_axis_1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float t_axis_0;//!<  inclination sensor temperature of first axis	[C] 
    #else
    binary::field<float, sc_float32, 480, it> t_axis_0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float t_axis_1;//!<  inclination sensor temperature of second axis	[C] 
    #else
    binary::field<float, sc_float32, 512, it> t_axis_1;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_monitor& operator=(const hk_monitor<ito>& o) {
        t_instrument = o.t_instrument;
        u_supply = o.u_supply;
        i_supply = o.i_supply;
        status = o.status;
        optime_instrument = o.optime_instrument;
        optime_laser = o.optime_laser;
        optime_line_motor = o.optime_line_motor;
        rel_humidity = o.rel_humidity;
        u_motor_supply = o.u_motor_supply;
        i_motor_supply = o.i_motor_supply;
        mirror_speed = o.mirror_speed;
        acc_min = o.acc_min;
        acc_max = o.acc_max;
        angle_axis_0 = o.angle_axis_0;
        angle_axis_1 = o.angle_axis_1;
        t_axis_0 = o.t_axis_0;
        t_axis_1 = o.t_axis_1;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_monitor<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_monitor<rebind_it> type;
    };

    enum { id_main = 123, id_sub = 0};

    float            t_instrument;
    float            u_supply;
    float            i_supply;
    uint32_t         status;
    uint32_t         optime_instrument;
    uint32_t         optime_laser;
    uint32_t         optime_line_motor;
    float            rel_humidity;
    float            u_motor_supply;
    float            i_motor_supply;
    float            mirror_speed;
    float            acc_min;
    float            acc_max;
    float            angle_axis_0;
    float            angle_axis_1;
    float            t_axis_0;
    float            t_axis_1;

    hk_monitor()
        : t_instrument()
        , u_supply()
        , i_supply()
        , status()
        , optime_instrument()
        , optime_laser()
        , optime_line_motor()
        , rel_humidity()
        , u_motor_supply()
        , i_motor_supply()
        , mirror_speed()
        , acc_min()
        , acc_max()
        , angle_axis_0()
        , angle_axis_1()
        , t_axis_0()
        , t_axis_1()
    {}

    template<class it>
    hk_monitor(const hk_monitor<it>& o) {
        t_instrument = o.t_instrument;
        u_supply = o.u_supply;
        i_supply = o.i_supply;
        status = o.status;
        optime_instrument = o.optime_instrument;
        optime_laser = o.optime_laser;
        optime_line_motor = o.optime_line_motor;
        rel_humidity = o.rel_humidity;
        u_motor_supply = o.u_motor_supply;
        i_motor_supply = o.i_motor_supply;
        mirror_speed = o.mirror_speed;
        acc_min = o.acc_min;
        acc_max = o.acc_max;
        angle_axis_0 = o.angle_axis_0;
        angle_axis_1 = o.angle_axis_1;
        t_axis_0 = o.t_axis_0;
        t_axis_1 = o.t_axis_1;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_monitor<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.t_instrument;
        s << ", " << x.u_supply;
        s << ", " << x.i_supply;
        s << ", " << x.status;
        s << ", " << x.optime_instrument;
        s << ", " << x.optime_laser;
        s << ", " << x.optime_line_motor;
        s << ", " << x.rel_humidity;
        s << ", " << x.u_motor_supply;
        s << ", " << x.i_motor_supply;
        s << ", " << x.mirror_speed;
        s << ", " << x.acc_min;
        s << ", " << x.acc_max;
        s << ", " << x.angle_axis_0;
        s << ", " << x.angle_axis_1;
        s << ", " << x.t_axis_0;
        s << ", " << x.t_axis_1;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_monitor<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.t_instrument;
        s >> ',' >> x.u_supply;
        s >> ',' >> x.i_supply;
        s >> ',' >> x.status;
        s >> ',' >> x.optime_instrument;
        s >> ',' >> x.optime_laser;
        s >> ',' >> x.optime_line_motor;
        s >> ',' >> x.rel_humidity;
        s >> ',' >> x.u_motor_supply;
        s >> ',' >> x.i_motor_supply;
        s >> ',' >> x.mirror_speed;
        s >> ',' >> x.acc_min;
        s >> ',' >> x.acc_max;
        s >> ',' >> x.angle_axis_0;
        s >> ',' >> x.angle_axis_1;
        s >> ',' >> x.t_axis_0;
        s >> ',' >> x.t_axis_1;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_param_header
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_param_header<rebind_it> type;
    };

    typedef it iterator_type;

    hk_param_header(it begin, it end, bool dirty=false)
        : group_id(begin)
        , param_id(begin)
        , unit(begin)
        , name(begin)
        , desc(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10017, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1048};
    it begin() const { return group_id.begin(); }
    it end() const { return desc.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t group_id;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> group_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t param_id;
    #else
    binary::field<uint16_t, sc_uint16, 8, it> param_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t unit[32];
    #else
    binary::array<uint8_t, 32, sc_uint8, 24, it> unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t name[32];
    #else
    binary::array<uint8_t, 32, sc_uint8, 280, it> name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t desc[64];
    #else
    binary::array<uint8_t, 64, sc_uint8, 536, it> desc;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_param_header& operator=(const hk_param_header<ito>& o) {
        group_id = o.group_id;
        param_id = o.param_id;
        for(unsigned n=0; n<32; ++n) unit[n] = o.unit[n];
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        for(unsigned n=0; n<64; ++n) desc[n] = o.desc[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_param_header<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_param_header<rebind_it> type;
    };

    enum { id_main = 10017, id_sub = 0};

    uint8_t          group_id;
    uint16_t         param_id;
    uint8_t          unit[32];
    uint8_t          name[32];
    uint8_t          desc[64];

    hk_param_header()
        : group_id()
        , param_id()
        , unit()
        , name()
        , desc()
    {}

    template<class it>
    hk_param_header(const hk_param_header<it>& o) {
        group_id = o.group_id;
        param_id = o.param_id;
        for(unsigned n=0; n<32; ++n) unit[n] = o.unit[n];
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        for(unsigned n=0; n<64; ++n) desc[n] = o.desc[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_param_header<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.group_id;
        s << ", " << x.param_id;
        s << ", "; write_array(s, 32, x.unit);
        s << ", "; write_array(s, 32, x.name);
        s << ", "; write_array(s, 64, x.desc);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_param_header<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.group_id;
        s >> ',' >> x.param_id;
        s >> ','; read_array(s, 32, x.unit);
        s >> ','; read_array(s, 32, x.name);
        s >> ','; read_array(s, 64, x.desc);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_param_header_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_param_header_1<rebind_it> type;
    };

    typedef it iterator_type;

    hk_param_header_1(it begin, it end, bool dirty=false)
        : group_id(begin)
        , param_id(begin)
        , unit(begin)
        , name(begin)
        , desc(begin)
        , type(begin)
        , min_string(begin)
        , max_string(begin)
        , resol_string(begin)
        , inval_string(begin)
        , instance(begin)
        , instance_string(begin)
        , ref_param_id(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10017, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 2040};
    it begin() const { return group_id.begin(); }
    it end() const { return ref_param_id.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t group_id;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> group_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t param_id;
    #else
    binary::field<uint16_t, sc_uint16, 8, it> param_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t unit[32];
    #else
    binary::array<uint8_t, 32, sc_uint8, 24, it> unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t name[32];
    #else
    binary::array<uint8_t, 32, sc_uint8, 280, it> name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t desc[64];
    #else
    binary::array<uint8_t, 64, sc_uint8, 536, it> desc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t type;
    #else
    binary::field<uint8_t, sc_uint8, 1048, it> type;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t min_string[24];
    #else
    binary::array<uint8_t, 24, sc_uint8, 1056, it> min_string;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t max_string[24];
    #else
    binary::array<uint8_t, 24, sc_uint8, 1248, it> max_string;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t resol_string[24];
    #else
    binary::array<uint8_t, 24, sc_uint8, 1440, it> resol_string;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t inval_string[24];
    #else
    binary::array<uint8_t, 24, sc_uint8, 1632, it> inval_string;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t instance;
    #else
    binary::field<uint8_t, sc_uint8, 1824, it> instance;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t instance_string[24];
    #else
    binary::array<uint8_t, 24, sc_uint8, 1832, it> instance_string;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ref_param_id;
    #else
    binary::field<uint16_t, sc_uint16, 2024, it> ref_param_id;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_param_header_1& operator=(const hk_param_header_1<ito>& o) {
        group_id = o.group_id;
        param_id = o.param_id;
        for(unsigned n=0; n<32; ++n) unit[n] = o.unit[n];
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        for(unsigned n=0; n<64; ++n) desc[n] = o.desc[n];
        type = o.type;
        for(unsigned n=0; n<24; ++n) min_string[n] = o.min_string[n];
        for(unsigned n=0; n<24; ++n) max_string[n] = o.max_string[n];
        for(unsigned n=0; n<24; ++n) resol_string[n] = o.resol_string[n];
        for(unsigned n=0; n<24; ++n) inval_string[n] = o.inval_string[n];
        instance = o.instance;
        for(unsigned n=0; n<24; ++n) instance_string[n] = o.instance_string[n];
        ref_param_id = o.ref_param_id;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_param_header_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_param_header_1<rebind_it> type;
    };

    enum { id_main = 10017, id_sub = 1};

    uint8_t          group_id;
    uint16_t         param_id;
    uint8_t          unit[32];
    uint8_t          name[32];
    uint8_t          desc[64];
    uint8_t          type;
    uint8_t          min_string[24];
    uint8_t          max_string[24];
    uint8_t          resol_string[24];
    uint8_t          inval_string[24];
    uint8_t          instance;
    uint8_t          instance_string[24];
    uint16_t         ref_param_id;

    hk_param_header_1()
        : group_id()
        , param_id()
        , unit()
        , name()
        , desc()
        , type()
        , min_string()
        , max_string()
        , resol_string()
        , inval_string()
        , instance()
        , instance_string()
        , ref_param_id()
    {}

    template<class it>
    hk_param_header_1(const hk_param_header_1<it>& o) {
        group_id = o.group_id;
        param_id = o.param_id;
        for(unsigned n=0; n<32; ++n) unit[n] = o.unit[n];
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        for(unsigned n=0; n<64; ++n) desc[n] = o.desc[n];
        type = o.type;
        for(unsigned n=0; n<24; ++n) min_string[n] = o.min_string[n];
        for(unsigned n=0; n<24; ++n) max_string[n] = o.max_string[n];
        for(unsigned n=0; n<24; ++n) resol_string[n] = o.resol_string[n];
        for(unsigned n=0; n<24; ++n) inval_string[n] = o.inval_string[n];
        instance = o.instance;
        for(unsigned n=0; n<24; ++n) instance_string[n] = o.instance_string[n];
        ref_param_id = o.ref_param_id;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_param_header_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.group_id;
        s << ", " << x.param_id;
        s << ", "; write_array(s, 32, x.unit);
        s << ", "; write_array(s, 32, x.name);
        s << ", "; write_array(s, 64, x.desc);
        s << ", " << x.type;
        s << ", "; write_array(s, 24, x.min_string);
        s << ", "; write_array(s, 24, x.max_string);
        s << ", "; write_array(s, 24, x.resol_string);
        s << ", "; write_array(s, 24, x.inval_string);
        s << ", " << x.instance;
        s << ", "; write_array(s, 24, x.instance_string);
        s << ", " << x.ref_param_id;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_param_header_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.group_id;
        s >> ',' >> x.param_id;
        s >> ','; read_array(s, 32, x.unit);
        s >> ','; read_array(s, 32, x.name);
        s >> ','; read_array(s, 64, x.desc);
        s >> ',' >> x.type;
        s >> ','; read_array(s, 24, x.min_string);
        s >> ','; read_array(s, 24, x.max_string);
        s >> ','; read_array(s, 24, x.resol_string);
        s >> ','; read_array(s, 24, x.inval_string);
        s >> ',' >> x.instance;
        s >> ','; read_array(s, 24, x.instance_string);
        s >> ',' >> x.ref_param_id;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! protective housing data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_ph_data
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ph_data<rebind_it> type;
    };

    typedef it iterator_type;

    hk_ph_data(it begin, it end, bool dirty=false)
        : Version_Major(begin)
        , Version_Minor(begin)
        , Version_Bugfix(begin)
        , Version_Build(begin)
        , Date_Year(begin)
        , Date_Month(begin)
        , Date_Day(begin)
        , Time_Seconds(begin)
        , Time_Minutes(begin)
        , Time_Hours(begin)
        , systime(begin)
        , OnTime(begin)
        , pwr_24V(begin)
        , pwr_I_24V(begin)
        , pwr_P_24V(begin)
        , pwr_U_TECp(begin)
        , pwr_U_TECm(begin)
        , uc_24V(begin)
        , uc_P_24V(begin)
        , uc_I_24V(begin)
        , uc_12V(begin)
        , uc_5V(begin)
        , uc_3V3(begin)
        , uc_Proc_T(begin)
        , uc_Temp(begin)
        , uc_RH(begin)
        , uc_TD(begin)
        , uc_TDq(begin)
        , uc_Tsoll(begin)
        , uc_I_FAN_C1(begin)
        , uc_I_FAN_C2(begin)
        , uc_I_FAN_TI(begin)
        , uc_I_FAN_TO(begin)
        , uc_FAN_SPEED(begin)
        , uc_PWM_F(begin)
        , uc_DCCq(begin)
        , uc_DCHq(begin)
        , uc_DACValue(begin)
        , uc_Status(begin)
        , uc_Error(begin)
        , Reserved0(begin)
        , Reserved1(begin)
        , Reserved2(begin)
        , Reserved3(begin)
        , Reserved4(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10014, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 904};
    it begin() const { return Version_Major.begin(); }
    it end() const { return Reserved4.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Version_Major;//!<  major version ID of protective housing firmware 
    #else
    binary::field<uint16_t, sc_uint16, 0, it> Version_Major;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Version_Minor;//!<  minor version ID of protective housing firmware 
    #else
    binary::field<uint16_t, sc_uint16, 16, it> Version_Minor;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Version_Bugfix;//!<  bugfix ID of protective housing firmware 
    #else
    binary::field<uint16_t, sc_uint16, 32, it> Version_Bugfix;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Version_Build;//!<  build ID of protective housing firmware 
    #else
    binary::field<uint16_t, sc_uint16, 48, it> Version_Build;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Date_Year;//!<  Year of protective housing internal RTC 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> Date_Year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Date_Month;//!<  Month of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 80, it> Date_Month;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Date_Day;//!<  Day of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 88, it> Date_Day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Time_Seconds;//!<  Seconds of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 96, it> Time_Seconds;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Time_Minutes;//!<  Minutes of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 104, it> Time_Minutes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Time_Hours;//!<  Hours of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 112, it> Time_Hours;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  [systime] = hk_ph_units.systime 
    #else
    binary::field<uint32_t, sc_uint32, 120, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t OnTime[2];//!<  OnTime[0]: time since power up in seconds  OnTime[1]: total operating time in seconds 
    #else
    binary::array<uint32_t, 2, sc_uint32, 152, it> OnTime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pwr_24V;//!<  [pwr_24V]    = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 216, it> pwr_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pwr_I_24V;//!<  [pwr_I_24V]  = hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 232, it> pwr_I_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t pwr_P_24V;//!<  [pwr_P_24V]  = hk_ph_units.power 
    #else
    binary::field<uint32_t, sc_uint32, 248, it> pwr_P_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pwr_U_TECp;//!<  [pwr_U_TECp] = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 280, it> pwr_U_TECp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pwr_U_TECm;//!<  [pwr_U_TECm] = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 296, it> pwr_U_TECm;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_24V;//!<  [uc_24V]     = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 312, it> uc_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_P_24V;//!<  [uc_P_24V]   = hk_ph_units.power 
    #else
    binary::field<uint16_t, sc_uint16, 328, it> uc_P_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_24V;//!<  [pwr_I_24V]  = hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 344, it> uc_I_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_12V;//!<  [uc_12V]     = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 360, it> uc_12V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_5V;//!<  [uc_5V]      = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 376, it> uc_5V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_3V3;//!<  [uc_3V3]     = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 392, it> uc_3V3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Proc_T;//!<  [uc_Proc_T]  = hk_ph_units.temp 
    #else
    binary::field<int16_t, sc_int16, 408, it> uc_Proc_T;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Temp;//!<  [uc_Temp]    = hk_ph_units.temp 
    #else
    binary::field<int16_t, sc_int16, 424, it> uc_Temp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_RH;//!<  [uc_RH]      = hk_ph_units.rh 
    #else
    binary::field<uint16_t, sc_uint16, 440, it> uc_RH;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_TD[8];//!<  [uc_TD[n]]   = hk_ph_units.temp 
    #else
    binary::array<int16_t, 8, sc_int16, 456, it> uc_TD;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_TDq;//!<  [uc_TDq]     = hk_ph_units.temp 
    #else
    binary::field<int16_t, sc_int16, 584, it> uc_TDq;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Tsoll;//!<  [uc_Tsoll]   = hk_ph_units.temp 
    #else
    binary::field<int16_t, sc_int16, 600, it> uc_Tsoll;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_FAN_C1;//!<  [uc_I_FAN_C1]= hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 616, it> uc_I_FAN_C1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_FAN_C2;//!<  [uc_I_FAN_C1]= hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 632, it> uc_I_FAN_C2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_FAN_TI;//!<  [uc_I_FAN_TI]= hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 648, it> uc_I_FAN_TI;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_FAN_TO;//!<  [uc_I_FAN_TO]= hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 664, it> uc_I_FAN_TO;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_FAN_SPEED[2];//!<  [uc_FAN_SPEED[n]] = RPM 
    #else
    binary::array<uint16_t, 2, sc_uint16, 680, it> uc_FAN_SPEED;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t uc_PWM_F;//!<  [uc_PWM_F]   = Hz 
    #else
    binary::field<uint32_t, sc_uint32, 712, it> uc_PWM_F;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t uc_DCCq;//!<  [uc_DCCq]    = hk_ph_units.dc 
    #else
    binary::field<uint8_t, sc_uint8, 744, it> uc_DCCq;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t uc_DCHq;//!<  [uc_DCHq]    = hk_ph_units.dc 
    #else
    binary::field<uint8_t, sc_uint8, 752, it> uc_DCHq;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_DACValue;//!<  [uc_DACValue]= 1 
    #else
    binary::field<uint16_t, sc_uint16, 760, it> uc_DACValue;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_Status;//!<  Statusinformationen 2 Oktetts 
    #else
    binary::field<uint16_t, sc_uint16, 776, it> uc_Status;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t uc_Error;//!<  Errorinformationen  4 Oktetts 
    #else
    binary::field<uint32_t, sc_uint32, 792, it> uc_Error;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved0;
    #else
    binary::field<uint16_t, sc_uint16, 824, it> Reserved0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved1;
    #else
    binary::field<uint16_t, sc_uint16, 840, it> Reserved1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved2;
    #else
    binary::field<uint16_t, sc_uint16, 856, it> Reserved2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved3;
    #else
    binary::field<uint16_t, sc_uint16, 872, it> Reserved3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved4;
    #else
    binary::field<uint16_t, sc_uint16, 888, it> Reserved4;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_ph_data& operator=(const hk_ph_data<ito>& o) {
        Version_Major = o.Version_Major;
        Version_Minor = o.Version_Minor;
        Version_Bugfix = o.Version_Bugfix;
        Version_Build = o.Version_Build;
        Date_Year = o.Date_Year;
        Date_Month = o.Date_Month;
        Date_Day = o.Date_Day;
        Time_Seconds = o.Time_Seconds;
        Time_Minutes = o.Time_Minutes;
        Time_Hours = o.Time_Hours;
        systime = o.systime;
        for(unsigned n=0; n<2; ++n) OnTime[n] = o.OnTime[n];
        pwr_24V = o.pwr_24V;
        pwr_I_24V = o.pwr_I_24V;
        pwr_P_24V = o.pwr_P_24V;
        pwr_U_TECp = o.pwr_U_TECp;
        pwr_U_TECm = o.pwr_U_TECm;
        uc_24V = o.uc_24V;
        uc_P_24V = o.uc_P_24V;
        uc_I_24V = o.uc_I_24V;
        uc_12V = o.uc_12V;
        uc_5V = o.uc_5V;
        uc_3V3 = o.uc_3V3;
        uc_Proc_T = o.uc_Proc_T;
        uc_Temp = o.uc_Temp;
        uc_RH = o.uc_RH;
        for(unsigned n=0; n<8; ++n) uc_TD[n] = o.uc_TD[n];
        uc_TDq = o.uc_TDq;
        uc_Tsoll = o.uc_Tsoll;
        uc_I_FAN_C1 = o.uc_I_FAN_C1;
        uc_I_FAN_C2 = o.uc_I_FAN_C2;
        uc_I_FAN_TI = o.uc_I_FAN_TI;
        uc_I_FAN_TO = o.uc_I_FAN_TO;
        for(unsigned n=0; n<2; ++n) uc_FAN_SPEED[n] = o.uc_FAN_SPEED[n];
        uc_PWM_F = o.uc_PWM_F;
        uc_DCCq = o.uc_DCCq;
        uc_DCHq = o.uc_DCHq;
        uc_DACValue = o.uc_DACValue;
        uc_Status = o.uc_Status;
        uc_Error = o.uc_Error;
        Reserved0 = o.Reserved0;
        Reserved1 = o.Reserved1;
        Reserved2 = o.Reserved2;
        Reserved3 = o.Reserved3;
        Reserved4 = o.Reserved4;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_ph_data<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ph_data<rebind_it> type;
    };

    enum { id_main = 10014, id_sub = 0};

    uint16_t         Version_Major;
    uint16_t         Version_Minor;
    uint16_t         Version_Bugfix;
    uint16_t         Version_Build;
    uint16_t         Date_Year;
    uint8_t          Date_Month;
    uint8_t          Date_Day;
    uint8_t          Time_Seconds;
    uint8_t          Time_Minutes;
    uint8_t          Time_Hours;
    uint32_t         systime;
    uint32_t         OnTime[2];
    uint16_t         pwr_24V;
    uint16_t         pwr_I_24V;
    uint32_t         pwr_P_24V;
    uint16_t         pwr_U_TECp;
    uint16_t         pwr_U_TECm;
    uint16_t         uc_24V;
    uint16_t         uc_P_24V;
    uint16_t         uc_I_24V;
    uint16_t         uc_12V;
    uint16_t         uc_5V;
    uint16_t         uc_3V3;
    int16_t          uc_Proc_T;
    int16_t          uc_Temp;
    uint16_t         uc_RH;
    int16_t          uc_TD[8];
    int16_t          uc_TDq;
    int16_t          uc_Tsoll;
    uint16_t         uc_I_FAN_C1;
    uint16_t         uc_I_FAN_C2;
    uint16_t         uc_I_FAN_TI;
    uint16_t         uc_I_FAN_TO;
    uint16_t         uc_FAN_SPEED[2];
    uint32_t         uc_PWM_F;
    uint8_t          uc_DCCq;
    uint8_t          uc_DCHq;
    uint16_t         uc_DACValue;
    uint16_t         uc_Status;
    uint32_t         uc_Error;
    uint16_t         Reserved0;
    uint16_t         Reserved1;
    uint16_t         Reserved2;
    uint16_t         Reserved3;
    uint16_t         Reserved4;

    hk_ph_data()
        : Version_Major()
        , Version_Minor()
        , Version_Bugfix()
        , Version_Build()
        , Date_Year()
        , Date_Month()
        , Date_Day()
        , Time_Seconds()
        , Time_Minutes()
        , Time_Hours()
        , systime()
        , OnTime()
        , pwr_24V()
        , pwr_I_24V()
        , pwr_P_24V()
        , pwr_U_TECp()
        , pwr_U_TECm()
        , uc_24V()
        , uc_P_24V()
        , uc_I_24V()
        , uc_12V()
        , uc_5V()
        , uc_3V3()
        , uc_Proc_T()
        , uc_Temp()
        , uc_RH()
        , uc_TD()
        , uc_TDq()
        , uc_Tsoll()
        , uc_I_FAN_C1()
        , uc_I_FAN_C2()
        , uc_I_FAN_TI()
        , uc_I_FAN_TO()
        , uc_FAN_SPEED()
        , uc_PWM_F()
        , uc_DCCq()
        , uc_DCHq()
        , uc_DACValue()
        , uc_Status()
        , uc_Error()
        , Reserved0()
        , Reserved1()
        , Reserved2()
        , Reserved3()
        , Reserved4()
    {}

    template<class it>
    hk_ph_data(const hk_ph_data<it>& o) {
        Version_Major = o.Version_Major;
        Version_Minor = o.Version_Minor;
        Version_Bugfix = o.Version_Bugfix;
        Version_Build = o.Version_Build;
        Date_Year = o.Date_Year;
        Date_Month = o.Date_Month;
        Date_Day = o.Date_Day;
        Time_Seconds = o.Time_Seconds;
        Time_Minutes = o.Time_Minutes;
        Time_Hours = o.Time_Hours;
        systime = o.systime;
        for(unsigned n=0; n<2; ++n) OnTime[n] = o.OnTime[n];
        pwr_24V = o.pwr_24V;
        pwr_I_24V = o.pwr_I_24V;
        pwr_P_24V = o.pwr_P_24V;
        pwr_U_TECp = o.pwr_U_TECp;
        pwr_U_TECm = o.pwr_U_TECm;
        uc_24V = o.uc_24V;
        uc_P_24V = o.uc_P_24V;
        uc_I_24V = o.uc_I_24V;
        uc_12V = o.uc_12V;
        uc_5V = o.uc_5V;
        uc_3V3 = o.uc_3V3;
        uc_Proc_T = o.uc_Proc_T;
        uc_Temp = o.uc_Temp;
        uc_RH = o.uc_RH;
        for(unsigned n=0; n<8; ++n) uc_TD[n] = o.uc_TD[n];
        uc_TDq = o.uc_TDq;
        uc_Tsoll = o.uc_Tsoll;
        uc_I_FAN_C1 = o.uc_I_FAN_C1;
        uc_I_FAN_C2 = o.uc_I_FAN_C2;
        uc_I_FAN_TI = o.uc_I_FAN_TI;
        uc_I_FAN_TO = o.uc_I_FAN_TO;
        for(unsigned n=0; n<2; ++n) uc_FAN_SPEED[n] = o.uc_FAN_SPEED[n];
        uc_PWM_F = o.uc_PWM_F;
        uc_DCCq = o.uc_DCCq;
        uc_DCHq = o.uc_DCHq;
        uc_DACValue = o.uc_DACValue;
        uc_Status = o.uc_Status;
        uc_Error = o.uc_Error;
        Reserved0 = o.Reserved0;
        Reserved1 = o.Reserved1;
        Reserved2 = o.Reserved2;
        Reserved3 = o.Reserved3;
        Reserved4 = o.Reserved4;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_ph_data<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.Version_Major;
        s << ", " << x.Version_Minor;
        s << ", " << x.Version_Bugfix;
        s << ", " << x.Version_Build;
        s << ", " << x.Date_Year;
        s << ", " << x.Date_Month;
        s << ", " << x.Date_Day;
        s << ", " << x.Time_Seconds;
        s << ", " << x.Time_Minutes;
        s << ", " << x.Time_Hours;
        s << ", " << x.systime;
        s << ", "; write_array(s, 2, x.OnTime);
        s << ", " << x.pwr_24V;
        s << ", " << x.pwr_I_24V;
        s << ", " << x.pwr_P_24V;
        s << ", " << x.pwr_U_TECp;
        s << ", " << x.pwr_U_TECm;
        s << ", " << x.uc_24V;
        s << ", " << x.uc_P_24V;
        s << ", " << x.uc_I_24V;
        s << ", " << x.uc_12V;
        s << ", " << x.uc_5V;
        s << ", " << x.uc_3V3;
        s << ", " << x.uc_Proc_T;
        s << ", " << x.uc_Temp;
        s << ", " << x.uc_RH;
        s << ", "; write_array(s, 8, x.uc_TD);
        s << ", " << x.uc_TDq;
        s << ", " << x.uc_Tsoll;
        s << ", " << x.uc_I_FAN_C1;
        s << ", " << x.uc_I_FAN_C2;
        s << ", " << x.uc_I_FAN_TI;
        s << ", " << x.uc_I_FAN_TO;
        s << ", "; write_array(s, 2, x.uc_FAN_SPEED);
        s << ", " << x.uc_PWM_F;
        s << ", " << x.uc_DCCq;
        s << ", " << x.uc_DCHq;
        s << ", " << x.uc_DACValue;
        s << ", " << x.uc_Status;
        s << ", " << x.uc_Error;
        s << ", " << x.Reserved0;
        s << ", " << x.Reserved1;
        s << ", " << x.Reserved2;
        s << ", " << x.Reserved3;
        s << ", " << x.Reserved4;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_ph_data<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.Version_Major;
        s >> ',' >> x.Version_Minor;
        s >> ',' >> x.Version_Bugfix;
        s >> ',' >> x.Version_Build;
        s >> ',' >> x.Date_Year;
        s >> ',' >> x.Date_Month;
        s >> ',' >> x.Date_Day;
        s >> ',' >> x.Time_Seconds;
        s >> ',' >> x.Time_Minutes;
        s >> ',' >> x.Time_Hours;
        s >> ',' >> x.systime;
        s >> ','; read_array(s, 2, x.OnTime);
        s >> ',' >> x.pwr_24V;
        s >> ',' >> x.pwr_I_24V;
        s >> ',' >> x.pwr_P_24V;
        s >> ',' >> x.pwr_U_TECp;
        s >> ',' >> x.pwr_U_TECm;
        s >> ',' >> x.uc_24V;
        s >> ',' >> x.uc_P_24V;
        s >> ',' >> x.uc_I_24V;
        s >> ',' >> x.uc_12V;
        s >> ',' >> x.uc_5V;
        s >> ',' >> x.uc_3V3;
        s >> ',' >> x.uc_Proc_T;
        s >> ',' >> x.uc_Temp;
        s >> ',' >> x.uc_RH;
        s >> ','; read_array(s, 8, x.uc_TD);
        s >> ',' >> x.uc_TDq;
        s >> ',' >> x.uc_Tsoll;
        s >> ',' >> x.uc_I_FAN_C1;
        s >> ',' >> x.uc_I_FAN_C2;
        s >> ',' >> x.uc_I_FAN_TI;
        s >> ',' >> x.uc_I_FAN_TO;
        s >> ','; read_array(s, 2, x.uc_FAN_SPEED);
        s >> ',' >> x.uc_PWM_F;
        s >> ',' >> x.uc_DCCq;
        s >> ',' >> x.uc_DCHq;
        s >> ',' >> x.uc_DACValue;
        s >> ',' >> x.uc_Status;
        s >> ',' >> x.uc_Error;
        s >> ',' >> x.Reserved0;
        s >> ',' >> x.Reserved1;
        s >> ',' >> x.Reserved2;
        s >> ',' >> x.Reserved3;
        s >> ',' >> x.Reserved4;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! protective housing data

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_ph_data_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ph_data_1<rebind_it> type;
    };

    typedef it iterator_type;

    hk_ph_data_1(it begin, it end, bool dirty=false)
        : Version_Major(begin)
        , Version_Minor(begin)
        , Version_Bugfix(begin)
        , Version_Build(begin)
        , Date_Year(begin)
        , Date_Month(begin)
        , Date_Day(begin)
        , Time_Seconds(begin)
        , Time_Minutes(begin)
        , Time_Hours(begin)
        , systime(begin)
        , OnTime(begin)
        , pwr_24V(begin)
        , pwr_I_24V(begin)
        , pwr_P_24V(begin)
        , pwr_U_TECp(begin)
        , pwr_U_TECm(begin)
        , uc_24V(begin)
        , uc_P_24V(begin)
        , uc_I_24V(begin)
        , uc_12V(begin)
        , uc_5V(begin)
        , uc_3V3(begin)
        , uc_Proc_T(begin)
        , uc_Temp(begin)
        , uc_RH(begin)
        , uc_TD(begin)
        , uc_TDq(begin)
        , uc_Tsoll(begin)
        , uc_I_FAN_C1(begin)
        , uc_I_FAN_C2(begin)
        , uc_I_FAN_TI(begin)
        , uc_I_FAN_TO(begin)
        , uc_FAN_SPEED(begin)
        , uc_PWM_F(begin)
        , uc_DCCq(begin)
        , uc_DCHq(begin)
        , uc_DACValue(begin)
        , uc_Status(begin)
        , uc_Error(begin)
        , Reserved0(begin)
        , Reserved1(begin)
        , Reserved2(begin)
        , Reserved3(begin)
        , Reserved4(begin)
        , uc_Accl_X_mean(begin)
        , uc_Accl_X_min(begin)
        , uc_Accl_X_max(begin)
        , uc_Accl_X_cnt(begin)
        , uc_Accl_Y_mean(begin)
        , uc_Accl_Y_min(begin)
        , uc_Accl_Y_max(begin)
        , uc_Accl_Y_cnt(begin)
        , uc_Accl_Z_mean(begin)
        , uc_Accl_Z_min(begin)
        , uc_Accl_Z_max(begin)
        , uc_Accl_Z_cnt(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10014, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 1096};
    it begin() const { return Version_Major.begin(); }
    it end() const { return uc_Accl_Z_cnt.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Version_Major;//!<  major version ID of protective housing firmware 
    #else
    binary::field<uint16_t, sc_uint16, 0, it> Version_Major;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Version_Minor;//!<  minor version ID of protective housing firmware 
    #else
    binary::field<uint16_t, sc_uint16, 16, it> Version_Minor;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Version_Bugfix;//!<  bugfix ID of protective housing firmware 
    #else
    binary::field<uint16_t, sc_uint16, 32, it> Version_Bugfix;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Version_Build;//!<  build ID of protective housing firmware 
    #else
    binary::field<uint16_t, sc_uint16, 48, it> Version_Build;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Date_Year;//!<  Year of protective housing internal RTC 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> Date_Year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Date_Month;//!<  Month of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 80, it> Date_Month;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Date_Day;//!<  Day of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 88, it> Date_Day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Time_Seconds;//!<  Seconds of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 96, it> Time_Seconds;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Time_Minutes;//!<  Minutes of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 104, it> Time_Minutes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t Time_Hours;//!<  Hours of protective housing internal RTC 
    #else
    binary::field<uint8_t, sc_uint8, 112, it> Time_Hours;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  [systime] = hk_ph_units.systime 
    #else
    binary::field<uint32_t, sc_uint32, 120, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t OnTime[2];//!<  OnTime[0]: time since power up in seconds  OnTime[1]: total operating time in seconds 
    #else
    binary::array<uint32_t, 2, sc_uint32, 152, it> OnTime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pwr_24V;//!<  [pwr_24V]    = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 216, it> pwr_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pwr_I_24V;//!<  [pwr_I_24V]  = hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 232, it> pwr_I_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t pwr_P_24V;//!<  [pwr_P_24V]  = hk_ph_units.power 
    #else
    binary::field<uint32_t, sc_uint32, 248, it> pwr_P_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pwr_U_TECp;//!<  [pwr_U_TECp] = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 280, it> pwr_U_TECp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pwr_U_TECm;//!<  [pwr_U_TECm] = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 296, it> pwr_U_TECm;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_24V;//!<  [uc_24V]     = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 312, it> uc_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_P_24V;//!<  [uc_P_24V]   = hk_ph_units.power 
    #else
    binary::field<uint16_t, sc_uint16, 328, it> uc_P_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_24V;//!<  [pwr_I_24V]  = hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 344, it> uc_I_24V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_12V;//!<  [uc_12V]     = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 360, it> uc_12V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_5V;//!<  [uc_5V]      = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 376, it> uc_5V;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_3V3;//!<  [uc_3V3]     = hk_ph_units.voltage 
    #else
    binary::field<uint16_t, sc_uint16, 392, it> uc_3V3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Proc_T;//!<  [uc_Proc_T]  = hk_ph_units.temp 
    #else
    binary::field<int16_t, sc_int16, 408, it> uc_Proc_T;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Temp;//!<  [uc_Temp]    = hk_ph_units.temp 
    #else
    binary::field<int16_t, sc_int16, 424, it> uc_Temp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_RH;//!<  [uc_RH]      = hk_ph_units.rh 
    #else
    binary::field<uint16_t, sc_uint16, 440, it> uc_RH;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_TD[8];//!<  [uc_TD[n]]   = hk_ph_units.temp 
    #else
    binary::array<int16_t, 8, sc_int16, 456, it> uc_TD;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_TDq;//!<  [uc_TDq]     = hk_ph_units.temp 
    #else
    binary::field<int16_t, sc_int16, 584, it> uc_TDq;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Tsoll;//!<  [uc_Tsoll]   = hk_ph_units.temp 
    #else
    binary::field<int16_t, sc_int16, 600, it> uc_Tsoll;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_FAN_C1;//!<  [uc_I_FAN_C1]= hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 616, it> uc_I_FAN_C1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_FAN_C2;//!<  [uc_I_FAN_C1]= hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 632, it> uc_I_FAN_C2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_FAN_TI;//!<  [uc_I_FAN_TI]= hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 648, it> uc_I_FAN_TI;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_I_FAN_TO;//!<  [uc_I_FAN_TO]= hk_ph_units.current 
    #else
    binary::field<uint16_t, sc_uint16, 664, it> uc_I_FAN_TO;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_FAN_SPEED[2];//!<  [uc_FAN_SPEED[n]] = RPM 
    #else
    binary::array<uint16_t, 2, sc_uint16, 680, it> uc_FAN_SPEED;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t uc_PWM_F;//!<  [uc_PWM_F]   = Hz 
    #else
    binary::field<uint32_t, sc_uint32, 712, it> uc_PWM_F;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t uc_DCCq;//!<  [uc_DCCq]    = hk_ph_units.dc 
    #else
    binary::field<uint8_t, sc_uint8, 744, it> uc_DCCq;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t uc_DCHq;//!<  [uc_DCHq]    = hk_ph_units.dc 
    #else
    binary::field<uint8_t, sc_uint8, 752, it> uc_DCHq;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_DACValue;//!<  [uc_DACValue]= 1 
    #else
    binary::field<uint16_t, sc_uint16, 760, it> uc_DACValue;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_Status;//!<  Statusinformationen 2 Oktetts 
    #else
    binary::field<uint16_t, sc_uint16, 776, it> uc_Status;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t uc_Error;//!<  Errorinformationen  4 Oktetts 
    #else
    binary::field<uint32_t, sc_uint32, 792, it> uc_Error;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved0;
    #else
    binary::field<uint16_t, sc_uint16, 824, it> Reserved0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved1;
    #else
    binary::field<uint16_t, sc_uint16, 840, it> Reserved1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved2;
    #else
    binary::field<uint16_t, sc_uint16, 856, it> Reserved2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved3;
    #else
    binary::field<uint16_t, sc_uint16, 872, it> Reserved3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t Reserved4;
    #else
    binary::field<uint16_t, sc_uint16, 888, it> Reserved4;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Accl_X_mean;//!<  [uc_Accl_X_mean] = hk_ph_units.accl_unit 
    #else
    binary::field<int16_t, sc_int16, 904, it> uc_Accl_X_mean;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Accl_X_min;//!<  [uc_Accl_X_min]  = hk_ph_units.accl_unit 
    #else
    binary::field<int16_t, sc_int16, 920, it> uc_Accl_X_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Accl_X_max;//!<  [uc_Accl_X_max]  = hk_ph_units.accl_unit 
    #else
    binary::field<int16_t, sc_int16, 936, it> uc_Accl_X_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_Accl_X_cnt;//!<  [uc_Accl_X_cnt]  = 1 
    #else
    binary::field<uint16_t, sc_uint16, 952, it> uc_Accl_X_cnt;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Accl_Y_mean;//!<  [uc_Accl_Y_mean] = hk_ph_units.accl_unit 
    #else
    binary::field<int16_t, sc_int16, 968, it> uc_Accl_Y_mean;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Accl_Y_min;//!<  [uc_Accl_Y_min]  = hk_ph_units.accl_unit 
    #else
    binary::field<int16_t, sc_int16, 984, it> uc_Accl_Y_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Accl_Y_max;//!<  [uc_Accl_Y_max]  = hk_ph_units.accl_unit 
    #else
    binary::field<int16_t, sc_int16, 1000, it> uc_Accl_Y_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_Accl_Y_cnt;//!<  [uc_Accl_X_cnt]  = 1 
    #else
    binary::field<uint16_t, sc_uint16, 1016, it> uc_Accl_Y_cnt;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Accl_Z_mean;//!<  [uc_Accl_Z_mean] = hk_ph_units.accl_unit 
    #else
    binary::field<int16_t, sc_int16, 1032, it> uc_Accl_Z_mean;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Accl_Z_min;//!<  [uc_Accl_Z_min]  = hk_ph_units.accl_unit 
    #else
    binary::field<int16_t, sc_int16, 1048, it> uc_Accl_Z_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t uc_Accl_Z_max;//!<  [uc_Accl_Z_max]  = hk_ph_units.accl_unit 
    #else
    binary::field<int16_t, sc_int16, 1064, it> uc_Accl_Z_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t uc_Accl_Z_cnt;//!<  [uc_Accl_X_cnt]  = 1* 
    #else
    binary::field<uint16_t, sc_uint16, 1080, it> uc_Accl_Z_cnt;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_ph_data_1& operator=(const hk_ph_data_1<ito>& o) {
        Version_Major = o.Version_Major;
        Version_Minor = o.Version_Minor;
        Version_Bugfix = o.Version_Bugfix;
        Version_Build = o.Version_Build;
        Date_Year = o.Date_Year;
        Date_Month = o.Date_Month;
        Date_Day = o.Date_Day;
        Time_Seconds = o.Time_Seconds;
        Time_Minutes = o.Time_Minutes;
        Time_Hours = o.Time_Hours;
        systime = o.systime;
        for(unsigned n=0; n<2; ++n) OnTime[n] = o.OnTime[n];
        pwr_24V = o.pwr_24V;
        pwr_I_24V = o.pwr_I_24V;
        pwr_P_24V = o.pwr_P_24V;
        pwr_U_TECp = o.pwr_U_TECp;
        pwr_U_TECm = o.pwr_U_TECm;
        uc_24V = o.uc_24V;
        uc_P_24V = o.uc_P_24V;
        uc_I_24V = o.uc_I_24V;
        uc_12V = o.uc_12V;
        uc_5V = o.uc_5V;
        uc_3V3 = o.uc_3V3;
        uc_Proc_T = o.uc_Proc_T;
        uc_Temp = o.uc_Temp;
        uc_RH = o.uc_RH;
        for(unsigned n=0; n<8; ++n) uc_TD[n] = o.uc_TD[n];
        uc_TDq = o.uc_TDq;
        uc_Tsoll = o.uc_Tsoll;
        uc_I_FAN_C1 = o.uc_I_FAN_C1;
        uc_I_FAN_C2 = o.uc_I_FAN_C2;
        uc_I_FAN_TI = o.uc_I_FAN_TI;
        uc_I_FAN_TO = o.uc_I_FAN_TO;
        for(unsigned n=0; n<2; ++n) uc_FAN_SPEED[n] = o.uc_FAN_SPEED[n];
        uc_PWM_F = o.uc_PWM_F;
        uc_DCCq = o.uc_DCCq;
        uc_DCHq = o.uc_DCHq;
        uc_DACValue = o.uc_DACValue;
        uc_Status = o.uc_Status;
        uc_Error = o.uc_Error;
        Reserved0 = o.Reserved0;
        Reserved1 = o.Reserved1;
        Reserved2 = o.Reserved2;
        Reserved3 = o.Reserved3;
        Reserved4 = o.Reserved4;
        uc_Accl_X_mean = o.uc_Accl_X_mean;
        uc_Accl_X_min = o.uc_Accl_X_min;
        uc_Accl_X_max = o.uc_Accl_X_max;
        uc_Accl_X_cnt = o.uc_Accl_X_cnt;
        uc_Accl_Y_mean = o.uc_Accl_Y_mean;
        uc_Accl_Y_min = o.uc_Accl_Y_min;
        uc_Accl_Y_max = o.uc_Accl_Y_max;
        uc_Accl_Y_cnt = o.uc_Accl_Y_cnt;
        uc_Accl_Z_mean = o.uc_Accl_Z_mean;
        uc_Accl_Z_min = o.uc_Accl_Z_min;
        uc_Accl_Z_max = o.uc_Accl_Z_max;
        uc_Accl_Z_cnt = o.uc_Accl_Z_cnt;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_ph_data_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ph_data_1<rebind_it> type;
    };

    enum { id_main = 10014, id_sub = 1};

    uint16_t         Version_Major;
    uint16_t         Version_Minor;
    uint16_t         Version_Bugfix;
    uint16_t         Version_Build;
    uint16_t         Date_Year;
    uint8_t          Date_Month;
    uint8_t          Date_Day;
    uint8_t          Time_Seconds;
    uint8_t          Time_Minutes;
    uint8_t          Time_Hours;
    uint32_t         systime;
    uint32_t         OnTime[2];
    uint16_t         pwr_24V;
    uint16_t         pwr_I_24V;
    uint32_t         pwr_P_24V;
    uint16_t         pwr_U_TECp;
    uint16_t         pwr_U_TECm;
    uint16_t         uc_24V;
    uint16_t         uc_P_24V;
    uint16_t         uc_I_24V;
    uint16_t         uc_12V;
    uint16_t         uc_5V;
    uint16_t         uc_3V3;
    int16_t          uc_Proc_T;
    int16_t          uc_Temp;
    uint16_t         uc_RH;
    int16_t          uc_TD[8];
    int16_t          uc_TDq;
    int16_t          uc_Tsoll;
    uint16_t         uc_I_FAN_C1;
    uint16_t         uc_I_FAN_C2;
    uint16_t         uc_I_FAN_TI;
    uint16_t         uc_I_FAN_TO;
    uint16_t         uc_FAN_SPEED[2];
    uint32_t         uc_PWM_F;
    uint8_t          uc_DCCq;
    uint8_t          uc_DCHq;
    uint16_t         uc_DACValue;
    uint16_t         uc_Status;
    uint32_t         uc_Error;
    uint16_t         Reserved0;
    uint16_t         Reserved1;
    uint16_t         Reserved2;
    uint16_t         Reserved3;
    uint16_t         Reserved4;
    int16_t          uc_Accl_X_mean;
    int16_t          uc_Accl_X_min;
    int16_t          uc_Accl_X_max;
    uint16_t         uc_Accl_X_cnt;
    int16_t          uc_Accl_Y_mean;
    int16_t          uc_Accl_Y_min;
    int16_t          uc_Accl_Y_max;
    uint16_t         uc_Accl_Y_cnt;
    int16_t          uc_Accl_Z_mean;
    int16_t          uc_Accl_Z_min;
    int16_t          uc_Accl_Z_max;
    uint16_t         uc_Accl_Z_cnt;

    hk_ph_data_1()
        : Version_Major()
        , Version_Minor()
        , Version_Bugfix()
        , Version_Build()
        , Date_Year()
        , Date_Month()
        , Date_Day()
        , Time_Seconds()
        , Time_Minutes()
        , Time_Hours()
        , systime()
        , OnTime()
        , pwr_24V()
        , pwr_I_24V()
        , pwr_P_24V()
        , pwr_U_TECp()
        , pwr_U_TECm()
        , uc_24V()
        , uc_P_24V()
        , uc_I_24V()
        , uc_12V()
        , uc_5V()
        , uc_3V3()
        , uc_Proc_T()
        , uc_Temp()
        , uc_RH()
        , uc_TD()
        , uc_TDq()
        , uc_Tsoll()
        , uc_I_FAN_C1()
        , uc_I_FAN_C2()
        , uc_I_FAN_TI()
        , uc_I_FAN_TO()
        , uc_FAN_SPEED()
        , uc_PWM_F()
        , uc_DCCq()
        , uc_DCHq()
        , uc_DACValue()
        , uc_Status()
        , uc_Error()
        , Reserved0()
        , Reserved1()
        , Reserved2()
        , Reserved3()
        , Reserved4()
        , uc_Accl_X_mean()
        , uc_Accl_X_min()
        , uc_Accl_X_max()
        , uc_Accl_X_cnt()
        , uc_Accl_Y_mean()
        , uc_Accl_Y_min()
        , uc_Accl_Y_max()
        , uc_Accl_Y_cnt()
        , uc_Accl_Z_mean()
        , uc_Accl_Z_min()
        , uc_Accl_Z_max()
        , uc_Accl_Z_cnt()
    {}

    template<class it>
    hk_ph_data_1(const hk_ph_data_1<it>& o) {
        Version_Major = o.Version_Major;
        Version_Minor = o.Version_Minor;
        Version_Bugfix = o.Version_Bugfix;
        Version_Build = o.Version_Build;
        Date_Year = o.Date_Year;
        Date_Month = o.Date_Month;
        Date_Day = o.Date_Day;
        Time_Seconds = o.Time_Seconds;
        Time_Minutes = o.Time_Minutes;
        Time_Hours = o.Time_Hours;
        systime = o.systime;
        for(unsigned n=0; n<2; ++n) OnTime[n] = o.OnTime[n];
        pwr_24V = o.pwr_24V;
        pwr_I_24V = o.pwr_I_24V;
        pwr_P_24V = o.pwr_P_24V;
        pwr_U_TECp = o.pwr_U_TECp;
        pwr_U_TECm = o.pwr_U_TECm;
        uc_24V = o.uc_24V;
        uc_P_24V = o.uc_P_24V;
        uc_I_24V = o.uc_I_24V;
        uc_12V = o.uc_12V;
        uc_5V = o.uc_5V;
        uc_3V3 = o.uc_3V3;
        uc_Proc_T = o.uc_Proc_T;
        uc_Temp = o.uc_Temp;
        uc_RH = o.uc_RH;
        for(unsigned n=0; n<8; ++n) uc_TD[n] = o.uc_TD[n];
        uc_TDq = o.uc_TDq;
        uc_Tsoll = o.uc_Tsoll;
        uc_I_FAN_C1 = o.uc_I_FAN_C1;
        uc_I_FAN_C2 = o.uc_I_FAN_C2;
        uc_I_FAN_TI = o.uc_I_FAN_TI;
        uc_I_FAN_TO = o.uc_I_FAN_TO;
        for(unsigned n=0; n<2; ++n) uc_FAN_SPEED[n] = o.uc_FAN_SPEED[n];
        uc_PWM_F = o.uc_PWM_F;
        uc_DCCq = o.uc_DCCq;
        uc_DCHq = o.uc_DCHq;
        uc_DACValue = o.uc_DACValue;
        uc_Status = o.uc_Status;
        uc_Error = o.uc_Error;
        Reserved0 = o.Reserved0;
        Reserved1 = o.Reserved1;
        Reserved2 = o.Reserved2;
        Reserved3 = o.Reserved3;
        Reserved4 = o.Reserved4;
        uc_Accl_X_mean = o.uc_Accl_X_mean;
        uc_Accl_X_min = o.uc_Accl_X_min;
        uc_Accl_X_max = o.uc_Accl_X_max;
        uc_Accl_X_cnt = o.uc_Accl_X_cnt;
        uc_Accl_Y_mean = o.uc_Accl_Y_mean;
        uc_Accl_Y_min = o.uc_Accl_Y_min;
        uc_Accl_Y_max = o.uc_Accl_Y_max;
        uc_Accl_Y_cnt = o.uc_Accl_Y_cnt;
        uc_Accl_Z_mean = o.uc_Accl_Z_mean;
        uc_Accl_Z_min = o.uc_Accl_Z_min;
        uc_Accl_Z_max = o.uc_Accl_Z_max;
        uc_Accl_Z_cnt = o.uc_Accl_Z_cnt;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_ph_data_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.Version_Major;
        s << ", " << x.Version_Minor;
        s << ", " << x.Version_Bugfix;
        s << ", " << x.Version_Build;
        s << ", " << x.Date_Year;
        s << ", " << x.Date_Month;
        s << ", " << x.Date_Day;
        s << ", " << x.Time_Seconds;
        s << ", " << x.Time_Minutes;
        s << ", " << x.Time_Hours;
        s << ", " << x.systime;
        s << ", "; write_array(s, 2, x.OnTime);
        s << ", " << x.pwr_24V;
        s << ", " << x.pwr_I_24V;
        s << ", " << x.pwr_P_24V;
        s << ", " << x.pwr_U_TECp;
        s << ", " << x.pwr_U_TECm;
        s << ", " << x.uc_24V;
        s << ", " << x.uc_P_24V;
        s << ", " << x.uc_I_24V;
        s << ", " << x.uc_12V;
        s << ", " << x.uc_5V;
        s << ", " << x.uc_3V3;
        s << ", " << x.uc_Proc_T;
        s << ", " << x.uc_Temp;
        s << ", " << x.uc_RH;
        s << ", "; write_array(s, 8, x.uc_TD);
        s << ", " << x.uc_TDq;
        s << ", " << x.uc_Tsoll;
        s << ", " << x.uc_I_FAN_C1;
        s << ", " << x.uc_I_FAN_C2;
        s << ", " << x.uc_I_FAN_TI;
        s << ", " << x.uc_I_FAN_TO;
        s << ", "; write_array(s, 2, x.uc_FAN_SPEED);
        s << ", " << x.uc_PWM_F;
        s << ", " << x.uc_DCCq;
        s << ", " << x.uc_DCHq;
        s << ", " << x.uc_DACValue;
        s << ", " << x.uc_Status;
        s << ", " << x.uc_Error;
        s << ", " << x.Reserved0;
        s << ", " << x.Reserved1;
        s << ", " << x.Reserved2;
        s << ", " << x.Reserved3;
        s << ", " << x.Reserved4;
        s << ", " << x.uc_Accl_X_mean;
        s << ", " << x.uc_Accl_X_min;
        s << ", " << x.uc_Accl_X_max;
        s << ", " << x.uc_Accl_X_cnt;
        s << ", " << x.uc_Accl_Y_mean;
        s << ", " << x.uc_Accl_Y_min;
        s << ", " << x.uc_Accl_Y_max;
        s << ", " << x.uc_Accl_Y_cnt;
        s << ", " << x.uc_Accl_Z_mean;
        s << ", " << x.uc_Accl_Z_min;
        s << ", " << x.uc_Accl_Z_max;
        s << ", " << x.uc_Accl_Z_cnt;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_ph_data_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.Version_Major;
        s >> ',' >> x.Version_Minor;
        s >> ',' >> x.Version_Bugfix;
        s >> ',' >> x.Version_Build;
        s >> ',' >> x.Date_Year;
        s >> ',' >> x.Date_Month;
        s >> ',' >> x.Date_Day;
        s >> ',' >> x.Time_Seconds;
        s >> ',' >> x.Time_Minutes;
        s >> ',' >> x.Time_Hours;
        s >> ',' >> x.systime;
        s >> ','; read_array(s, 2, x.OnTime);
        s >> ',' >> x.pwr_24V;
        s >> ',' >> x.pwr_I_24V;
        s >> ',' >> x.pwr_P_24V;
        s >> ',' >> x.pwr_U_TECp;
        s >> ',' >> x.pwr_U_TECm;
        s >> ',' >> x.uc_24V;
        s >> ',' >> x.uc_P_24V;
        s >> ',' >> x.uc_I_24V;
        s >> ',' >> x.uc_12V;
        s >> ',' >> x.uc_5V;
        s >> ',' >> x.uc_3V3;
        s >> ',' >> x.uc_Proc_T;
        s >> ',' >> x.uc_Temp;
        s >> ',' >> x.uc_RH;
        s >> ','; read_array(s, 8, x.uc_TD);
        s >> ',' >> x.uc_TDq;
        s >> ',' >> x.uc_Tsoll;
        s >> ',' >> x.uc_I_FAN_C1;
        s >> ',' >> x.uc_I_FAN_C2;
        s >> ',' >> x.uc_I_FAN_TI;
        s >> ',' >> x.uc_I_FAN_TO;
        s >> ','; read_array(s, 2, x.uc_FAN_SPEED);
        s >> ',' >> x.uc_PWM_F;
        s >> ',' >> x.uc_DCCq;
        s >> ',' >> x.uc_DCHq;
        s >> ',' >> x.uc_DACValue;
        s >> ',' >> x.uc_Status;
        s >> ',' >> x.uc_Error;
        s >> ',' >> x.Reserved0;
        s >> ',' >> x.Reserved1;
        s >> ',' >> x.Reserved2;
        s >> ',' >> x.Reserved3;
        s >> ',' >> x.Reserved4;
        s >> ',' >> x.uc_Accl_X_mean;
        s >> ',' >> x.uc_Accl_X_min;
        s >> ',' >> x.uc_Accl_X_max;
        s >> ',' >> x.uc_Accl_X_cnt;
        s >> ',' >> x.uc_Accl_Y_mean;
        s >> ',' >> x.uc_Accl_Y_min;
        s >> ',' >> x.uc_Accl_Y_max;
        s >> ',' >> x.uc_Accl_Y_cnt;
        s >> ',' >> x.uc_Accl_Z_mean;
        s >> ',' >> x.uc_Accl_Z_min;
        s >> ',' >> x.uc_Accl_Z_max;
        s >> ',' >> x.uc_Accl_Z_cnt;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! protective housing units

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_ph_units
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ph_units<rebind_it> type;
    };

    typedef it iterator_type;

    hk_ph_units(it begin, it end, bool dirty=false)
        : voltage(begin)
        , current(begin)
        , power(begin)
        , temp(begin)
        , rh(begin)
        , dc(begin)
        , systime(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10013, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 224};
    it begin() const { return voltage.begin(); }
    it end() const { return systime.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float voltage;//!<  nominally 0.001V 
    #else
    binary::field<float, sc_float32, 0, it> voltage;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float current;//!<  nominally 0.001A 
    #else
    binary::field<float, sc_float32, 32, it> current;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float power;//!<  nominally 0.001W 
    #else
    binary::field<float, sc_float32, 64, it> power;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float temp;//!<  nominally 0.01C 
    #else
    binary::field<float, sc_float32, 96, it> temp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rh;//!<  nominally % 
    #else
    binary::field<float, sc_float32, 128, it> rh;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float dc;//!<  nominally % 
    #else
    binary::field<float, sc_float32, 160, it> dc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float systime;//!<  nominally 12.5ns 
    #else
    binary::field<float, sc_float32, 192, it> systime;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_ph_units& operator=(const hk_ph_units<ito>& o) {
        voltage = o.voltage;
        current = o.current;
        power = o.power;
        temp = o.temp;
        rh = o.rh;
        dc = o.dc;
        systime = o.systime;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_ph_units<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ph_units<rebind_it> type;
    };

    enum { id_main = 10013, id_sub = 0};

    float            voltage;
    float            current;
    float            power;
    float            temp;
    float            rh;
    float            dc;
    float            systime;

    hk_ph_units()
        : voltage()
        , current()
        , power()
        , temp()
        , rh()
        , dc()
        , systime()
    {}

    template<class it>
    hk_ph_units(const hk_ph_units<it>& o) {
        voltage = o.voltage;
        current = o.current;
        power = o.power;
        temp = o.temp;
        rh = o.rh;
        dc = o.dc;
        systime = o.systime;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_ph_units<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.voltage;
        s << ", " << x.current;
        s << ", " << x.power;
        s << ", " << x.temp;
        s << ", " << x.rh;
        s << ", " << x.dc;
        s << ", " << x.systime;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_ph_units<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.voltage;
        s >> ',' >> x.current;
        s >> ',' >> x.power;
        s >> ',' >> x.temp;
        s >> ',' >> x.rh;
        s >> ',' >> x.dc;
        s >> ',' >> x.systime;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! protective housing units

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_ph_units_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ph_units_1<rebind_it> type;
    };

    typedef it iterator_type;

    hk_ph_units_1(it begin, it end, bool dirty=false)
        : voltage(begin)
        , current(begin)
        , power(begin)
        , temp(begin)
        , rh(begin)
        , dc(begin)
        , systime(begin)
        , accl_unit(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10013, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 256};
    it begin() const { return voltage.begin(); }
    it end() const { return accl_unit.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float voltage;//!<  nominally 0.001V 
    #else
    binary::field<float, sc_float32, 0, it> voltage;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float current;//!<  nominally 0.001A 
    #else
    binary::field<float, sc_float32, 32, it> current;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float power;//!<  nominally 0.001W 
    #else
    binary::field<float, sc_float32, 64, it> power;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float temp;//!<  nominally 0.01C 
    #else
    binary::field<float, sc_float32, 96, it> temp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rh;//!<  nominally % 
    #else
    binary::field<float, sc_float32, 128, it> rh;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float dc;//!<  nominally % 
    #else
    binary::field<float, sc_float32, 160, it> dc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float systime;//!<  nominally 12.5ns 
    #else
    binary::field<float, sc_float32, 192, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_unit;//!<  nominally 0.001g 
    #else
    binary::field<float, sc_float32, 224, it> accl_unit;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_ph_units_1& operator=(const hk_ph_units_1<ito>& o) {
        voltage = o.voltage;
        current = o.current;
        power = o.power;
        temp = o.temp;
        rh = o.rh;
        dc = o.dc;
        systime = o.systime;
        accl_unit = o.accl_unit;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_ph_units_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_ph_units_1<rebind_it> type;
    };

    enum { id_main = 10013, id_sub = 1};

    float            voltage;
    float            current;
    float            power;
    float            temp;
    float            rh;
    float            dc;
    float            systime;
    float            accl_unit;

    hk_ph_units_1()
        : voltage()
        , current()
        , power()
        , temp()
        , rh()
        , dc()
        , systime()
        , accl_unit()
    {}

    template<class it>
    hk_ph_units_1(const hk_ph_units_1<it>& o) {
        voltage = o.voltage;
        current = o.current;
        power = o.power;
        temp = o.temp;
        rh = o.rh;
        dc = o.dc;
        systime = o.systime;
        accl_unit = o.accl_unit;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_ph_units_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.voltage;
        s << ", " << x.current;
        s << ", " << x.power;
        s << ", " << x.temp;
        s << ", " << x.rh;
        s << ", " << x.dc;
        s << ", " << x.systime;
        s << ", " << x.accl_unit;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_ph_units_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.voltage;
        s >> ',' >> x.current;
        s >> ',' >> x.power;
        s >> ',' >> x.temp;
        s >> ',' >> x.rh;
        s >> ',' >> x.dc;
        s >> ',' >> x.systime;
        s >> ',' >> x.accl_unit;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! power supply unit (24 Bytes)

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status, deprecated</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_pwr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_pwr<rebind_it> type;
    };

    typedef it iterator_type;

    hk_pwr(it begin, it end, bool dirty=false)
        : V_IN_1(begin)
        , V_IN_2(begin)
        , V_IN_3(begin)
        , V_IN_SEL(begin)
        , A_IN_SEL(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10003, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 192};
    it begin() const { return V_IN_1.begin(); }
    it end() const { return RESERVED_11.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_1;//!<  power supply unit, input voltage port 1            [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 0, it> V_IN_1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_2;//!<  power supply unit, input voltage port 2            [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 16, it> V_IN_2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_3;//!<  power supply unit, input voltage battery port      [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 32, it> V_IN_3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t V_IN_SEL;//!<  power supply unit, selected input voltage          [10 mV] 
    #else
    binary::field<uint16_t, sc_uint16, 48, it> V_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t A_IN_SEL;//!<  power supply unit, input current                   [ 1 mA] 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> A_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_05;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_06;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_10;
    #else
    binary::field<uint8_t, sc_uint8, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_11[3];
    #else
    binary::array<uint8_t, 3, sc_uint8, 168, it> RESERVED_11;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_pwr& operator=(const hk_pwr<ito>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_pwr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_pwr<rebind_it> type;
    };

    enum { id_main = 10003, id_sub = 0};

    int16_t          V_IN_1;
    int16_t          V_IN_2;
    int16_t          V_IN_3;
    uint16_t         V_IN_SEL;
    uint16_t         A_IN_SEL;
    uint16_t         RESERVED_05;
    uint16_t         RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    uint8_t          RESERVED_10;
    uint8_t          RESERVED_11[3];

    hk_pwr()
        : V_IN_1()
        , V_IN_2()
        , V_IN_3()
        , V_IN_SEL()
        , A_IN_SEL()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
    {}

    template<class it>
    hk_pwr(const hk_pwr<it>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_pwr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.V_IN_1;
        s << ", " << x.V_IN_2;
        s << ", " << x.V_IN_3;
        s << ", " << x.V_IN_SEL;
        s << ", " << x.A_IN_SEL;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", "; write_array(s, 3, x.RESERVED_11);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_pwr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.V_IN_1;
        s >> ',' >> x.V_IN_2;
        s >> ',' >> x.V_IN_3;
        s >> ',' >> x.V_IN_SEL;
        s >> ',' >> x.A_IN_SEL;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ','; read_array(s, 3, x.RESERVED_11);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! power supply unit (24 Bytes)

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_pwr_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_pwr_1<rebind_it> type;
    };

    typedef it iterator_type;

    hk_pwr_1(it begin, it end, bool dirty=false)
        : V_IN_1(begin)
        , V_IN_2(begin)
        , V_IN_3(begin)
        , V_IN_SEL(begin)
        , A_IN_SEL(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10007, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 200};
    it begin() const { return V_IN_1.begin(); }
    it end() const { return RESERVED_11.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_1;//!<  power supply unit, input voltage port 1            [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 0, it> V_IN_1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_2;//!<  power supply unit, input voltage port 2            [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 16, it> V_IN_2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t V_IN_3;//!<  power supply unit, input voltage battery port      [10 mV] 
    #else
    binary::field<int16_t, sc_int16, 32, it> V_IN_3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t V_IN_SEL;//!<  power supply unit, selected input voltage          [10 mV] 
    #else
    binary::field<uint16_t, sc_uint16, 48, it> V_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t A_IN_SEL;//!<  power supply unit, input current                   [ 1 mA] 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> A_IN_SEL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_05;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_06;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_10;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t RESERVED_11[3];
    #else
    binary::array<uint8_t, 3, sc_uint8, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_pwr_1& operator=(const hk_pwr_1<ito>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_pwr_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_pwr_1<rebind_it> type;
    };

    enum { id_main = 10007, id_sub = 0};

    int16_t          V_IN_1;
    int16_t          V_IN_2;
    int16_t          V_IN_3;
    uint16_t         V_IN_SEL;
    uint16_t         A_IN_SEL;
    uint16_t         RESERVED_05;
    uint16_t         RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    uint16_t         RESERVED_10;
    uint8_t          RESERVED_11[3];

    hk_pwr_1()
        : V_IN_1()
        , V_IN_2()
        , V_IN_3()
        , V_IN_SEL()
        , A_IN_SEL()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
    {}

    template<class it>
    hk_pwr_1(const hk_pwr_1<it>& o) {
        V_IN_1 = o.V_IN_1;
        V_IN_2 = o.V_IN_2;
        V_IN_3 = o.V_IN_3;
        V_IN_SEL = o.V_IN_SEL;
        A_IN_SEL = o.A_IN_SEL;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        for(unsigned n=0; n<3; ++n) RESERVED_11[n] = o.RESERVED_11[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_pwr_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.V_IN_1;
        s << ", " << x.V_IN_2;
        s << ", " << x.V_IN_3;
        s << ", " << x.V_IN_SEL;
        s << ", " << x.A_IN_SEL;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", "; write_array(s, 3, x.RESERVED_11);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_pwr_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.V_IN_1;
        s >> ',' >> x.V_IN_2;
        s >> ',' >> x.V_IN_3;
        s >> ',' >> x.V_IN_SEL;
        s >> ',' >> x.A_IN_SEL;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ','; read_array(s, 3, x.RESERVED_11);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rad
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rad<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rad(it begin, it end, bool dirty=false)
        : RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10010, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return RESERVED_01.begin(); }
    it end() const { return RESERVED_06.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_02;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_04;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_06;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rad& operator=(const hk_rad<ito>& o) {
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rad<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rad<rebind_it> type;
    };

    enum { id_main = 10010, id_sub = 0};

    uint16_t         RESERVED_01;
    uint16_t         RESERVED_02;
    uint16_t         RESERVED_03;
    uint16_t         RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;

    hk_rad()
        : RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
    {}

    template<class it>
    hk_rad(const hk_rad<it>& o) {
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rad<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rad<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 304};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_18.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng& operator=(const hk_rng<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 0};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;

    hk_rng()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
    {}

    template<class it>
    hk_rng(const hk_rng<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_1<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng_1(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 336};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_19.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng_1& operator=(const hk_rng_1<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_1<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 1};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;

    hk_rng_1()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
    {}

    template<class it>
    hk_rng_1(const hk_rng_1<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_2<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng_2(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
        , RESERVED_20(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 352};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_20.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_20;
    #else
    binary::field<int16_t, sc_int16, 336, it> RESERVED_20;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng_2& operator=(const hk_rng_2<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_2<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 2};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;
    int16_t          RESERVED_20;

    hk_rng_2()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
        , RESERVED_20()
    {}

    template<class it>
    hk_rng_2(const hk_rng_2<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
        s << ", " << x.RESERVED_20;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
        s >> ',' >> x.RESERVED_20;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng_3
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_3<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng_3(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 3};
    #ifndef DOXYGEN
    enum { max_bit_width = 400};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_23.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_20;
    #else
    binary::field<int16_t, sc_int16, 336, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_21;
    #else
    binary::field<int16_t, sc_int16, 352, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 368, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 384, it> RESERVED_23;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng_3& operator=(const hk_rng_3<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng_3<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_3<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 3};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;
    int16_t          RESERVED_20;
    int16_t          RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;

    hk_rng_3()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
    {}

    template<class it>
    hk_rng_3(const hk_rng_3<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng_3<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng_3<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng_4
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_4<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng_4(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 4};
    #ifndef DOXYGEN
    enum { max_bit_width = 432};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_24.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_20;
    #else
    binary::field<int16_t, sc_int16, 336, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_21;
    #else
    binary::field<int16_t, sc_int16, 352, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 368, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 384, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_24;
    #else
    binary::field<uint32_t, sc_uint32, 400, it> RESERVED_24;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng_4& operator=(const hk_rng_4<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng_4<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_4<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 4};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;
    int16_t          RESERVED_20;
    int16_t          RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint32_t         RESERVED_24;

    hk_rng_4()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
    {}

    template<class it>
    hk_rng_4(const hk_rng_4<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng_4<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng_4<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng_5
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_5<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng_5(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
        , RESERVED_25(begin)
        , RESERVED_26(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 5};
    #ifndef DOXYGEN
    enum { max_bit_width = 464};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_26.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_20;
    #else
    binary::field<int16_t, sc_int16, 336, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_21;
    #else
    binary::field<int16_t, sc_int16, 352, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 368, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 384, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_24;
    #else
    binary::field<uint32_t, sc_uint32, 400, it> RESERVED_24;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_25;
    #else
    binary::field<uint16_t, sc_uint16, 432, it> RESERVED_25;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_26;
    #else
    binary::field<uint16_t, sc_uint16, 448, it> RESERVED_26;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng_5& operator=(const hk_rng_5<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng_5<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_5<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 5};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;
    int16_t          RESERVED_20;
    int16_t          RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint32_t         RESERVED_24;
    uint16_t         RESERVED_25;
    uint16_t         RESERVED_26;

    hk_rng_5()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
        , RESERVED_25()
        , RESERVED_26()
    {}

    template<class it>
    hk_rng_5(const hk_rng_5<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng_5<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
        s << ", " << x.RESERVED_25;
        s << ", " << x.RESERVED_26;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng_5<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
        s >> ',' >> x.RESERVED_25;
        s >> ',' >> x.RESERVED_26;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng_6
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_6<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng_6(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
        , RESERVED_25(begin)
        , RESERVED_26(begin)
        , RESERVED_27(begin)
        , RESERVED_28(begin)
        , RESERVED_29(begin)
        , RESERVED_30(begin)
        , RESERVED_31(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 6};
    #ifndef DOXYGEN
    enum { max_bit_width = 544};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_31.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_20;
    #else
    binary::field<int16_t, sc_int16, 336, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_21;
    #else
    binary::field<int16_t, sc_int16, 352, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 368, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 384, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_24;
    #else
    binary::field<uint32_t, sc_uint32, 400, it> RESERVED_24;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_25;
    #else
    binary::field<uint16_t, sc_uint16, 432, it> RESERVED_25;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_26;
    #else
    binary::field<uint16_t, sc_uint16, 448, it> RESERVED_26;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_27;
    #else
    binary::field<int16_t, sc_int16, 464, it> RESERVED_27;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_28;
    #else
    binary::field<uint16_t, sc_uint16, 480, it> RESERVED_28;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_29;
    #else
    binary::field<int16_t, sc_int16, 496, it> RESERVED_29;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_30;
    #else
    binary::field<int16_t, sc_int16, 512, it> RESERVED_30;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_31;
    #else
    binary::field<uint16_t, sc_uint16, 528, it> RESERVED_31;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng_6& operator=(const hk_rng_6<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng_6<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_6<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 6};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;
    int16_t          RESERVED_20;
    int16_t          RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint32_t         RESERVED_24;
    uint16_t         RESERVED_25;
    uint16_t         RESERVED_26;
    int16_t          RESERVED_27;
    uint16_t         RESERVED_28;
    int16_t          RESERVED_29;
    int16_t          RESERVED_30;
    uint16_t         RESERVED_31;

    hk_rng_6()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
        , RESERVED_25()
        , RESERVED_26()
        , RESERVED_27()
        , RESERVED_28()
        , RESERVED_29()
        , RESERVED_30()
        , RESERVED_31()
    {}

    template<class it>
    hk_rng_6(const hk_rng_6<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng_6<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
        s << ", " << x.RESERVED_25;
        s << ", " << x.RESERVED_26;
        s << ", " << x.RESERVED_27;
        s << ", " << x.RESERVED_28;
        s << ", " << x.RESERVED_29;
        s << ", " << x.RESERVED_30;
        s << ", " << x.RESERVED_31;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng_6<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
        s >> ',' >> x.RESERVED_25;
        s >> ',' >> x.RESERVED_26;
        s >> ',' >> x.RESERVED_27;
        s >> ',' >> x.RESERVED_28;
        s >> ',' >> x.RESERVED_29;
        s >> ',' >> x.RESERVED_30;
        s >> ',' >> x.RESERVED_31;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng_7
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_7<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng_7(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
        , RESERVED_25(begin)
        , RESERVED_26(begin)
        , RESERVED_27(begin)
        , RESERVED_28(begin)
        , RESERVED_29(begin)
        , RESERVED_30(begin)
        , RESERVED_31(begin)
        , RESERVED_32(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 7};
    #ifndef DOXYGEN
    enum { max_bit_width = 560};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_32.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_20;
    #else
    binary::field<int16_t, sc_int16, 336, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_21;
    #else
    binary::field<int16_t, sc_int16, 352, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 368, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 384, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_24;
    #else
    binary::field<uint32_t, sc_uint32, 400, it> RESERVED_24;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_25;
    #else
    binary::field<uint16_t, sc_uint16, 432, it> RESERVED_25;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_26;
    #else
    binary::field<uint16_t, sc_uint16, 448, it> RESERVED_26;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_27;
    #else
    binary::field<int16_t, sc_int16, 464, it> RESERVED_27;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_28;
    #else
    binary::field<uint16_t, sc_uint16, 480, it> RESERVED_28;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_29;
    #else
    binary::field<int16_t, sc_int16, 496, it> RESERVED_29;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_30;
    #else
    binary::field<int16_t, sc_int16, 512, it> RESERVED_30;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_31;
    #else
    binary::field<uint16_t, sc_uint16, 528, it> RESERVED_31;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_32;
    #else
    binary::field<int16_t, sc_int16, 544, it> RESERVED_32;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng_7& operator=(const hk_rng_7<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
        RESERVED_32 = o.RESERVED_32;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng_7<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_7<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 7};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;
    int16_t          RESERVED_20;
    int16_t          RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint32_t         RESERVED_24;
    uint16_t         RESERVED_25;
    uint16_t         RESERVED_26;
    int16_t          RESERVED_27;
    uint16_t         RESERVED_28;
    int16_t          RESERVED_29;
    int16_t          RESERVED_30;
    uint16_t         RESERVED_31;
    int16_t          RESERVED_32;

    hk_rng_7()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
        , RESERVED_25()
        , RESERVED_26()
        , RESERVED_27()
        , RESERVED_28()
        , RESERVED_29()
        , RESERVED_30()
        , RESERVED_31()
        , RESERVED_32()
    {}

    template<class it>
    hk_rng_7(const hk_rng_7<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
        RESERVED_32 = o.RESERVED_32;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng_7<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
        s << ", " << x.RESERVED_25;
        s << ", " << x.RESERVED_26;
        s << ", " << x.RESERVED_27;
        s << ", " << x.RESERVED_28;
        s << ", " << x.RESERVED_29;
        s << ", " << x.RESERVED_30;
        s << ", " << x.RESERVED_31;
        s << ", " << x.RESERVED_32;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng_7<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
        s >> ',' >> x.RESERVED_25;
        s >> ',' >> x.RESERVED_26;
        s >> ',' >> x.RESERVED_27;
        s >> ',' >> x.RESERVED_28;
        s >> ',' >> x.RESERVED_29;
        s >> ',' >> x.RESERVED_30;
        s >> ',' >> x.RESERVED_31;
        s >> ',' >> x.RESERVED_32;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng_8
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_8<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng_8(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
        , RESERVED_25(begin)
        , RESERVED_26(begin)
        , RESERVED_27(begin)
        , RESERVED_28(begin)
        , RESERVED_29(begin)
        , RESERVED_30(begin)
        , RESERVED_31(begin)
        , RESERVED_32(begin)
        , RESERVED_33(begin)
        , RESERVED_34(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 8};
    #ifndef DOXYGEN
    enum { max_bit_width = 592};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_34.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_20;
    #else
    binary::field<int16_t, sc_int16, 336, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_21;
    #else
    binary::field<int16_t, sc_int16, 352, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 368, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 384, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_24;
    #else
    binary::field<uint32_t, sc_uint32, 400, it> RESERVED_24;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_25;
    #else
    binary::field<uint16_t, sc_uint16, 432, it> RESERVED_25;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_26;
    #else
    binary::field<uint16_t, sc_uint16, 448, it> RESERVED_26;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_27;
    #else
    binary::field<int16_t, sc_int16, 464, it> RESERVED_27;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_28;
    #else
    binary::field<uint16_t, sc_uint16, 480, it> RESERVED_28;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_29;
    #else
    binary::field<int16_t, sc_int16, 496, it> RESERVED_29;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_30;
    #else
    binary::field<int16_t, sc_int16, 512, it> RESERVED_30;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_31;
    #else
    binary::field<uint16_t, sc_uint16, 528, it> RESERVED_31;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_32;
    #else
    binary::field<int16_t, sc_int16, 544, it> RESERVED_32;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_33;
    #else
    binary::field<uint16_t, sc_uint16, 560, it> RESERVED_33;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_34;
    #else
    binary::field<uint16_t, sc_uint16, 576, it> RESERVED_34;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng_8& operator=(const hk_rng_8<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
        RESERVED_32 = o.RESERVED_32;
        RESERVED_33 = o.RESERVED_33;
        RESERVED_34 = o.RESERVED_34;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng_8<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_8<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 8};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;
    int16_t          RESERVED_20;
    int16_t          RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint32_t         RESERVED_24;
    uint16_t         RESERVED_25;
    uint16_t         RESERVED_26;
    int16_t          RESERVED_27;
    uint16_t         RESERVED_28;
    int16_t          RESERVED_29;
    int16_t          RESERVED_30;
    uint16_t         RESERVED_31;
    int16_t          RESERVED_32;
    uint16_t         RESERVED_33;
    uint16_t         RESERVED_34;

    hk_rng_8()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
        , RESERVED_25()
        , RESERVED_26()
        , RESERVED_27()
        , RESERVED_28()
        , RESERVED_29()
        , RESERVED_30()
        , RESERVED_31()
        , RESERVED_32()
        , RESERVED_33()
        , RESERVED_34()
    {}

    template<class it>
    hk_rng_8(const hk_rng_8<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
        RESERVED_32 = o.RESERVED_32;
        RESERVED_33 = o.RESERVED_33;
        RESERVED_34 = o.RESERVED_34;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng_8<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
        s << ", " << x.RESERVED_25;
        s << ", " << x.RESERVED_26;
        s << ", " << x.RESERVED_27;
        s << ", " << x.RESERVED_28;
        s << ", " << x.RESERVED_29;
        s << ", " << x.RESERVED_30;
        s << ", " << x.RESERVED_31;
        s << ", " << x.RESERVED_32;
        s << ", " << x.RESERVED_33;
        s << ", " << x.RESERVED_34;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng_8<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
        s >> ',' >> x.RESERVED_25;
        s >> ',' >> x.RESERVED_26;
        s >> ',' >> x.RESERVED_27;
        s >> ',' >> x.RESERVED_28;
        s >> ',' >> x.RESERVED_29;
        s >> ',' >> x.RESERVED_30;
        s >> ',' >> x.RESERVED_31;
        s >> ',' >> x.RESERVED_32;
        s >> ',' >> x.RESERVED_33;
        s >> ',' >> x.RESERVED_34;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rng_9
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_9<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rng_9(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
        , RESERVED_25(begin)
        , RESERVED_26(begin)
        , RESERVED_27(begin)
        , RESERVED_28(begin)
        , RESERVED_29(begin)
        , RESERVED_30(begin)
        , RESERVED_31(begin)
        , RESERVED_32(begin)
        , RESERVED_33(begin)
        , RESERVED_34(begin)
        , RESERVED_35(begin)
        , RESERVED_36(begin)
        , RESERVED_37(begin)
        , RESERVED_38(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10001, id_sub = 9};
    #ifndef DOXYGEN
    enum { max_bit_width = 656};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_38.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_13;
    #else
    binary::field<int16_t, sc_int16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_20;
    #else
    binary::field<int16_t, sc_int16, 336, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_21;
    #else
    binary::field<int16_t, sc_int16, 352, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 368, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 384, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_24;
    #else
    binary::field<uint32_t, sc_uint32, 400, it> RESERVED_24;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_25;
    #else
    binary::field<uint16_t, sc_uint16, 432, it> RESERVED_25;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_26;
    #else
    binary::field<uint16_t, sc_uint16, 448, it> RESERVED_26;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_27;
    #else
    binary::field<int16_t, sc_int16, 464, it> RESERVED_27;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_28;
    #else
    binary::field<uint16_t, sc_uint16, 480, it> RESERVED_28;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_29;
    #else
    binary::field<int16_t, sc_int16, 496, it> RESERVED_29;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_30;
    #else
    binary::field<int16_t, sc_int16, 512, it> RESERVED_30;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_31;
    #else
    binary::field<uint16_t, sc_uint16, 528, it> RESERVED_31;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_32;
    #else
    binary::field<int16_t, sc_int16, 544, it> RESERVED_32;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_33;
    #else
    binary::field<uint16_t, sc_uint16, 560, it> RESERVED_33;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_34;
    #else
    binary::field<uint16_t, sc_uint16, 576, it> RESERVED_34;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_35;
    #else
    binary::field<uint16_t, sc_uint16, 592, it> RESERVED_35;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_36;
    #else
    binary::field<uint16_t, sc_uint16, 608, it> RESERVED_36;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_37;
    #else
    binary::field<uint16_t, sc_uint16, 624, it> RESERVED_37;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_38;
    #else
    binary::field<uint16_t, sc_uint16, 640, it> RESERVED_38;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rng_9& operator=(const hk_rng_9<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
        RESERVED_32 = o.RESERVED_32;
        RESERVED_33 = o.RESERVED_33;
        RESERVED_34 = o.RESERVED_34;
        RESERVED_35 = o.RESERVED_35;
        RESERVED_36 = o.RESERVED_36;
        RESERVED_37 = o.RESERVED_37;
        RESERVED_38 = o.RESERVED_38;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rng_9<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rng_9<rebind_it> type;
    };

    enum { id_main = 10001, id_sub = 9};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    int16_t          RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;
    int16_t          RESERVED_20;
    int16_t          RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint32_t         RESERVED_24;
    uint16_t         RESERVED_25;
    uint16_t         RESERVED_26;
    int16_t          RESERVED_27;
    uint16_t         RESERVED_28;
    int16_t          RESERVED_29;
    int16_t          RESERVED_30;
    uint16_t         RESERVED_31;
    int16_t          RESERVED_32;
    uint16_t         RESERVED_33;
    uint16_t         RESERVED_34;
    uint16_t         RESERVED_35;
    uint16_t         RESERVED_36;
    uint16_t         RESERVED_37;
    uint16_t         RESERVED_38;

    hk_rng_9()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
        , RESERVED_25()
        , RESERVED_26()
        , RESERVED_27()
        , RESERVED_28()
        , RESERVED_29()
        , RESERVED_30()
        , RESERVED_31()
        , RESERVED_32()
        , RESERVED_33()
        , RESERVED_34()
        , RESERVED_35()
        , RESERVED_36()
        , RESERVED_37()
        , RESERVED_38()
    {}

    template<class it>
    hk_rng_9(const hk_rng_9<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
        RESERVED_32 = o.RESERVED_32;
        RESERVED_33 = o.RESERVED_33;
        RESERVED_34 = o.RESERVED_34;
        RESERVED_35 = o.RESERVED_35;
        RESERVED_36 = o.RESERVED_36;
        RESERVED_37 = o.RESERVED_37;
        RESERVED_38 = o.RESERVED_38;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rng_9<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
        s << ", " << x.RESERVED_25;
        s << ", " << x.RESERVED_26;
        s << ", " << x.RESERVED_27;
        s << ", " << x.RESERVED_28;
        s << ", " << x.RESERVED_29;
        s << ", " << x.RESERVED_30;
        s << ", " << x.RESERVED_31;
        s << ", " << x.RESERVED_32;
        s << ", " << x.RESERVED_33;
        s << ", " << x.RESERVED_34;
        s << ", " << x.RESERVED_35;
        s << ", " << x.RESERVED_36;
        s << ", " << x.RESERVED_37;
        s << ", " << x.RESERVED_38;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rng_9<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
        s >> ',' >> x.RESERVED_25;
        s >> ',' >> x.RESERVED_26;
        s >> ',' >> x.RESERVED_27;
        s >> ',' >> x.RESERVED_28;
        s >> ',' >> x.RESERVED_29;
        s >> ',' >> x.RESERVED_30;
        s >> ',' >> x.RESERVED_31;
        s >> ',' >> x.RESERVED_32;
        s >> ',' >> x.RESERVED_33;
        s >> ',' >> x.RESERVED_34;
        s >> ',' >> x.RESERVED_35;
        s >> ',' >> x.RESERVED_36;
        s >> ',' >> x.RESERVED_37;
        s >> ',' >> x.RESERVED_38;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rngx
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rngx<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rngx(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
        , RESERVED_14(begin)
        , RESERVED_15(begin)
        , RESERVED_16(begin)
        , RESERVED_17(begin)
        , RESERVED_18(begin)
        , RESERVED_19(begin)
        , RESERVED_20(begin)
        , RESERVED_21(begin)
        , RESERVED_22(begin)
        , RESERVED_23(begin)
        , RESERVED_24(begin)
        , RESERVED_25(begin)
        , RESERVED_26(begin)
        , RESERVED_27(begin)
        , RESERVED_28(begin)
        , RESERVED_29(begin)
        , RESERVED_30(begin)
        , RESERVED_31(begin)
        , RESERVED_32(begin)
        , RESERVED_33(begin)
        , RESERVED_34(begin)
        , RESERVED_35(begin)
        , RESERVED_36(begin)
        , RESERVED_37(begin)
        , RESERVED_38(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10015, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 656};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_38.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_02;
    #else
    binary::field<int16_t, sc_int16, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_03;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_04;
    #else
    binary::field<int16_t, sc_int16, 64, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 80, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 96, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_07;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_08;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_09;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_10;
    #else
    binary::field<int16_t, sc_int16, 160, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_11;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_12;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_13;
    #else
    binary::field<uint16_t, sc_uint16, 208, it> RESERVED_13;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_14;
    #else
    binary::field<int16_t, sc_int16, 224, it> RESERVED_14;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_15;
    #else
    binary::field<int16_t, sc_int16, 240, it> RESERVED_15;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_16;
    #else
    binary::field<int16_t, sc_int16, 256, it> RESERVED_16;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_17;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> RESERVED_17;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_18;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> RESERVED_18;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_19;
    #else
    binary::field<uint32_t, sc_uint32, 304, it> RESERVED_19;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_20;
    #else
    binary::field<uint16_t, sc_uint16, 336, it> RESERVED_20;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_21;
    #else
    binary::field<int16_t, sc_int16, 352, it> RESERVED_21;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_22;
    #else
    binary::field<uint16_t, sc_uint16, 368, it> RESERVED_22;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_23;
    #else
    binary::field<uint16_t, sc_uint16, 384, it> RESERVED_23;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_24;
    #else
    binary::field<uint32_t, sc_uint32, 400, it> RESERVED_24;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_25;
    #else
    binary::field<uint16_t, sc_uint16, 432, it> RESERVED_25;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_26;
    #else
    binary::field<uint16_t, sc_uint16, 448, it> RESERVED_26;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_27;
    #else
    binary::field<int16_t, sc_int16, 464, it> RESERVED_27;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_28;
    #else
    binary::field<uint16_t, sc_uint16, 480, it> RESERVED_28;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_29;
    #else
    binary::field<int16_t, sc_int16, 496, it> RESERVED_29;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_30;
    #else
    binary::field<uint16_t, sc_uint16, 512, it> RESERVED_30;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_31;
    #else
    binary::field<uint16_t, sc_uint16, 528, it> RESERVED_31;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_32;
    #else
    binary::field<int16_t, sc_int16, 544, it> RESERVED_32;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_33;
    #else
    binary::field<uint16_t, sc_uint16, 560, it> RESERVED_33;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_34;
    #else
    binary::field<uint16_t, sc_uint16, 576, it> RESERVED_34;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_35;
    #else
    binary::field<uint16_t, sc_uint16, 592, it> RESERVED_35;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_36;
    #else
    binary::field<uint16_t, sc_uint16, 608, it> RESERVED_36;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_37;
    #else
    binary::field<uint16_t, sc_uint16, 624, it> RESERVED_37;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_38;
    #else
    binary::field<uint16_t, sc_uint16, 640, it> RESERVED_38;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rngx& operator=(const hk_rngx<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
        RESERVED_32 = o.RESERVED_32;
        RESERVED_33 = o.RESERVED_33;
        RESERVED_34 = o.RESERVED_34;
        RESERVED_35 = o.RESERVED_35;
        RESERVED_36 = o.RESERVED_36;
        RESERVED_37 = o.RESERVED_37;
        RESERVED_38 = o.RESERVED_38;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_rngx<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rngx<rebind_it> type;
    };

    enum { id_main = 10015, id_sub = 0};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    int16_t          RESERVED_02;
    uint16_t         RESERVED_03;
    int16_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    uint16_t         RESERVED_07;
    uint16_t         RESERVED_08;
    int16_t          RESERVED_09;
    int16_t          RESERVED_10;
    uint16_t         RESERVED_11;
    uint16_t         RESERVED_12;
    uint16_t         RESERVED_13;
    int16_t          RESERVED_14;
    int16_t          RESERVED_15;
    int16_t          RESERVED_16;
    uint16_t         RESERVED_17;
    uint16_t         RESERVED_18;
    uint32_t         RESERVED_19;
    uint16_t         RESERVED_20;
    int16_t          RESERVED_21;
    uint16_t         RESERVED_22;
    uint16_t         RESERVED_23;
    uint32_t         RESERVED_24;
    uint16_t         RESERVED_25;
    uint16_t         RESERVED_26;
    int16_t          RESERVED_27;
    uint16_t         RESERVED_28;
    int16_t          RESERVED_29;
    uint16_t         RESERVED_30;
    uint16_t         RESERVED_31;
    int16_t          RESERVED_32;
    uint16_t         RESERVED_33;
    uint16_t         RESERVED_34;
    uint16_t         RESERVED_35;
    uint16_t         RESERVED_36;
    uint16_t         RESERVED_37;
    uint16_t         RESERVED_38;

    hk_rngx()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
        , RESERVED_14()
        , RESERVED_15()
        , RESERVED_16()
        , RESERVED_17()
        , RESERVED_18()
        , RESERVED_19()
        , RESERVED_20()
        , RESERVED_21()
        , RESERVED_22()
        , RESERVED_23()
        , RESERVED_24()
        , RESERVED_25()
        , RESERVED_26()
        , RESERVED_27()
        , RESERVED_28()
        , RESERVED_29()
        , RESERVED_30()
        , RESERVED_31()
        , RESERVED_32()
        , RESERVED_33()
        , RESERVED_34()
        , RESERVED_35()
        , RESERVED_36()
        , RESERVED_37()
        , RESERVED_38()
    {}

    template<class it>
    hk_rngx(const hk_rngx<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        RESERVED_14 = o.RESERVED_14;
        RESERVED_15 = o.RESERVED_15;
        RESERVED_16 = o.RESERVED_16;
        RESERVED_17 = o.RESERVED_17;
        RESERVED_18 = o.RESERVED_18;
        RESERVED_19 = o.RESERVED_19;
        RESERVED_20 = o.RESERVED_20;
        RESERVED_21 = o.RESERVED_21;
        RESERVED_22 = o.RESERVED_22;
        RESERVED_23 = o.RESERVED_23;
        RESERVED_24 = o.RESERVED_24;
        RESERVED_25 = o.RESERVED_25;
        RESERVED_26 = o.RESERVED_26;
        RESERVED_27 = o.RESERVED_27;
        RESERVED_28 = o.RESERVED_28;
        RESERVED_29 = o.RESERVED_29;
        RESERVED_30 = o.RESERVED_30;
        RESERVED_31 = o.RESERVED_31;
        RESERVED_32 = o.RESERVED_32;
        RESERVED_33 = o.RESERVED_33;
        RESERVED_34 = o.RESERVED_34;
        RESERVED_35 = o.RESERVED_35;
        RESERVED_36 = o.RESERVED_36;
        RESERVED_37 = o.RESERVED_37;
        RESERVED_38 = o.RESERVED_38;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rngx<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
        s << ", " << x.RESERVED_14;
        s << ", " << x.RESERVED_15;
        s << ", " << x.RESERVED_16;
        s << ", " << x.RESERVED_17;
        s << ", " << x.RESERVED_18;
        s << ", " << x.RESERVED_19;
        s << ", " << x.RESERVED_20;
        s << ", " << x.RESERVED_21;
        s << ", " << x.RESERVED_22;
        s << ", " << x.RESERVED_23;
        s << ", " << x.RESERVED_24;
        s << ", " << x.RESERVED_25;
        s << ", " << x.RESERVED_26;
        s << ", " << x.RESERVED_27;
        s << ", " << x.RESERVED_28;
        s << ", " << x.RESERVED_29;
        s << ", " << x.RESERVED_30;
        s << ", " << x.RESERVED_31;
        s << ", " << x.RESERVED_32;
        s << ", " << x.RESERVED_33;
        s << ", " << x.RESERVED_34;
        s << ", " << x.RESERVED_35;
        s << ", " << x.RESERVED_36;
        s << ", " << x.RESERVED_37;
        s << ", " << x.RESERVED_38;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rngx<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
        s >> ',' >> x.RESERVED_14;
        s >> ',' >> x.RESERVED_15;
        s >> ',' >> x.RESERVED_16;
        s >> ',' >> x.RESERVED_17;
        s >> ',' >> x.RESERVED_18;
        s >> ',' >> x.RESERVED_19;
        s >> ',' >> x.RESERVED_20;
        s >> ',' >> x.RESERVED_21;
        s >> ',' >> x.RESERVED_22;
        s >> ',' >> x.RESERVED_23;
        s >> ',' >> x.RESERVED_24;
        s >> ',' >> x.RESERVED_25;
        s >> ',' >> x.RESERVED_26;
        s >> ',' >> x.RESERVED_27;
        s >> ',' >> x.RESERVED_28;
        s >> ',' >> x.RESERVED_29;
        s >> ',' >> x.RESERVED_30;
        s >> ',' >> x.RESERVED_31;
        s >> ',' >> x.RESERVED_32;
        s >> ',' >> x.RESERVED_33;
        s >> ',' >> x.RESERVED_34;
        s >> ',' >> x.RESERVED_35;
        s >> ',' >> x.RESERVED_36;
        s >> ',' >> x.RESERVED_37;
        s >> ',' >> x.RESERVED_38;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! built in real time clock of scanning device, local time

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status, legacy</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rtc
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rtc<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rtc(it begin, it end, bool dirty=false)
        : year(begin)
        , month(begin)
        , day(begin)
        , hour(begin)
        , minute(begin)
        , second(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10000, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 48};
    it begin() const { return year.begin(); }
    it end() const { return second.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t year;//!<  years since 1900 
    #else
    binary::field<uint8_t, sc_uint8, 0, it> year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t month;//!<  months since January 
    #else
    binary::field<uint8_t, sc_uint8, 8, it> month;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t day;//!<  day of the month 
    #else
    binary::field<uint8_t, sc_uint8, 16, it> day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hour;//!<  hours after midnight 
    #else
    binary::field<uint8_t, sc_uint8, 24, it> hour;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t minute;//!<  minutes after the hour 
    #else
    binary::field<uint8_t, sc_uint8, 32, it> minute;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t second;//!<  seconds after the minute 
    #else
    binary::field<uint8_t, sc_uint8, 40, it> second;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rtc& operator=(const hk_rtc<ito>& o) {
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_rtc<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rtc<rebind_it> type;
    };

    enum { id_main = 10000, id_sub = 0};

    uint8_t          year;
    uint8_t          month;
    uint8_t          day;
    uint8_t          hour;
    uint8_t          minute;
    uint8_t          second;

    hk_rtc()
        : year()
        , month()
        , day()
        , hour()
        , minute()
        , second()
    {}

    template<class it>
    hk_rtc(const hk_rtc<it>& o) {
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rtc<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.year;
        s << ", " << x.month;
        s << ", " << x.day;
        s << ", " << x.hour;
        s << ", " << x.minute;
        s << ", " << x.second;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rtc<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.year;
        s >> ',' >> x.month;
        s >> ',' >> x.day;
        s >> ',' >> x.hour;
        s >> ',' >> x.minute;
        s >> ',' >> x.second;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! real time clock, local time (10 Bytes)

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status, legacy</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_rtc_sys
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rtc_sys<rebind_it> type;
    };

    typedef it iterator_type;

    hk_rtc_sys(it begin, it end, bool dirty=false)
        : year(begin)
        , month(begin)
        , day(begin)
        , hour(begin)
        , minute(begin)
        , second(begin)
        , systime(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10000, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 80};
    it begin() const { return year.begin(); }
    it end() const { return systime.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t year;//!<  years since 1900 
    #else
    binary::field<uint8_t, sc_uint8, 0, it> year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t month;//!<  months since January 
    #else
    binary::field<uint8_t, sc_uint8, 8, it> month;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t day;//!<  day of the month 
    #else
    binary::field<uint8_t, sc_uint8, 16, it> day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hour;//!<  hours after midnight 
    #else
    binary::field<uint8_t, sc_uint8, 24, it> hour;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t minute;//!<  minutes after the hour 
    #else
    binary::field<uint8_t, sc_uint8, 32, it> minute;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t second;//!<  seconds after the minute 
    #else
    binary::field<uint8_t, sc_uint8, 40, it> second;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 48, it> systime;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_rtc_sys& operator=(const hk_rtc_sys<ito>& o) {
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        systime = o.systime;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct hk_rtc_sys<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_rtc_sys<rebind_it> type;
    };

    enum { id_main = 10000, id_sub = 1};

    uint8_t          year;
    uint8_t          month;
    uint8_t          day;
    uint8_t          hour;
    uint8_t          minute;
    uint8_t          second;
    uint32_t         systime;

    hk_rtc_sys()
        : year()
        , month()
        , day()
        , hour()
        , minute()
        , second()
        , systime()
    {}

    template<class it>
    hk_rtc_sys(const hk_rtc_sys<it>& o) {
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        systime = o.systime;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_rtc_sys<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.year;
        s << ", " << x.month;
        s << ", " << x.day;
        s << ", " << x.hour;
        s << ", " << x.minute;
        s << ", " << x.second;
        s << ", " << x.systime;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_rtc_sys<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.year;
        s >> ',' >> x.month;
        s >> ',' >> x.day;
        s >> ',' >> x.hour;
        s >> ',' >> x.minute;
        s >> ',' >> x.second;
        s >> ',' >> x.systime;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_scn
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_scn<rebind_it> type;
    };

    typedef it iterator_type;

    hk_scn(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10002, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 160};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_06.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_02;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t RESERVED_03;
    #else
    binary::field<int32_t, sc_int32, 64, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t RESERVED_04;
    #else
    binary::field<int32_t, sc_int32, 96, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 128, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_06;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_scn& operator=(const hk_scn<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_scn<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_scn<rebind_it> type;
    };

    enum { id_main = 10002, id_sub = 0};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    uint32_t         RESERVED_02;
    int32_t          RESERVED_03;
    int32_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;

    hk_scn()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
    {}

    template<class it>
    hk_scn(const hk_scn<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_scn<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_scn<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_scn_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_scn_1<rebind_it> type;
    };

    typedef it iterator_type;

    hk_scn_1(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10002, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 320};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_11.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_02;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t RESERVED_03;
    #else
    binary::field<int32_t, sc_int32, 64, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t RESERVED_04;
    #else
    binary::field<int32_t, sc_int32, 96, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 128, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t RESERVED_07;
    #else
    binary::field<int32_t, sc_int32, 160, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_08;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_09;
    #else
    binary::field<uint32_t, sc_uint32, 224, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_10;
    #else
    binary::field<uint32_t, sc_uint32, 256, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_11;
    #else
    binary::field<uint32_t, sc_uint32, 288, it> RESERVED_11;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_scn_1& operator=(const hk_scn_1<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_scn_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_scn_1<rebind_it> type;
    };

    enum { id_main = 10002, id_sub = 1};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    uint32_t         RESERVED_02;
    int32_t          RESERVED_03;
    int32_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    int32_t          RESERVED_07;
    uint32_t         RESERVED_08;
    uint32_t         RESERVED_09;
    uint32_t         RESERVED_10;
    uint32_t         RESERVED_11;

    hk_scn_1()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
    {}

    template<class it>
    hk_scn_1(const hk_scn_1<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_scn_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_scn_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_scn_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_scn_2<rebind_it> type;
    };

    typedef it iterator_type;

    hk_scn_2(it begin, it end, bool dirty=false)
        : RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , RESERVED_03(begin)
        , RESERVED_04(begin)
        , RESERVED_05(begin)
        , RESERVED_06(begin)
        , RESERVED_07(begin)
        , RESERVED_08(begin)
        , RESERVED_09(begin)
        , RESERVED_10(begin)
        , RESERVED_11(begin)
        , RESERVED_12(begin)
        , RESERVED_13(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10002, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 384};
    it begin() const { return RESERVED_00.begin(); }
    it end() const { return RESERVED_13.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_00;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t RESERVED_01;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_02;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t RESERVED_03;
    #else
    binary::field<int32_t, sc_int32, 64, it> RESERVED_03;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t RESERVED_04;
    #else
    binary::field<int32_t, sc_int32, 96, it> RESERVED_04;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_05;
    #else
    binary::field<int16_t, sc_int16, 128, it> RESERVED_05;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t RESERVED_06;
    #else
    binary::field<int16_t, sc_int16, 144, it> RESERVED_06;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t RESERVED_07;
    #else
    binary::field<int32_t, sc_int32, 160, it> RESERVED_07;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_08;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> RESERVED_08;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_09;
    #else
    binary::field<uint32_t, sc_uint32, 224, it> RESERVED_09;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_10;
    #else
    binary::field<uint32_t, sc_uint32, 256, it> RESERVED_10;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_11;
    #else
    binary::field<uint32_t, sc_uint32, 288, it> RESERVED_11;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t RESERVED_12;
    #else
    binary::field<int32_t, sc_int32, 320, it> RESERVED_12;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_13;
    #else
    binary::field<uint32_t, sc_uint32, 352, it> RESERVED_13;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_scn_2& operator=(const hk_scn_2<ito>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_scn_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_scn_2<rebind_it> type;
    };

    enum { id_main = 10002, id_sub = 2};

    uint16_t         RESERVED_00;
    uint16_t         RESERVED_01;
    uint32_t         RESERVED_02;
    int32_t          RESERVED_03;
    int32_t          RESERVED_04;
    int16_t          RESERVED_05;
    int16_t          RESERVED_06;
    int32_t          RESERVED_07;
    uint32_t         RESERVED_08;
    uint32_t         RESERVED_09;
    uint32_t         RESERVED_10;
    uint32_t         RESERVED_11;
    int32_t          RESERVED_12;
    uint32_t         RESERVED_13;

    hk_scn_2()
        : RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , RESERVED_03()
        , RESERVED_04()
        , RESERVED_05()
        , RESERVED_06()
        , RESERVED_07()
        , RESERVED_08()
        , RESERVED_09()
        , RESERVED_10()
        , RESERVED_11()
        , RESERVED_12()
        , RESERVED_13()
    {}

    template<class it>
    hk_scn_2(const hk_scn_2<it>& o) {
        RESERVED_00 = o.RESERVED_00;
        RESERVED_01 = o.RESERVED_01;
        RESERVED_02 = o.RESERVED_02;
        RESERVED_03 = o.RESERVED_03;
        RESERVED_04 = o.RESERVED_04;
        RESERVED_05 = o.RESERVED_05;
        RESERVED_06 = o.RESERVED_06;
        RESERVED_07 = o.RESERVED_07;
        RESERVED_08 = o.RESERVED_08;
        RESERVED_09 = o.RESERVED_09;
        RESERVED_10 = o.RESERVED_10;
        RESERVED_11 = o.RESERVED_11;
        RESERVED_12 = o.RESERVED_12;
        RESERVED_13 = o.RESERVED_13;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_scn_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.RESERVED_00;
        s << ", " << x.RESERVED_01;
        s << ", " << x.RESERVED_02;
        s << ", " << x.RESERVED_03;
        s << ", " << x.RESERVED_04;
        s << ", " << x.RESERVED_05;
        s << ", " << x.RESERVED_06;
        s << ", " << x.RESERVED_07;
        s << ", " << x.RESERVED_08;
        s << ", " << x.RESERVED_09;
        s << ", " << x.RESERVED_10;
        s << ", " << x.RESERVED_11;
        s << ", " << x.RESERVED_12;
        s << ", " << x.RESERVED_13;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_scn_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.RESERVED_00;
        s >> ',' >> x.RESERVED_01;
        s >> ',' >> x.RESERVED_02;
        s >> ',' >> x.RESERVED_03;
        s >> ',' >> x.RESERVED_04;
        s >> ',' >> x.RESERVED_05;
        s >> ',' >> x.RESERVED_06;
        s >> ',' >> x.RESERVED_07;
        s >> ',' >> x.RESERVED_08;
        s >> ',' >> x.RESERVED_09;
        s >> ',' >> x.RESERVED_10;
        s >> ',' >> x.RESERVED_11;
        s >> ',' >> x.RESERVED_12;
        s >> ',' >> x.RESERVED_13;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_string_param
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_string_param<rebind_it> type;
    };

    typedef it iterator_type;

    hk_string_param(it begin, it end, bool dirty=false)
        : param_id(begin)
        , string(begin, end, string_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 10019, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 2064};
    it begin() const { return param_id.begin(); }
    it end() const { return string.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t param_id;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> param_id;
    #endif //DOXYGEN

    std::size_t string_size;
    enum { string_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : ch(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint8_t ch;
        #else
        binary::field<uint8_t, sc_uint8, 0, it> ch;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition string[256];
    #else
    sequence<hk_string_param, 8, 16, it> string;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    hk_string_param& operator=(const hk_string_param<ito>& o) {
        param_id = o.param_id;
        string_size = o.string_size;
        string.clean();
        for(unsigned n=0; n<string_size; ++n){
            string[n].ch = o.string[n].ch;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_string_param<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_string_param<rebind_it> type;
    };

    enum { id_main = 10019, id_sub = 0};

    uint16_t         param_id;
    std::size_t string_size;
    enum { string_max_size = 256 };
    struct sequence_definition {
        uint8_t          ch;
    } string[256];

    hk_string_param()
        : param_id()
    {}

    template<class it>
    hk_string_param(const hk_string_param<it>& o) {
        param_id = o.param_id;
        string_size = o.string.size();
        for(unsigned n=0; n<string_size; ++n){
            string[n].ch = o.string[n].ch;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_string_param<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.param_id;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.string_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.string[n].ch
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_string_param<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.param_id;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.string_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.string_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.string[x.string_size-1].ch)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_time
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_time<rebind_it> type;
    };

    typedef it iterator_type;

    hk_time(it begin, it end, bool dirty=false)
        : systime(begin)
        , year(begin)
        , month(begin)
        , day(begin)
        , hour(begin)
        , minute(begin)
        , second(begin)
        , utc_offset(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 40, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return systime.begin(); }
    it end() const { return utc_offset.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  systime of message in units of unit units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t year;//!<  year 
    #else
    binary::field<uint16_t, sc_uint16, 32, it> year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t month;//!<  month  1 .. 12 
    #else
    binary::field<uint8_t, sc_uint8, 48, it> month;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t day;//!<  day    1 .. 31 
    #else
    binary::field<uint8_t, sc_uint8, 56, it> day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hour;//!<  hour   0 .. 23 
    #else
    binary::field<uint8_t, sc_uint8, 64, it> hour;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t minute;//!<  minute 0 .. 59 
    #else
    binary::field<uint8_t, sc_uint8, 72, it> minute;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t second;//!<  second 0 .. 59 (60 if leap second) 
    #else
    binary::field<uint8_t, sc_uint8, 80, it> second;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t utc_offset;//!<  diff. between localtime and UTC 
    #else
    binary::field<int8_t, sc_int8, 88, it> utc_offset;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    hk_time& operator=(const hk_time<ito>& o) {
        systime = o.systime;
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        utc_offset = o.utc_offset;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_time<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_time<rebind_it> type;
    };

    enum { id_main = 40, id_sub = 0};

    uint32_t         systime;
    uint16_t         year;
    uint8_t          month;
    uint8_t          day;
    uint8_t          hour;
    uint8_t          minute;
    uint8_t          second;
    int8_t           utc_offset;

    hk_time()
        : systime()
        , year()
        , month()
        , day()
        , hour()
        , minute()
        , second()
        , utc_offset()
    {}

    template<class it>
    hk_time(const hk_time<it>& o) {
        systime = o.systime;
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        utc_offset = o.utc_offset;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_time<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.year;
        s << ", " << x.month;
        s << ", " << x.day;
        s << ", " << x.hour;
        s << ", " << x.minute;
        s << ", " << x.second;
        s << ", " << x.utc_offset;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_time<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.year;
        s >> ',' >> x.month;
        s >> ',' >> x.day;
        s >> ',' >> x.hour;
        s >> ',' >> x.minute;
        s >> ',' >> x.second;
        s >> ',' >> x.utc_offset;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct hk_uint64_param
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef hk_uint64_param<rebind_it> type;
    };

    typedef it iterator_type;

    hk_uint64_param(it begin, it end, bool dirty=false)
        : data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 10022, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 20480};
    it begin() const { return data.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : param_id(begin, begin_bit)
            , value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t param_id;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> param_id;
        #endif
        #ifdef DOXYGEN
        uint64_t value;
        #else
        binary::field<uint64_t, sc_uint64, 16, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[256];
    #else
    sequence<hk_uint64_param, 80, 0, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    hk_uint64_param& operator=(const hk_uint64_param<ito>& o) {
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].param_id = o.data[n].param_id;
            data[n].value = o.data[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct hk_uint64_param<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef hk_uint64_param<rebind_it> type;
    };

    enum { id_main = 10022, id_sub = 0};

    std::size_t data_size;
    enum { data_max_size = 256 };
    struct sequence_definition {
        uint16_t         param_id;
        uint64_t         value;
    } data[256];

    hk_uint64_param()
    {}

    template<class it>
    hk_uint64_param(const hk_uint64_param<it>& o) {
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].param_id = o.data[n].param_id;
            data[n].value = o.data[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const hk_uint64_param<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].param_id
            << ", " << x.data[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, hk_uint64_param<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].param_id)
            >> ',' >> (x.data[x.data_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct ht_dbg_data
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef ht_dbg_data<rebind_it> type;
    };

    typedef it iterator_type;

    ht_dbg_data(it begin, it end, bool dirty=false)
        : systime(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 53, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 65568};
    it begin() const { return systime.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 1024 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : i_ber_led(begin, begin_bit)
            , u_apd(begin, begin_bit)
            , w_ber_led(begin, begin_bit)
            , I_APD_DC(begin, begin_bit)
            , minq_max(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t i_ber_led;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> i_ber_led;
        #endif
        #ifdef DOXYGEN
        uint16_t u_apd;
        #else
        binary::field<uint16_t, sc_uint16, 16, it> u_apd;
        #endif
        #ifdef DOXYGEN
        uint16_t w_ber_led;
        #else
        binary::field<uint16_t, sc_uint16, 32, it> w_ber_led;
        #endif
        #ifdef DOXYGEN
        uint16_t I_APD_DC;
        #else
        binary::field<uint16_t, sc_uint15, 48, it> I_APD_DC;
        #endif
        #ifdef DOXYGEN
        uint8_t minq_max;
        #else
        binary::field<uint8_t, sc_bit, 63, it> minq_max;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[1024];
    #else
    sequence<ht_dbg_data, 64, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    ht_dbg_data& operator=(const ht_dbg_data<ito>& o) {
        systime = o.systime;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].i_ber_led = o.data[n].i_ber_led;
            data[n].u_apd = o.data[n].u_apd;
            data[n].w_ber_led = o.data[n].w_ber_led;
            data[n].I_APD_DC = o.data[n].I_APD_DC;
            data[n].minq_max = o.data[n].minq_max;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct ht_dbg_data<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef ht_dbg_data<rebind_it> type;
    };

    enum { id_main = 53, id_sub = 0};

    uint32_t         systime;
    std::size_t data_size;
    enum { data_max_size = 1024 };
    struct sequence_definition {
        uint16_t         i_ber_led;
        uint16_t         u_apd;
        uint16_t         w_ber_led;
        uint16_t         I_APD_DC;
        uint8_t          minq_max;
    } data[1024];

    ht_dbg_data()
        : systime()
    {}

    template<class it>
    ht_dbg_data(const ht_dbg_data<it>& o) {
        systime = o.systime;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].i_ber_led = o.data[n].i_ber_led;
            data[n].u_apd = o.data[n].u_apd;
            data[n].w_ber_led = o.data[n].w_ber_led;
            data[n].I_APD_DC = o.data[n].I_APD_DC;
            data[n].minq_max = o.data[n].minq_max;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const ht_dbg_data<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].i_ber_led
            << ", " << x.data[n].u_apd
            << ", " << x.data[n].w_ber_led
            << ", " << x.data[n].I_APD_DC
            << ", " << x.data[n].minq_max
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, ht_dbg_data<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].i_ber_led)
            >> ',' >> (x.data[x.data_size-1].u_apd)
            >> ',' >> (x.data[x.data_size-1].w_ber_led)
            >> ',' >> (x.data[x.data_size-1].I_APD_DC)
            >> ',' >> (x.data[x.data_size-1].minq_max)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct inclination
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef inclination<rebind_it> type;
    };

    typedef it iterator_type;

    inclination(it begin, it end, bool dirty=false)
        : systime(begin)
        , frame_angle(begin)
        , adc1(begin)
        , adc2(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 26, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return systime.begin(); }
    it end() const { return adc2.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time of external PPS pulse in units of uints.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;//!<  frame angle (same units as laser_shot_*angles) 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t adc1;//!<  output of adc1, belongs to sensitve axis 1 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> adc1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t adc2;//!<  output of adc2, belongs to sensitive axis 2 
    #else
    binary::field<uint16_t, sc_uint16, 80, it> adc2;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    inclination& operator=(const inclination<ito>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        adc1 = o.adc1;
        adc2 = o.adc2;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct inclination<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef inclination<rebind_it> type;
    };

    enum { id_main = 26, id_sub = 0};

    uint32_t         systime;
    uint32_t         frame_angle;
    uint16_t         adc1;
    uint16_t         adc2;

    inclination()
        : systime()
        , frame_angle()
        , adc1()
        , adc2()
    {}

    template<class it>
    inclination(const inclination<it>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        adc1 = o.adc1;
        adc2 = o.adc2;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const inclination<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.frame_angle;
        s << ", " << x.adc1;
        s << ", " << x.adc2;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, inclination<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.adc1;
        s >> ',' >> x.adc2;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct inclination_4axes
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_4axes<rebind_it> type;
    };

    typedef it iterator_type;

    inclination_4axes(it begin, it end, bool dirty=false)
        : systime(begin)
        , frame_angle(begin)
        , adc1(begin)
        , adc2(begin)
        , adc3(begin)
        , adc4(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 26, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return systime.begin(); }
    it end() const { return adc4.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time of external PPS pulse in units of uints.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;//!<  frame angle (same units as laser_shot_*angles) 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t adc1;//!<  output of adc1, belongs to sensitive axis 1 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> adc1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t adc2;//!<  output of adc2, belongs to sensitive axis 2 
    #else
    binary::field<uint16_t, sc_uint16, 80, it> adc2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t adc3;//!<  output of adc2, belongs to sensitive axis 3 
    #else
    binary::field<uint16_t, sc_uint16, 96, it> adc3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t adc4;//!<  output of adc2, belongs to sensitive axis 4 
    #else
    binary::field<uint16_t, sc_uint16, 112, it> adc4;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    inclination_4axes& operator=(const inclination_4axes<ito>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        adc1 = o.adc1;
        adc2 = o.adc2;
        adc3 = o.adc3;
        adc4 = o.adc4;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct inclination_4axes<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_4axes<rebind_it> type;
    };

    enum { id_main = 26, id_sub = 1};

    uint32_t         systime;
    uint32_t         frame_angle;
    uint16_t         adc1;
    uint16_t         adc2;
    uint16_t         adc3;
    uint16_t         adc4;

    inclination_4axes()
        : systime()
        , frame_angle()
        , adc1()
        , adc2()
        , adc3()
        , adc4()
    {}

    template<class it>
    inclination_4axes(const inclination_4axes<it>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        adc1 = o.adc1;
        adc2 = o.adc2;
        adc3 = o.adc3;
        adc4 = o.adc4;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const inclination_4axes<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.frame_angle;
        s << ", " << x.adc1;
        s << ", " << x.adc2;
        s << ", " << x.adc3;
        s << ", " << x.adc4;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, inclination_4axes<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.adc1;
        s >> ',' >> x.adc2;
        s >> ',' >> x.adc3;
        s >> ',' >> x.adc4;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct inclination_device
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_device<rebind_it> type;
    };

    typedef it iterator_type;

    inclination_device(it begin, it end, bool dirty=false)
        : s1(begin)
        , s2(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 6, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 192};
    it begin() const { return s1.begin(); }
    it end() const { return s2.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s1[3];//!<  sensitive axis sensor 1 
    #else
    binary::array<float, 3, sc_float32, 0, it> s1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s2[3];//!<  sensitive axis sensor 2 
    #else
    binary::array<float, 3, sc_float32, 96, it> s2;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    inclination_device& operator=(const inclination_device<ito>& o) {
        for(unsigned n=0; n<3; ++n) s1[n] = o.s1[n];
        for(unsigned n=0; n<3; ++n) s2[n] = o.s2[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct inclination_device<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_device<rebind_it> type;
    };

    enum { id_main = 6, id_sub = 0};

    float            s1[3];
    float            s2[3];

    inclination_device()
        : s1()
        , s2()
    {}

    template<class it>
    inclination_device(const inclination_device<it>& o) {
        for(unsigned n=0; n<3; ++n) s1[n] = o.s1[n];
        for(unsigned n=0; n<3; ++n) s2[n] = o.s2[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const inclination_device<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.s1);
        s << ", "; write_array(s, 3, x.s2);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, inclination_device<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.s1);
        s >> ','; read_array(s, 3, x.s2);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct inclination_device_4axes
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_device_4axes<rebind_it> type;
    };

    typedef it iterator_type;

    inclination_device_4axes(it begin, it end, bool dirty=false)
        : s1(begin)
        , s2(begin)
        , s3(begin)
        , s4(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 6, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 384};
    it begin() const { return s1.begin(); }
    it end() const { return s4.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s1[3];//!<  sensitive axis sensor 1 
    #else
    binary::array<float, 3, sc_float32, 0, it> s1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s2[3];//!<  sensitive axis sensor 2 
    #else
    binary::array<float, 3, sc_float32, 96, it> s2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s3[3];//!<  sensitive axis sensor 3 
    #else
    binary::array<float, 3, sc_float32, 192, it> s3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s4[3];//!<  sensitive axis sensor 4 
    #else
    binary::array<float, 3, sc_float32, 288, it> s4;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    inclination_device_4axes& operator=(const inclination_device_4axes<ito>& o) {
        for(unsigned n=0; n<3; ++n) s1[n] = o.s1[n];
        for(unsigned n=0; n<3; ++n) s2[n] = o.s2[n];
        for(unsigned n=0; n<3; ++n) s3[n] = o.s3[n];
        for(unsigned n=0; n<3; ++n) s4[n] = o.s4[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct inclination_device_4axes<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_device_4axes<rebind_it> type;
    };

    enum { id_main = 6, id_sub = 1};

    float            s1[3];
    float            s2[3];
    float            s3[3];
    float            s4[3];

    inclination_device_4axes()
        : s1()
        , s2()
        , s3()
        , s4()
    {}

    template<class it>
    inclination_device_4axes(const inclination_device_4axes<it>& o) {
        for(unsigned n=0; n<3; ++n) s1[n] = o.s1[n];
        for(unsigned n=0; n<3; ++n) s2[n] = o.s2[n];
        for(unsigned n=0; n<3; ++n) s3[n] = o.s3[n];
        for(unsigned n=0; n<3; ++n) s4[n] = o.s4[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const inclination_device_4axes<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.s1);
        s << ", "; write_array(s, 3, x.s2);
        s << ", "; write_array(s, 3, x.s3);
        s << ", "; write_array(s, 3, x.s4);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, inclination_device_4axes<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.s1);
        s >> ','; read_array(s, 3, x.s2);
        s >> ','; read_array(s, 3, x.s3);
        s >> ','; read_array(s, 3, x.s4);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct inclination_device_4axes_offset
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_device_4axes_offset<rebind_it> type;
    };

    typedef it iterator_type;

    inclination_device_4axes_offset(it begin, it end, bool dirty=false)
        : s1(begin)
        , s2(begin)
        , s3(begin)
        , s4(begin)
        , o1(begin)
        , o2(begin)
        , o3(begin)
        , o4(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 6, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 512};
    it begin() const { return s1.begin(); }
    it end() const { return o4.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s1[3];//!<  sensitive axis sensor 1 
    #else
    binary::array<float, 3, sc_float32, 0, it> s1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s2[3];//!<  sensitive axis sensor 2 
    #else
    binary::array<float, 3, sc_float32, 96, it> s2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s3[3];//!<  sensitive axis sensor 3 
    #else
    binary::array<float, 3, sc_float32, 192, it> s3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float s4[3];//!<  sensitive axis sensor 4 
    #else
    binary::array<float, 3, sc_float32, 288, it> s4;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float o1;//!<  voltage offset sensor 1 
    #else
    binary::field<float, sc_float32, 384, it> o1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float o2;//!<  voltage offset sensor 2 
    #else
    binary::field<float, sc_float32, 416, it> o2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float o3;//!<  voltage offset sensor 3 
    #else
    binary::field<float, sc_float32, 448, it> o3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float o4;//!<  voltage offset sensor 4 
    #else
    binary::field<float, sc_float32, 480, it> o4;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    inclination_device_4axes_offset& operator=(const inclination_device_4axes_offset<ito>& o) {
        for(unsigned n=0; n<3; ++n) s1[n] = o.s1[n];
        for(unsigned n=0; n<3; ++n) s2[n] = o.s2[n];
        for(unsigned n=0; n<3; ++n) s3[n] = o.s3[n];
        for(unsigned n=0; n<3; ++n) s4[n] = o.s4[n];
        o1 = o.o1;
        o2 = o.o2;
        o3 = o.o3;
        o4 = o.o4;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct inclination_device_4axes_offset<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_device_4axes_offset<rebind_it> type;
    };

    enum { id_main = 6, id_sub = 2};

    float            s1[3];
    float            s2[3];
    float            s3[3];
    float            s4[3];
    float            o1;
    float            o2;
    float            o3;
    float            o4;

    inclination_device_4axes_offset()
        : s1()
        , s2()
        , s3()
        , s4()
        , o1()
        , o2()
        , o3()
        , o4()
    {}

    template<class it>
    inclination_device_4axes_offset(const inclination_device_4axes_offset<it>& o) {
        for(unsigned n=0; n<3; ++n) s1[n] = o.s1[n];
        for(unsigned n=0; n<3; ++n) s2[n] = o.s2[n];
        for(unsigned n=0; n<3; ++n) s3[n] = o.s3[n];
        for(unsigned n=0; n<3; ++n) s4[n] = o.s4[n];
        o1 = o.o1;
        o2 = o.o2;
        o3 = o.o3;
        o4 = o.o4;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const inclination_device_4axes_offset<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 3, x.s1);
        s << ", "; write_array(s, 3, x.s2);
        s << ", "; write_array(s, 3, x.s3);
        s << ", "; write_array(s, 3, x.s4);
        s << ", " << x.o1;
        s << ", " << x.o2;
        s << ", " << x.o3;
        s << ", " << x.o4;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, inclination_device_4axes_offset<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 3, x.s1);
        s >> ','; read_array(s, 3, x.s2);
        s >> ','; read_array(s, 3, x.s3);
        s >> ','; read_array(s, 3, x.s4);
        s >> ',' >> x.o1;
        s >> ',' >> x.o2;
        s >> ',' >> x.o3;
        s >> ',' >> x.o4;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! static inclination sensor

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct inclination_static
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_static<rebind_it> type;
    };

    typedef it iterator_type;

    inclination_static(it begin, it end, bool dirty=false)
        : systime(begin)
        , angle_axis_0(begin)
        , angle_axis_1(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 79, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return systime.begin(); }
    it end() const { return angle_axis_1.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  approximate systime when the sample was taken in units of uints.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float angle_axis_0;//!<  angle of first axis measured in degrees 
    #else
    binary::field<float, sc_float32, 32, it> angle_axis_0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float angle_axis_1;//!<  angle of second axis measured in degrees 
    #else
    binary::field<float, sc_float32, 64, it> angle_axis_1;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    inclination_static& operator=(const inclination_static<ito>& o) {
        systime = o.systime;
        angle_axis_0 = o.angle_axis_0;
        angle_axis_1 = o.angle_axis_1;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct inclination_static<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef inclination_static<rebind_it> type;
    };

    enum { id_main = 79, id_sub = 0};

    uint32_t         systime;
    float            angle_axis_0;
    float            angle_axis_1;

    inclination_static()
        : systime()
        , angle_axis_0()
        , angle_axis_1()
    {}

    template<class it>
    inclination_static(const inclination_static<it>& o) {
        systime = o.systime;
        angle_axis_0 = o.angle_axis_0;
        angle_axis_1 = o.angle_axis_1;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const inclination_static<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.angle_axis_0;
        s << ", " << x.angle_axis_1;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, inclination_static<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.angle_axis_0;
        s >> ',' >> x.angle_axis_1;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_echo
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_echo<rebind_it> type;
    };

    typedef it iterator_type;

    laser_echo(it begin, it end, bool dirty=false)
        : range(begin)
        , amplitude(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 11, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 48};
    it begin() const { return range.begin(); }
    it end() const { return amplitude.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t range;
    #else
    binary::field<int32_t, sc_int32, 0, it> range;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t amplitude;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> amplitude;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_echo& operator=(const laser_echo<ito>& o) {
        range = o.range;
        amplitude = o.amplitude;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_echo<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_echo<rebind_it> type;
    };

    enum { id_main = 11, id_sub = 0};

    int32_t          range;
    uint16_t         amplitude;

    laser_echo()
        : range()
        , amplitude()
    {}

    template<class it>
    laser_echo(const laser_echo<it>& o) {
        range = o.range;
        amplitude = o.amplitude;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_echo<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range;
        s << ", " << x.amplitude;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_echo<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range;
        s >> ',' >> x.amplitude;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_echo_qual
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_echo_qual<rebind_it> type;
    };

    typedef it iterator_type;

    laser_echo_qual(it begin, it end, bool dirty=false)
        : range(begin)
        , amplitude(begin)
        , flags(begin)
        , quality(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 11, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 64};
    it begin() const { return range.begin(); }
    it end() const { return quality.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t range;
    #else
    binary::field<int32_t, sc_int32, 0, it> range;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t amplitude;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> amplitude;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t flags;
    #else
    binary::field<uint8_t, sc_uint8, 48, it> flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t quality;
    #else
    binary::field<uint8_t, sc_uint8, 56, it> quality;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_echo_qual& operator=(const laser_echo_qual<ito>& o) {
        range = o.range;
        amplitude = o.amplitude;
        flags = o.flags;
        quality = o.quality;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_echo_qual<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_echo_qual<rebind_it> type;
    };

    enum { id_main = 11, id_sub = 1};

    int32_t          range;
    uint16_t         amplitude;
    uint8_t          flags;
    uint8_t          quality;

    laser_echo_qual()
        : range()
        , amplitude()
        , flags()
        , quality()
    {}

    template<class it>
    laser_echo_qual(const laser_echo_qual<it>& o) {
        range = o.range;
        amplitude = o.amplitude;
        flags = o.flags;
        quality = o.quality;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_echo_qual<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range;
        s << ", " << x.amplitude;
        s << ", " << x.flags;
        s << ", " << x.quality;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_echo_qual<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range;
        s >> ',' >> x.amplitude;
        s >> ',' >> x.flags;
        s >> ',' >> x.quality;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_echo_sw
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_echo_sw<rebind_it> type;
    };

    typedef it iterator_type;

    laser_echo_sw(it begin, it end, bool dirty=false)
        : range(begin)
        , amplitude(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 28, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 48};
    it begin() const { return range.begin(); }
    it end() const { return amplitude.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t range;
    #else
    binary::field<int32_t, sc_int32, 0, it> range;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t amplitude;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> amplitude;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_echo_sw& operator=(const laser_echo_sw<ito>& o) {
        range = o.range;
        amplitude = o.amplitude;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_echo_sw<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_echo_sw<rebind_it> type;
    };

    enum { id_main = 28, id_sub = 0};

    int32_t          range;
    uint16_t         amplitude;

    laser_echo_sw()
        : range()
        , amplitude()
    {}

    template<class it>
    laser_echo_sw(const laser_echo_sw<it>& o) {
        range = o.range;
        amplitude = o.amplitude;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_echo_sw<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range;
        s << ", " << x.amplitude;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_echo_sw<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range;
        s >> ',' >> x.amplitude;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot(it begin, it end, bool dirty=false)
        : systime(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32};
    it begin() const { return systime.begin(); }
    it end() const { return systime.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  time of laser shot in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot& operator=(const laser_shot<ito>& o) {
        systime = o.systime;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot<rebind_it> type;
    };

    enum { id_main = 10, id_sub = 0};

    uint32_t         systime;

    laser_shot()
        : systime()
    {}

    template<class it>
    laser_shot(const laser_shot<it>& o) {
        systime = o.systime;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot_1angle
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_1angle<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot_1angle(it begin, it end, bool dirty=false)
        : systime(begin)
        , line_angle(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 64};
    it begin() const { return systime.begin(); }
    it end() const { return line_angle.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  time of laser shot in units of time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;//!<  line angle 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_angle;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot_1angle& operator=(const laser_shot_1angle<ito>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot_1angle<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_1angle<rebind_it> type;
    };

    enum { id_main = 10, id_sub = 1};

    uint32_t         systime;
    uint32_t         line_angle;

    laser_shot_1angle()
        : systime()
        , line_angle()
    {}

    template<class it>
    laser_shot_1angle(const laser_shot_1angle<it>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot_1angle<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.line_angle;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot_1angle<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.line_angle;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot_2angles
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_2angles<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot_2angles(it begin, it end, bool dirty=false)
        : systime(begin)
        , line_angle(begin)
        , frame_angle(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 10, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return systime.begin(); }
    it end() const { return frame_angle.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  time of laser shot in units of time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;//!<  line angle 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;//!<  frame angle 
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_angle;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot_2angles& operator=(const laser_shot_2angles<ito>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot_2angles<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_2angles<rebind_it> type;
    };

    enum { id_main = 10, id_sub = 2};

    uint32_t         systime;
    uint32_t         line_angle;
    uint32_t         frame_angle;

    laser_shot_2angles()
        : systime()
        , line_angle()
        , frame_angle()
    {}

    template<class it>
    laser_shot_2angles(const laser_shot_2angles<it>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot_2angles<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot_2angles<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot_2angles_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_2angles_hr<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot_2angles_hr(it begin, it end, bool dirty=false)
        : systime(begin)
        , line_angle(begin)
        , frame_angle(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 67, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return systime.begin(); }
    it end() const { return frame_angle.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;//!<  time of laser shot in units of units.time_unit_hi_prec 
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;
    #else
    binary::field<uint32_t, sc_uint24, 72, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> frame_angle;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot_2angles_hr& operator=(const laser_shot_2angles_hr<ito>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot_2angles_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_2angles_hr<rebind_it> type;
    };

    enum { id_main = 67, id_sub = 0};

    uint64_t         systime;
    uint32_t         line_angle;
    uint32_t         frame_angle;

    laser_shot_2angles_hr()
        : systime()
        , line_angle()
        , frame_angle()
    {}

    template<class it>
    laser_shot_2angles_hr(const laser_shot_2angles_hr<it>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot_2angles_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot_2angles_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot_2angles_rad
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_2angles_rad<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot_2angles_rad(it begin, it end, bool dirty=false)
        : systime(begin)
        , line_angle(begin)
        , frame_angle(begin)
        , backgnd_rad(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 20, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 112};
    it begin() const { return systime.begin(); }
    it end() const { return backgnd_rad.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  time of laser shot in units of time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;//!<  line angle 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;//!<  frame angle 
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t backgnd_rad;//!<  background radiation 
    #else
    binary::field<uint16_t, sc_uint16, 96, it> backgnd_rad;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot_2angles_rad& operator=(const laser_shot_2angles_rad<ito>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        backgnd_rad = o.backgnd_rad;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot_2angles_rad<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_2angles_rad<rebind_it> type;
    };

    enum { id_main = 20, id_sub = 0};

    uint32_t         systime;
    uint32_t         line_angle;
    uint32_t         frame_angle;
    uint16_t         backgnd_rad;

    laser_shot_2angles_rad()
        : systime()
        , line_angle()
        , frame_angle()
        , backgnd_rad()
    {}

    template<class it>
    laser_shot_2angles_rad(const laser_shot_2angles_rad<it>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        backgnd_rad = o.backgnd_rad;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot_2angles_rad<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
        s << ", " << x.backgnd_rad;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot_2angles_rad<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.backgnd_rad;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot_3angles
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_3angles<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot_3angles(it begin, it end, bool dirty=false)
        : systime(begin)
        , line_angle(begin)
        , line_angle_r0(begin)
        , line_angle_r1(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50010, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return systime.begin(); }
    it end() const { return line_angle_r1.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle_r0;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> line_angle_r0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle_r1;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> line_angle_r1;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot_3angles& operator=(const laser_shot_3angles<ito>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        line_angle_r0 = o.line_angle_r0;
        line_angle_r1 = o.line_angle_r1;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot_3angles<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_3angles<rebind_it> type;
    };

    enum { id_main = 50010, id_sub = 0};

    uint32_t         systime;
    uint32_t         line_angle;
    uint32_t         line_angle_r0;
    uint32_t         line_angle_r1;

    laser_shot_3angles()
        : systime()
        , line_angle()
        , line_angle_r0()
        , line_angle_r1()
    {}

    template<class it>
    laser_shot_3angles(const laser_shot_3angles<it>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        line_angle_r0 = o.line_angle_r0;
        line_angle_r1 = o.line_angle_r1;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot_3angles<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.line_angle;
        s << ", " << x.line_angle_r0;
        s << ", " << x.line_angle_r1;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot_3angles<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.line_angle_r0;
        s >> ',' >> x.line_angle_r1;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot_6angles
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_6angles<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot_6angles(it begin, it end, bool dirty=false)
        : systime(begin)
        , line_angle(begin)
        , frame_angle(begin)
        , line_angle_r0(begin)
        , line_angle_r1(begin)
        , frame_angle_r0(begin)
        , frame_angle_r1(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50011, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 224};
    it begin() const { return systime.begin(); }
    it end() const { return frame_angle_r1.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle_r0;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> line_angle_r0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle_r1;
    #else
    binary::field<uint32_t, sc_uint32, 128, it> line_angle_r1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle_r0;
    #else
    binary::field<uint32_t, sc_uint32, 160, it> frame_angle_r0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle_r1;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> frame_angle_r1;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot_6angles& operator=(const laser_shot_6angles<ito>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        line_angle_r0 = o.line_angle_r0;
        line_angle_r1 = o.line_angle_r1;
        frame_angle_r0 = o.frame_angle_r0;
        frame_angle_r1 = o.frame_angle_r1;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot_6angles<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_6angles<rebind_it> type;
    };

    enum { id_main = 50011, id_sub = 0};

    uint32_t         systime;
    uint32_t         line_angle;
    uint32_t         frame_angle;
    uint32_t         line_angle_r0;
    uint32_t         line_angle_r1;
    uint32_t         frame_angle_r0;
    uint32_t         frame_angle_r1;

    laser_shot_6angles()
        : systime()
        , line_angle()
        , frame_angle()
        , line_angle_r0()
        , line_angle_r1()
        , frame_angle_r0()
        , frame_angle_r1()
    {}

    template<class it>
    laser_shot_6angles(const laser_shot_6angles<it>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        line_angle_r0 = o.line_angle_r0;
        line_angle_r1 = o.line_angle_r1;
        frame_angle_r0 = o.frame_angle_r0;
        frame_angle_r1 = o.frame_angle_r1;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot_6angles<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
        s << ", " << x.line_angle_r0;
        s << ", " << x.line_angle_r1;
        s << ", " << x.frame_angle_r0;
        s << ", " << x.frame_angle_r1;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot_6angles<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.line_angle_r0;
        s >> ',' >> x.line_angle_r1;
        s >> ',' >> x.frame_angle_r0;
        s >> ',' >> x.frame_angle_r1;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot_6angles_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_6angles_hr<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot_6angles_hr(it begin, it end, bool dirty=false)
        : systime(begin)
        , line_angle(begin)
        , frame_angle(begin)
        , line_angle_r0(begin)
        , line_angle_r1(begin)
        , frame_angle_r0(begin)
        , frame_angle_r1(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50012, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 256};
    it begin() const { return systime.begin(); }
    it end() const { return frame_angle_r1.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;
    #else
    binary::field<uint32_t, sc_uint24, 72, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle_r0;
    #else
    binary::field<uint32_t, sc_uint32, 128, it> line_angle_r0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle_r1;
    #else
    binary::field<uint32_t, sc_uint32, 160, it> line_angle_r1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle_r0;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> frame_angle_r0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle_r1;
    #else
    binary::field<uint32_t, sc_uint32, 224, it> frame_angle_r1;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot_6angles_hr& operator=(const laser_shot_6angles_hr<ito>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        line_angle_r0 = o.line_angle_r0;
        line_angle_r1 = o.line_angle_r1;
        frame_angle_r0 = o.frame_angle_r0;
        frame_angle_r1 = o.frame_angle_r1;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot_6angles_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_6angles_hr<rebind_it> type;
    };

    enum { id_main = 50012, id_sub = 0};

    uint64_t         systime;
    uint32_t         line_angle;
    uint32_t         frame_angle;
    uint32_t         line_angle_r0;
    uint32_t         line_angle_r1;
    uint32_t         frame_angle_r0;
    uint32_t         frame_angle_r1;

    laser_shot_6angles_hr()
        : systime()
        , line_angle()
        , frame_angle()
        , line_angle_r0()
        , line_angle_r1()
        , frame_angle_r0()
        , frame_angle_r1()
    {}

    template<class it>
    laser_shot_6angles_hr(const laser_shot_6angles_hr<it>& o) {
        systime = o.systime;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        line_angle_r0 = o.line_angle_r0;
        line_angle_r1 = o.line_angle_r1;
        frame_angle_r0 = o.frame_angle_r0;
        frame_angle_r1 = o.frame_angle_r1;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot_6angles_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
        s << ", " << x.line_angle_r0;
        s << ", " << x.line_angle_r1;
        s << ", " << x.frame_angle_r0;
        s << ", " << x.frame_angle_r1;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot_6angles_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.line_angle_r0;
        s >> ',' >> x.line_angle_r1;
        s >> ',' >> x.frame_angle_r0;
        s >> ',' >> x.frame_angle_r1;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot_rad
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_rad<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot_rad(it begin, it end, bool dirty=false)
        : systime(begin)
        , backgnd_rad(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 102, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 48};
    it begin() const { return systime.begin(); }
    it end() const { return backgnd_rad.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  time of laser shot in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t backgnd_rad;//!<  background radiation 
    #else
    binary::field<uint16_t, sc_uint16, 32, it> backgnd_rad;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot_rad& operator=(const laser_shot_rad<ito>& o) {
        systime = o.systime;
        backgnd_rad = o.backgnd_rad;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot_rad<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_rad<rebind_it> type;
    };

    enum { id_main = 102, id_sub = 0};

    uint32_t         systime;
    uint16_t         backgnd_rad;

    laser_shot_rad()
        : systime()
        , backgnd_rad()
    {}

    template<class it>
    laser_shot_rad(const laser_shot_rad<it>& o) {
        systime = o.systime;
        backgnd_rad = o.backgnd_rad;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot_rad<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.backgnd_rad;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot_rad<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.backgnd_rad;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct laser_shot_utctime_origin_direction
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_utctime_origin_direction<rebind_it> type;
    };

    typedef it iterator_type;

    laser_shot_utctime_origin_direction(it begin, it end, bool dirty=false)
        : exttime(begin)
        , is_int_time(begin)
        , origin(begin)
        , direction(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 112, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 192};
    it begin() const { return exttime.begin(); }
    it end() const { return direction.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t exttime;//!<  time of laser shot in units of units_4.time_unit_exttime since units_4.epoch_exttime  in case units_4.epoch_exttime is UNKNOWN, exttime refers to last midnight 
    #else
    binary::field<uint64_t, sc_uint64, 0, it> exttime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t is_int_time;//!<  if > 0:  time is systime_hr instead of exttime 
    #else
    binary::field<uint8_t, sc_uint8, 64, it> is_int_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t origin[3];//!<  origin of laser beam in units of 2**-14 
    #else
    binary::array<int16_t, 3, sc_int16, 72, it> origin;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t direction[3];//!<  direction of laser beam in units of 2**-22 
    #else
    binary::array<int32_t, 3, sc_int24, 120, it> direction;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    laser_shot_utctime_origin_direction& operator=(const laser_shot_utctime_origin_direction<ito>& o) {
        exttime = o.exttime;
        is_int_time = o.is_int_time;
        for(unsigned n=0; n<3; ++n) origin[n] = o.origin[n];
        for(unsigned n=0; n<3; ++n) direction[n] = o.direction[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct laser_shot_utctime_origin_direction<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef laser_shot_utctime_origin_direction<rebind_it> type;
    };

    enum { id_main = 112, id_sub = 0};

    uint64_t         exttime;
    uint8_t          is_int_time;
    int16_t          origin[3];
    int32_t          direction[3];

    laser_shot_utctime_origin_direction()
        : exttime()
        , is_int_time()
        , origin()
        , direction()
    {}

    template<class it>
    laser_shot_utctime_origin_direction(const laser_shot_utctime_origin_direction<it>& o) {
        exttime = o.exttime;
        is_int_time = o.is_int_time;
        for(unsigned n=0; n<3; ++n) origin[n] = o.origin[n];
        for(unsigned n=0; n<3; ++n) direction[n] = o.direction[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const laser_shot_utctime_origin_direction<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.exttime;
        s << ", " << x.is_int_time;
        s << ", "; write_array(s, 3, x.origin);
        s << ", "; write_array(s, 3, x.direction);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, laser_shot_utctime_origin_direction<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.exttime;
        s >> ',' >> x.is_int_time;
        s >> ','; read_array(s, 3, x.origin);
        s >> ','; read_array(s, 3, x.direction);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct line_start
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef line_start<rebind_it> type;
    };

    typedef it iterator_type;

    line_start(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 16, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    line_start& operator=(const line_start<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct line_start<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef line_start<rebind_it> type;
    };

    enum { id_main = 16, id_sub = 0};


    line_start()
    {}

    template<class it>
    line_start(const line_start<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const line_start<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, line_start<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! start of a line scan in down direction

//! before data packets belonging to this line
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan, startcond</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct line_start_dn
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_dn<rebind_it> type;
    };

    typedef it iterator_type;

    line_start_dn(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 25, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    line_start_dn& operator=(const line_start_dn<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct line_start_dn<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_dn<rebind_it> type;
    };

    enum { id_main = 25, id_sub = 0};


    line_start_dn()
    {}

    template<class it>
    line_start_dn(const line_start_dn<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const line_start_dn<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, line_start_dn<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! start of the 1 segment of a scan line

//! before data packets belonging to this line
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan, startcond</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct line_start_segment_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_segment_1<rebind_it> type;
    };

    typedef it iterator_type;

    line_start_segment_1(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 99, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    line_start_segment_1& operator=(const line_start_segment_1<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct line_start_segment_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_segment_1<rebind_it> type;
    };

    enum { id_main = 99, id_sub = 0};


    line_start_segment_1()
    {}

    template<class it>
    line_start_segment_1(const line_start_segment_1<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const line_start_segment_1<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, line_start_segment_1<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! start of the 2 segment of a scan line

//! before data packets belonging to this line
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan, startcond</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct line_start_segment_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_segment_2<rebind_it> type;
    };

    typedef it iterator_type;

    line_start_segment_2(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 100, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    line_start_segment_2& operator=(const line_start_segment_2<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct line_start_segment_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_segment_2<rebind_it> type;
    };

    enum { id_main = 100, id_sub = 0};


    line_start_segment_2()
    {}

    template<class it>
    line_start_segment_2(const line_start_segment_2<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const line_start_segment_2<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, line_start_segment_2<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! start of the 3 segment of a scan line

//! before data packets belonging to this line
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan, startcond</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct line_start_segment_3
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_segment_3<rebind_it> type;
    };

    typedef it iterator_type;

    line_start_segment_3(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 101, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    line_start_segment_3& operator=(const line_start_segment_3<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct line_start_segment_3<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_segment_3<rebind_it> type;
    };

    enum { id_main = 101, id_sub = 0};


    line_start_segment_3()
    {}

    template<class it>
    line_start_segment_3(const line_start_segment_3<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const line_start_segment_3<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, line_start_segment_3<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! start of a line scan in up direction

//! before data packets belonging to this line
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan, startcond</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct line_start_up
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_up<rebind_it> type;
    };

    typedef it iterator_type;

    line_start_up(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 24, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    line_start_up& operator=(const line_start_up<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct line_start_up<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef line_start_up<rebind_it> type;
    };

    enum { id_main = 24, id_sub = 0};


    line_start_up()
    {}

    template<class it>
    line_start_up(const line_start_up<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const line_start_up<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, line_start_up<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! end of line scan

//! sent, when a scan with changing frame angle escapes the
//! specified frame range
//! after data packets belonging to this line
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct line_stop
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef line_stop<rebind_it> type;
    };

    typedef it iterator_type;

    line_stop(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 17, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    line_stop& operator=(const line_stop<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct line_stop<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef line_stop<rebind_it> type;
    };

    enum { id_main = 17, id_sub = 0};


    line_stop()
    {}

    template<class it>
    line_stop(const line_stop<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const line_stop<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, line_stop<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct m_sequence_mta
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef m_sequence_mta<rebind_it> type;
    };

    typedef it iterator_type;

    m_sequence_mta(it begin, it end, bool dirty=false)
        : length(begin)
        , seq(begin, end, seq_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 83, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1040};
    it begin() const { return length.begin(); }
    it end() const { return seq.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t length;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> length;
    #endif //DOXYGEN

    std::size_t seq_size;
    enum { seq_max_size = 1024 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : val(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint8_t val;
        #else
        binary::field<uint8_t, sc_bit, 0, it> val;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition seq[1024];
    #else
    sequence<m_sequence_mta, 1, 16, it> seq;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    m_sequence_mta& operator=(const m_sequence_mta<ito>& o) {
        length = o.length;
        seq_size = o.seq_size;
        seq.clean();
        for(unsigned n=0; n<seq_size; ++n){
            seq[n].val = o.seq[n].val;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct m_sequence_mta<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef m_sequence_mta<rebind_it> type;
    };

    enum { id_main = 83, id_sub = 0};

    uint16_t         length;
    std::size_t seq_size;
    enum { seq_max_size = 1024 };
    struct sequence_definition {
        uint8_t          val;
    } seq[1024];

    m_sequence_mta()
        : length()
    {}

    template<class it>
    m_sequence_mta(const m_sequence_mta<it>& o) {
        length = o.length;
        seq_size = o.seq.size();
        for(unsigned n=0; n<seq_size; ++n){
            seq[n].val = o.seq[n].val;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const m_sequence_mta<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.length;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.seq_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.seq[n].val
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, m_sequence_mta<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.length;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.seq_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.seq_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.seq[x.seq_size-1].val)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct magnetic_field
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef magnetic_field<rebind_it> type;
    };

    typedef it iterator_type;

    magnetic_field(it begin, it end, bool dirty=false)
        : systime(begin)
        , frame_angle(begin)
        , adc_x(begin)
        , adc_y(begin)
        , adc_z(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 44, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 112};
    it begin() const { return systime.begin(); }
    it end() const { return adc_z.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t adc_x;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> adc_x;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t adc_y;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> adc_y;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t adc_z;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> adc_z;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    magnetic_field& operator=(const magnetic_field<ito>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        adc_x = o.adc_x;
        adc_y = o.adc_y;
        adc_z = o.adc_z;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct magnetic_field<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef magnetic_field<rebind_it> type;
    };

    enum { id_main = 44, id_sub = 0};

    uint32_t         systime;
    uint32_t         frame_angle;
    uint16_t         adc_x;
    uint16_t         adc_y;
    uint16_t         adc_z;

    magnetic_field()
        : systime()
        , frame_angle()
        , adc_x()
        , adc_y()
        , adc_z()
    {}

    template<class it>
    magnetic_field(const magnetic_field<it>& o) {
        systime = o.systime;
        frame_angle = o.frame_angle;
        adc_x = o.adc_x;
        adc_y = o.adc_y;
        adc_z = o.adc_z;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const magnetic_field<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.frame_angle;
        s << ", " << x.adc_x;
        s << ", " << x.adc_y;
        s << ", " << x.adc_z;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, magnetic_field<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.adc_x;
        s >> ',' >> x.adc_y;
        s >> ',' >> x.adc_z;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! measurement has started

//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan, startcond</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct meas_start
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef meas_start<rebind_it> type;
    };

    typedef it iterator_type;

    meas_start(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 31, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    meas_start& operator=(const meas_start<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct meas_start<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef meas_start<rebind_it> type;
    };

    enum { id_main = 31, id_sub = 0};


    meas_start()
    {}

    template<class it>
    meas_start(const meas_start<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const meas_start<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, meas_start<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! measurement has stopped

//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct meas_stop
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef meas_stop<rebind_it> type;
    };

    typedef it iterator_type;

    meas_stop(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 32, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    meas_stop& operator=(const meas_stop<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct meas_stop<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef meas_stop<rebind_it> type;
    };

    enum { id_main = 32, id_sub = 0};


    meas_stop()
    {}

    template<class it>
    meas_stop(const meas_stop<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const meas_stop<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, meas_stop<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! current setting of subdivider for monitoring data stream

//! For explanation please read the user manual of scanner device
//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct monitoring_info
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef monitoring_info<rebind_it> type;
    };

    typedef it iterator_type;

    monitoring_info(it begin, it end, bool dirty=false)
        : msm_line(begin)
        , msm_frame(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 39, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32};
    it begin() const { return msm_line.begin(); }
    it end() const { return msm_frame.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t msm_line;//!<  subdivider for measurements within scan line 
    #else
    binary::field<uint16_t, sc_uint16, 0, it> msm_line;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t msm_frame;//!<  subdivider for scan lines within frames 
    #else
    binary::field<uint16_t, sc_uint16, 16, it> msm_frame;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    monitoring_info& operator=(const monitoring_info<ito>& o) {
        msm_line = o.msm_line;
        msm_frame = o.msm_frame;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct monitoring_info<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef monitoring_info<rebind_it> type;
    };

    enum { id_main = 39, id_sub = 0};

    uint16_t         msm_line;
    uint16_t         msm_frame;

    monitoring_info()
        : msm_line()
        , msm_frame()
    {}

    template<class it>
    monitoring_info(const monitoring_info<it>& o) {
        msm_line = o.msm_line;
        msm_frame = o.msm_frame;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const monitoring_info<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.msm_line;
        s << ", " << x.msm_frame;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, monitoring_info<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.msm_line;
        s >> ',' >> x.msm_frame;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! default parameters for MTA processing

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct mta_settings
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef mta_settings<rebind_it> type;
    };

    typedef it iterator_type;

    mta_settings(it begin, it end, bool dirty=false)
        : zone(begin)
        , gate_low(begin)
        , gate_high(begin)
        , zone_width(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 74, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 104};
    it begin() const { return zone.begin(); }
    it end() const { return zone_width.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t zone;//!<  user requested MTA zone for data analysis. 
    #else
    binary::field<uint8_t, sc_uint8, 0, it> zone;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gate_low;//!<  lower range gate in meters, valid if zone == 0 
    #else
    binary::field<float, sc_float32, 8, it> gate_low;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gate_high;//!<  upper range gate in meters, valid if zone == 0 
    #else
    binary::field<float, sc_float32, 40, it> gate_high;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float zone_width;//!<  width of the multiple time around zones in meter 
    #else
    binary::field<float, sc_float32, 72, it> zone_width;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    mta_settings& operator=(const mta_settings<ito>& o) {
        zone = o.zone;
        gate_low = o.gate_low;
        gate_high = o.gate_high;
        zone_width = o.zone_width;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct mta_settings<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef mta_settings<rebind_it> type;
    };

    enum { id_main = 74, id_sub = 0};

    uint8_t          zone;
    float            gate_low;
    float            gate_high;
    float            zone_width;

    mta_settings()
        : zone()
        , gate_low()
        , gate_high()
        , zone_width()
    {}

    template<class it>
    mta_settings(const mta_settings<it>& o) {
        zone = o.zone;
        gate_low = o.gate_low;
        gate_high = o.gate_high;
        zone_width = o.zone_width;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const mta_settings<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.zone;
        s << ", " << x.gate_low;
        s << ", " << x.gate_high;
        s << ", " << x.zone_width;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, mta_settings<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.zone;
        s >> ',' >> x.gate_low;
        s >> ',' >> x.gate_high;
        s >> ',' >> x.zone_width;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! default parameters for MTA processing

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct mta_settings_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef mta_settings_1<rebind_it> type;
    };

    typedef it iterator_type;

    mta_settings_1(it begin, it end, bool dirty=false)
        : zone(begin)
        , gate_low(begin)
        , gate_high(begin)
        , zone_width(begin)
        , modulation_depth(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 81, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 136};
    it begin() const { return zone.begin(); }
    it end() const { return modulation_depth.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t zone;//!<  user requested MTA zone for data analysis. 
    #else
    binary::field<uint8_t, sc_uint8, 0, it> zone;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gate_low;//!<  lower range gate in meters, valid if zone == 0 
    #else
    binary::field<float, sc_float32, 8, it> gate_low;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gate_high;//!<  upper range gate in meters, valid if zone == 0 
    #else
    binary::field<float, sc_float32, 40, it> gate_high;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float zone_width;//!<  width of the multiple time around zones in meter 
    #else
    binary::field<float, sc_float32, 72, it> zone_width;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float modulation_depth;//!<  modulation of shot phase in meter 
    #else
    binary::field<float, sc_float32, 104, it> modulation_depth;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    mta_settings_1& operator=(const mta_settings_1<ito>& o) {
        zone = o.zone;
        gate_low = o.gate_low;
        gate_high = o.gate_high;
        zone_width = o.zone_width;
        modulation_depth = o.modulation_depth;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct mta_settings_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef mta_settings_1<rebind_it> type;
    };

    enum { id_main = 81, id_sub = 0};

    uint8_t          zone;
    float            gate_low;
    float            gate_high;
    float            zone_width;
    float            modulation_depth;

    mta_settings_1()
        : zone()
        , gate_low()
        , gate_high()
        , zone_width()
        , modulation_depth()
    {}

    template<class it>
    mta_settings_1(const mta_settings_1<it>& o) {
        zone = o.zone;
        gate_low = o.gate_low;
        gate_high = o.gate_high;
        zone_width = o.zone_width;
        modulation_depth = o.modulation_depth;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const mta_settings_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.zone;
        s << ", " << x.gate_low;
        s << ", " << x.gate_high;
        s << ", " << x.zone_width;
        s << ", " << x.modulation_depth;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, mta_settings_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.zone;
        s >> ',' >> x.gate_low;
        s >> ',' >> x.gate_high;
        s >> ',' >> x.zone_width;
        s >> ',' >> x.modulation_depth;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! default parameters for MTA processing

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct mta_settings_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef mta_settings_2<rebind_it> type;
    };

    typedef it iterator_type;

    mta_settings_2(it begin, it end, bool dirty=false)
        : zone(begin)
        , gate_low(begin)
        , gate_high(begin)
        , zone_width(begin)
        , modulation_depth(begin)
        , modulation_depth_dithering(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 81, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 168};
    it begin() const { return zone.begin(); }
    it end() const { return modulation_depth_dithering.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t zone;//!<  user requested MTA zone for data analysis. 
    #else
    binary::field<uint8_t, sc_uint8, 0, it> zone;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gate_low;//!<  lower range gate in meters, valid if zone == 0 
    #else
    binary::field<float, sc_float32, 8, it> gate_low;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gate_high;//!<  upper range gate in meters, valid if zone == 0 
    #else
    binary::field<float, sc_float32, 40, it> gate_high;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float zone_width;//!<  width of the multiple time around zones in meter 
    #else
    binary::field<float, sc_float32, 72, it> zone_width;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float modulation_depth;//!<  depth of pulse position modulation in meter 
    #else
    binary::field<float, sc_float32, 104, it> modulation_depth;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float modulation_depth_dithering;//!<  depth of dithering in meter 
    #else
    binary::field<float, sc_float32, 136, it> modulation_depth_dithering;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    mta_settings_2& operator=(const mta_settings_2<ito>& o) {
        zone = o.zone;
        gate_low = o.gate_low;
        gate_high = o.gate_high;
        zone_width = o.zone_width;
        modulation_depth = o.modulation_depth;
        modulation_depth_dithering = o.modulation_depth_dithering;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct mta_settings_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef mta_settings_2<rebind_it> type;
    };

    enum { id_main = 81, id_sub = 1};

    uint8_t          zone;
    float            gate_low;
    float            gate_high;
    float            zone_width;
    float            modulation_depth;
    float            modulation_depth_dithering;

    mta_settings_2()
        : zone()
        , gate_low()
        , gate_high()
        , zone_width()
        , modulation_depth()
        , modulation_depth_dithering()
    {}

    template<class it>
    mta_settings_2(const mta_settings_2<it>& o) {
        zone = o.zone;
        gate_low = o.gate_low;
        gate_high = o.gate_high;
        zone_width = o.zone_width;
        modulation_depth = o.modulation_depth;
        modulation_depth_dithering = o.modulation_depth_dithering;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const mta_settings_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.zone;
        s << ", " << x.gate_low;
        s << ", " << x.gate_high;
        s << ", " << x.zone_width;
        s << ", " << x.modulation_depth;
        s << ", " << x.modulation_depth_dithering;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, mta_settings_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.zone;
        s >> ',' >> x.gate_low;
        s >> ',' >> x.gate_high;
        s >> ',' >> x.zone_width;
        s >> ',' >> x.modulation_depth;
        s >> ',' >> x.modulation_depth_dithering;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! default parameters for MTA processing

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct mta_settings_3
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef mta_settings_3<rebind_it> type;
    };

    typedef it iterator_type;

    mta_settings_3(it begin, it end, bool dirty=false)
        : zone(begin)
        , gate_low(begin)
        , gate_high(begin)
        , zone_width(begin)
        , modulation_depth(begin)
        , modulation_depth_dithering(begin)
        , zone_max(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 81, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 176};
    it begin() const { return zone.begin(); }
    it end() const { return zone_max.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t zone;//!<  user requested MTA zone for data analysis. 
    #else
    binary::field<uint8_t, sc_uint8, 0, it> zone;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gate_low;//!<  lower range gate in meters, valid if zone == 0 
    #else
    binary::field<float, sc_float32, 8, it> gate_low;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gate_high;//!<  upper range gate in meters, valid if zone == 0 
    #else
    binary::field<float, sc_float32, 40, it> gate_high;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float zone_width;//!<  width of the multiple time around zones in meter 
    #else
    binary::field<float, sc_float32, 72, it> zone_width;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float modulation_depth;//!<  depth of pulse position modulation in meter 
    #else
    binary::field<float, sc_float32, 104, it> modulation_depth;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float modulation_depth_dithering;//!<  depth of dithering in meter 
    #else
    binary::field<float, sc_float32, 136, it> modulation_depth_dithering;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t zone_max;//!<  maximum possible configured mta zone 
    #else
    binary::field<uint8_t, sc_uint8, 168, it> zone_max;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    mta_settings_3& operator=(const mta_settings_3<ito>& o) {
        zone = o.zone;
        gate_low = o.gate_low;
        gate_high = o.gate_high;
        zone_width = o.zone_width;
        modulation_depth = o.modulation_depth;
        modulation_depth_dithering = o.modulation_depth_dithering;
        zone_max = o.zone_max;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct mta_settings_3<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef mta_settings_3<rebind_it> type;
    };

    enum { id_main = 81, id_sub = 2};

    uint8_t          zone;
    float            gate_low;
    float            gate_high;
    float            zone_width;
    float            modulation_depth;
    float            modulation_depth_dithering;
    uint8_t          zone_max;

    mta_settings_3()
        : zone()
        , gate_low()
        , gate_high()
        , zone_width()
        , modulation_depth()
        , modulation_depth_dithering()
        , zone_max()
    {}

    template<class it>
    mta_settings_3(const mta_settings_3<it>& o) {
        zone = o.zone;
        gate_low = o.gate_low;
        gate_high = o.gate_high;
        zone_width = o.zone_width;
        modulation_depth = o.modulation_depth;
        modulation_depth_dithering = o.modulation_depth_dithering;
        zone_max = o.zone_max;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const mta_settings_3<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.zone;
        s << ", " << x.gate_low;
        s << ", " << x.gate_high;
        s << ", " << x.zone_width;
        s << ", " << x.modulation_depth;
        s << ", " << x.modulation_depth_dithering;
        s << ", " << x.zone_max;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, mta_settings_3<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.zone;
        s >> ',' >> x.gate_low;
        s >> ',' >> x.gate_high;
        s >> ',' >> x.zone_width;
        s >> ',' >> x.modulation_depth;
        s >> ',' >> x.modulation_depth_dithering;
        s >> ',' >> x.zone_max;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct notch_filter
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef notch_filter<rebind_it> type;
    };

    typedef it iterator_type;

    notch_filter(it begin, it end, bool dirty=false)
        : range_min(begin)
        , range_max(begin)
        , amplitude_max(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 84, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return range_min.begin(); }
    it end() const { return amplitude_max.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_min;
    #else
    binary::field<float, sc_float32, 0, it> range_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_max;
    #else
    binary::field<float, sc_float32, 32, it> range_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_max;
    #else
    binary::field<float, sc_float32, 64, it> amplitude_max;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    notch_filter& operator=(const notch_filter<ito>& o) {
        range_min = o.range_min;
        range_max = o.range_max;
        amplitude_max = o.amplitude_max;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct notch_filter<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef notch_filter<rebind_it> type;
    };

    enum { id_main = 84, id_sub = 0};

    float            range_min;
    float            range_max;
    float            amplitude_max;

    notch_filter()
        : range_min()
        , range_max()
        , amplitude_max()
    {}

    template<class it>
    notch_filter(const notch_filter<it>& o) {
        range_min = o.range_min;
        range_max = o.range_max;
        amplitude_max = o.amplitude_max;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const notch_filter<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range_min;
        s << ", " << x.range_max;
        s << ", " << x.amplitude_max;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, notch_filter<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range_min;
        s >> ',' >> x.range_max;
        s >> ',' >> x.amplitude_max;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct notch_filter_modification_parameters
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef notch_filter_modification_parameters<rebind_it> type;
    };

    typedef it iterator_type;

    notch_filter_modification_parameters(it begin, it end, bool dirty=false)
        : amplitude_offset(begin)
        , range_sigma_add(begin)
        , range_sigma_factor(begin)
        , amplitude_sigma_add(begin)
        , amplitude_sigma_factor(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 142, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 160};
    it begin() const { return amplitude_offset.begin(); }
    it end() const { return amplitude_sigma_factor.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_offset;
    #else
    binary::field<float, sc_float32, 0, it> amplitude_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_sigma_add;
    #else
    binary::field<float, sc_float32, 32, it> range_sigma_add;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_sigma_factor;
    #else
    binary::field<float, sc_float32, 64, it> range_sigma_factor;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_sigma_add;
    #else
    binary::field<float, sc_float32, 96, it> amplitude_sigma_add;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_sigma_factor;
    #else
    binary::field<float, sc_float32, 128, it> amplitude_sigma_factor;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    notch_filter_modification_parameters& operator=(const notch_filter_modification_parameters<ito>& o) {
        amplitude_offset = o.amplitude_offset;
        range_sigma_add = o.range_sigma_add;
        range_sigma_factor = o.range_sigma_factor;
        amplitude_sigma_add = o.amplitude_sigma_add;
        amplitude_sigma_factor = o.amplitude_sigma_factor;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct notch_filter_modification_parameters<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef notch_filter_modification_parameters<rebind_it> type;
    };

    enum { id_main = 142, id_sub = 0};

    float            amplitude_offset;
    float            range_sigma_add;
    float            range_sigma_factor;
    float            amplitude_sigma_add;
    float            amplitude_sigma_factor;

    notch_filter_modification_parameters()
        : amplitude_offset()
        , range_sigma_add()
        , range_sigma_factor()
        , amplitude_sigma_add()
        , amplitude_sigma_factor()
    {}

    template<class it>
    notch_filter_modification_parameters(const notch_filter_modification_parameters<it>& o) {
        amplitude_offset = o.amplitude_offset;
        range_sigma_add = o.range_sigma_add;
        range_sigma_factor = o.range_sigma_factor;
        amplitude_sigma_add = o.amplitude_sigma_add;
        amplitude_sigma_factor = o.amplitude_sigma_factor;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const notch_filter_modification_parameters<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.amplitude_offset;
        s << ", " << x.range_sigma_add;
        s << ", " << x.range_sigma_factor;
        s << ", " << x.amplitude_sigma_add;
        s << ", " << x.amplitude_sigma_factor;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, notch_filter_modification_parameters<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.amplitude_offset;
        s >> ',' >> x.range_sigma_add;
        s >> ',' >> x.range_sigma_factor;
        s >> ',' >> x.amplitude_sigma_add;
        s >> ',' >> x.amplitude_sigma_factor;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct nrange_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef nrange_table<rebind_it> type;
    };

    typedef it iterator_type;

    nrange_table(it begin, it end, bool dirty=false)
        : sc(begin)
        , roff(begin)
        , nrange(begin, end, nrange_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 68, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1088};
    it begin() const { return sc.begin(); }
    it end() const { return nrange.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t sc;
    #else
    binary::field<int32_t, sc_int32, 0, it> sc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t roff;
    #else
    binary::field<int32_t, sc_int32, 32, it> roff;
    #endif //DOXYGEN

    std::size_t nrange_size;
    enum { nrange_max_size = 64 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : val(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int16_t val;
        #else
        binary::field<int16_t, sc_int16, 0, it> val;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition nrange[64];
    #else
    sequence<nrange_table, 16, 64, it> nrange;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    nrange_table& operator=(const nrange_table<ito>& o) {
        sc = o.sc;
        roff = o.roff;
        nrange_size = o.nrange_size;
        nrange.clean();
        for(unsigned n=0; n<nrange_size; ++n){
            nrange[n].val = o.nrange[n].val;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct nrange_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef nrange_table<rebind_it> type;
    };

    enum { id_main = 68, id_sub = 0};

    int32_t          sc;
    int32_t          roff;
    std::size_t nrange_size;
    enum { nrange_max_size = 64 };
    struct sequence_definition {
        int16_t          val;
    } nrange[64];

    nrange_table()
        : sc()
        , roff()
    {}

    template<class it>
    nrange_table(const nrange_table<it>& o) {
        sc = o.sc;
        roff = o.roff;
        nrange_size = o.nrange.size();
        for(unsigned n=0; n<nrange_size; ++n){
            nrange[n].val = o.nrange[n].val;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const nrange_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.sc;
        s << ", " << x.roff;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.nrange_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.nrange[n].val
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, nrange_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.sc;
        s >> ',' >> x.roff;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.nrange_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.nrange_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.nrange[x.nrange_size-1].val)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct operating_time
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef operating_time<rebind_it> type;
    };

    typedef it iterator_type;

    operating_time(it begin, it end, bool dirty=false)
        : instrument(begin)
        , laser(begin)
        , line_motor(begin)
        , frame_motor(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 85, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 512};
    it begin() const { return instrument.begin(); }
    it end() const { return frame_motor.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char instrument[16];
    #else
    binary::array<char, 16, sc_char, 0, it> instrument;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char laser[16];
    #else
    binary::array<char, 16, sc_char, 128, it> laser;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char line_motor[16];
    #else
    binary::array<char, 16, sc_char, 256, it> line_motor;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char frame_motor[16];
    #else
    binary::array<char, 16, sc_char, 384, it> frame_motor;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    operating_time& operator=(const operating_time<ito>& o) {
        for(unsigned n=0; n<16; ++n) instrument[n] = o.instrument[n];
        for(unsigned n=0; n<16; ++n) laser[n] = o.laser[n];
        for(unsigned n=0; n<16; ++n) line_motor[n] = o.line_motor[n];
        for(unsigned n=0; n<16; ++n) frame_motor[n] = o.frame_motor[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct operating_time<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef operating_time<rebind_it> type;
    };

    enum { id_main = 85, id_sub = 0};

    char             instrument[16];
    char             laser[16];
    char             line_motor[16];
    char             frame_motor[16];

    operating_time()
        : instrument()
        , laser()
        , line_motor()
        , frame_motor()
    {}

    template<class it>
    operating_time(const operating_time<it>& o) {
        for(unsigned n=0; n<16; ++n) instrument[n] = o.instrument[n];
        for(unsigned n=0; n<16; ++n) laser[n] = o.laser[n];
        for(unsigned n=0; n<16; ++n) line_motor[n] = o.line_motor[n];
        for(unsigned n=0; n<16; ++n) frame_motor[n] = o.frame_motor[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const operating_time<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 16, x.instrument);
        s << ", "; write_array(s, 16, x.laser);
        s << ", "; write_array(s, 16, x.line_motor);
        s << ", "; write_array(s, 16, x.frame_motor);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, operating_time<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 16, x.instrument);
        s >> ','; read_array(s, 16, x.laser);
        s >> ','; read_array(s, 16, x.line_motor);
        s >> ','; read_array(s, 16, x.frame_motor);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_frame_echo
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_echo<rebind_it> type;
    };

    typedef it iterator_type;

    packed_frame_echo(it begin, it end, bool dirty=false)
        : deltas(begin, end, deltas_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 48, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1048512};
    it begin() const { return deltas.begin(); }
    it end() const { return deltas.end(); }

    #endif //DOXYGEN

    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : range(begin, begin_bit)
            , ampl(begin, begin_bit)
            , refl(begin, begin_bit)
            , flags(begin, begin_bit)
            , dev(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int32_t range;
        #else
        binary::field<int32_t, sc_int23, 0, it> range;
        #endif
        #ifdef DOXYGEN
        int16_t ampl;
        #else
        binary::field<int16_t, sc_int14, 23, it> ampl;
        #endif
        #ifdef DOXYGEN
        int16_t refl;
        #else
        binary::field<int16_t, sc_int14, 37, it> refl;
        #endif
        #ifdef DOXYGEN
        uint8_t flags;
        #else
        binary::field<uint8_t, sc_uint4, 51, it> flags;
        #endif
        #ifdef DOXYGEN
        int16_t dev;
        #else
        binary::field<int16_t, sc_int9, 55, it> dev;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition deltas[16383];
    #else
    sequence<packed_frame_echo, 64, 0, it> deltas;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    packed_frame_echo& operator=(const packed_frame_echo<ito>& o) {
        deltas_size = o.deltas_size;
        deltas.clean();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].range = o.deltas[n].range;
            deltas[n].ampl = o.deltas[n].ampl;
            deltas[n].refl = o.deltas[n].refl;
            deltas[n].flags = o.deltas[n].flags;
            deltas[n].dev = o.deltas[n].dev;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_frame_echo<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_echo<rebind_it> type;
    };

    enum { id_main = 48, id_sub = 0};

    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition {
        int32_t          range;
        int16_t          ampl;
        int16_t          refl;
        uint8_t          flags;
        int16_t          dev;
    } deltas[16383];

    packed_frame_echo()
    {}

    template<class it>
    packed_frame_echo(const packed_frame_echo<it>& o) {
        deltas_size = o.deltas.size();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].range = o.deltas[n].range;
            deltas[n].ampl = o.deltas[n].ampl;
            deltas[n].refl = o.deltas[n].refl;
            deltas[n].flags = o.deltas[n].flags;
            deltas[n].dev = o.deltas[n].dev;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_frame_echo<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.deltas_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.deltas[n].range
            << ", " << x.deltas[n].ampl
            << ", " << x.deltas[n].refl
            << ", " << x.deltas[n].flags
            << ", " << x.deltas[n].dev
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_frame_echo<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.deltas_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.deltas_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.deltas[x.deltas_size-1].range)
            >> ',' >> (x.deltas[x.deltas_size-1].ampl)
            >> ',' >> (x.deltas[x.deltas_size-1].refl)
            >> ',' >> (x.deltas[x.deltas_size-1].flags)
            >> ',' >> (x.deltas[x.deltas_size-1].dev)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_frame_echo_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_echo_hr<rebind_it> type;
    };

    typedef it iterator_type;

    packed_frame_echo_hr(it begin, it end, bool dirty=false)
        : deltas(begin, end, deltas_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 66, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1048512};
    it begin() const { return deltas.begin(); }
    it end() const { return deltas.end(); }

    #endif //DOXYGEN

    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : range(begin, begin_bit)
            , ampl(begin, begin_bit)
            , refl(begin, begin_bit)
            , flags(begin, begin_bit)
            , dev(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int32_t range;
        #else
        binary::field<int32_t, sc_int25, 0, it> range;
        #endif
        #ifdef DOXYGEN
        int16_t ampl;
        #else
        binary::field<int16_t, sc_int12, 25, it> ampl;
        #endif
        #ifdef DOXYGEN
        int16_t refl;
        #else
        binary::field<int16_t, sc_int12, 37, it> refl;
        #endif
        #ifdef DOXYGEN
        uint8_t flags;
        #else
        binary::field<uint8_t, sc_uint4, 49, it> flags;
        #endif
        #ifdef DOXYGEN
        int16_t dev;
        #else
        binary::field<int16_t, sc_int11, 53, it> dev;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition deltas[16383];
    #else
    sequence<packed_frame_echo_hr, 64, 0, it> deltas;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    packed_frame_echo_hr& operator=(const packed_frame_echo_hr<ito>& o) {
        deltas_size = o.deltas_size;
        deltas.clean();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].range = o.deltas[n].range;
            deltas[n].ampl = o.deltas[n].ampl;
            deltas[n].refl = o.deltas[n].refl;
            deltas[n].flags = o.deltas[n].flags;
            deltas[n].dev = o.deltas[n].dev;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_frame_echo_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_echo_hr<rebind_it> type;
    };

    enum { id_main = 66, id_sub = 0};

    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition {
        int32_t          range;
        int16_t          ampl;
        int16_t          refl;
        uint8_t          flags;
        int16_t          dev;
    } deltas[16383];

    packed_frame_echo_hr()
    {}

    template<class it>
    packed_frame_echo_hr(const packed_frame_echo_hr<it>& o) {
        deltas_size = o.deltas.size();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].range = o.deltas[n].range;
            deltas[n].ampl = o.deltas[n].ampl;
            deltas[n].refl = o.deltas[n].refl;
            deltas[n].flags = o.deltas[n].flags;
            deltas[n].dev = o.deltas[n].dev;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_frame_echo_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.deltas_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.deltas[n].range
            << ", " << x.deltas[n].ampl
            << ", " << x.deltas[n].refl
            << ", " << x.deltas[n].flags
            << ", " << x.deltas[n].dev
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_frame_echo_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.deltas_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.deltas_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.deltas[x.deltas_size-1].range)
            >> ',' >> (x.deltas[x.deltas_size-1].ampl)
            >> ',' >> (x.deltas[x.deltas_size-1].refl)
            >> ',' >> (x.deltas[x.deltas_size-1].flags)
            >> ',' >> (x.deltas[x.deltas_size-1].dev)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_frame_echo_hr_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_echo_hr_1<rebind_it> type;
    };

    typedef it iterator_type;

    packed_frame_echo_hr_1(it begin, it end, bool dirty=false)
        : deltas(begin, end, deltas_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 93, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1048512};
    it begin() const { return deltas.begin(); }
    it end() const { return deltas.end(); }

    #endif //DOXYGEN

    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : range(begin, begin_bit)
            , ampl(begin, begin_bit)
            , gain(begin, begin_bit)
            , flags(begin, begin_bit)
            , dev(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int32_t range;
        #else
        binary::field<int32_t, sc_int26, 0, it> range;
        #endif
        #ifdef DOXYGEN
        int16_t ampl;
        #else
        binary::field<int16_t, sc_int14, 26, it> ampl;
        #endif
        #ifdef DOXYGEN
        int16_t gain;
        #else
        binary::field<int16_t, sc_int11, 40, it> gain;
        #endif
        #ifdef DOXYGEN
        uint8_t flags;
        #else
        binary::field<uint8_t, sc_uint2, 51, it> flags;
        #endif
        #ifdef DOXYGEN
        int16_t dev;
        #else
        binary::field<int16_t, sc_int11, 53, it> dev;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition deltas[16383];
    #else
    sequence<packed_frame_echo_hr_1, 64, 0, it> deltas;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    packed_frame_echo_hr_1& operator=(const packed_frame_echo_hr_1<ito>& o) {
        deltas_size = o.deltas_size;
        deltas.clean();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].range = o.deltas[n].range;
            deltas[n].ampl = o.deltas[n].ampl;
            deltas[n].gain = o.deltas[n].gain;
            deltas[n].flags = o.deltas[n].flags;
            deltas[n].dev = o.deltas[n].dev;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_frame_echo_hr_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_echo_hr_1<rebind_it> type;
    };

    enum { id_main = 93, id_sub = 0};

    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition {
        int32_t          range;
        int16_t          ampl;
        int16_t          gain;
        uint8_t          flags;
        int16_t          dev;
    } deltas[16383];

    packed_frame_echo_hr_1()
    {}

    template<class it>
    packed_frame_echo_hr_1(const packed_frame_echo_hr_1<it>& o) {
        deltas_size = o.deltas.size();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].range = o.deltas[n].range;
            deltas[n].ampl = o.deltas[n].ampl;
            deltas[n].gain = o.deltas[n].gain;
            deltas[n].flags = o.deltas[n].flags;
            deltas[n].dev = o.deltas[n].dev;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_frame_echo_hr_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.deltas_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.deltas[n].range
            << ", " << x.deltas[n].ampl
            << ", " << x.deltas[n].gain
            << ", " << x.deltas[n].flags
            << ", " << x.deltas[n].dev
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_frame_echo_hr_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.deltas_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.deltas_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.deltas[x.deltas_size-1].range)
            >> ',' >> (x.deltas[x.deltas_size-1].ampl)
            >> ',' >> (x.deltas[x.deltas_size-1].gain)
            >> ',' >> (x.deltas[x.deltas_size-1].flags)
            >> ',' >> (x.deltas[x.deltas_size-1].dev)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_frame_laser_shot_2angles
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_laser_shot_2angles<rebind_it> type;
    };

    typedef it iterator_type;

    packed_frame_laser_shot_2angles(it begin, it end, bool dirty=false)
        : systime_diff(begin)
        , num_echoes(begin)
        , line_angle_diff(begin)
        , frame_angle_diff(begin)
        , deltas(begin, end, deltas_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 46, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 262176};
    it begin() const { return systime_diff.begin(); }
    it end() const { return deltas.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t systime_diff;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> systime_diff;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_echoes;
    #else
    binary::field<uint8_t, sc_uint8, 8, it> num_echoes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t line_angle_diff;
    #else
    binary::field<int16_t, sc_int16, 16, it> line_angle_diff;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t frame_angle_diff;
    #else
    binary::field<int16_t, sc_int16, 32, it> frame_angle_diff;
    #endif //DOXYGEN

    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : systime(begin, begin_bit)
            , line_angle(begin, begin_bit)
            , frame_angle(begin, begin_bit)
            , num_echoes(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int8_t systime;
        #else
        binary::field<int8_t, sc_int2, 0, it> systime;
        #endif
        #ifdef DOXYGEN
        int8_t line_angle;
        #else
        binary::field<int8_t, sc_int5, 2, it> line_angle;
        #endif
        #ifdef DOXYGEN
        int8_t frame_angle;
        #else
        binary::field<int8_t, sc_int5, 7, it> frame_angle;
        #endif
        #ifdef DOXYGEN
        uint8_t num_echoes;
        #else
        binary::field<uint8_t, sc_uint4, 12, it> num_echoes;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition deltas[16383];
    #else
    sequence<packed_frame_laser_shot_2angles, 16, 48, it> deltas;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    packed_frame_laser_shot_2angles& operator=(const packed_frame_laser_shot_2angles<ito>& o) {
        systime_diff = o.systime_diff;
        num_echoes = o.num_echoes;
        line_angle_diff = o.line_angle_diff;
        frame_angle_diff = o.frame_angle_diff;
        deltas_size = o.deltas_size;
        deltas.clean();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].systime = o.deltas[n].systime;
            deltas[n].line_angle = o.deltas[n].line_angle;
            deltas[n].frame_angle = o.deltas[n].frame_angle;
            deltas[n].num_echoes = o.deltas[n].num_echoes;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_frame_laser_shot_2angles<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_laser_shot_2angles<rebind_it> type;
    };

    enum { id_main = 46, id_sub = 0};

    uint8_t          systime_diff;
    uint8_t          num_echoes;
    int16_t          line_angle_diff;
    int16_t          frame_angle_diff;
    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition {
        int8_t           systime;
        int8_t           line_angle;
        int8_t           frame_angle;
        uint8_t          num_echoes;
    } deltas[16383];

    packed_frame_laser_shot_2angles()
        : systime_diff()
        , num_echoes()
        , line_angle_diff()
        , frame_angle_diff()
    {}

    template<class it>
    packed_frame_laser_shot_2angles(const packed_frame_laser_shot_2angles<it>& o) {
        systime_diff = o.systime_diff;
        num_echoes = o.num_echoes;
        line_angle_diff = o.line_angle_diff;
        frame_angle_diff = o.frame_angle_diff;
        deltas_size = o.deltas.size();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].systime = o.deltas[n].systime;
            deltas[n].line_angle = o.deltas[n].line_angle;
            deltas[n].frame_angle = o.deltas[n].frame_angle;
            deltas[n].num_echoes = o.deltas[n].num_echoes;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_frame_laser_shot_2angles<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime_diff;
        s << ", " << x.num_echoes;
        s << ", " << x.line_angle_diff;
        s << ", " << x.frame_angle_diff;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.deltas_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.deltas[n].systime
            << ", " << x.deltas[n].line_angle
            << ", " << x.deltas[n].frame_angle
            << ", " << x.deltas[n].num_echoes
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_frame_laser_shot_2angles<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime_diff;
        s >> ',' >> x.num_echoes;
        s >> ',' >> x.line_angle_diff;
        s >> ',' >> x.frame_angle_diff;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.deltas_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.deltas_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.deltas[x.deltas_size-1].systime)
            >> ',' >> (x.deltas[x.deltas_size-1].line_angle)
            >> ',' >> (x.deltas[x.deltas_size-1].frame_angle)
            >> ',' >> (x.deltas[x.deltas_size-1].num_echoes)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_frame_laser_shot_2angles_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_laser_shot_2angles_hr<rebind_it> type;
    };

    typedef it iterator_type;

    packed_frame_laser_shot_2angles_hr(it begin, it end, bool dirty=false)
        : systime_diff(begin)
        , num_echoes(begin)
        , line_angle_diff(begin)
        , frame_angle_diff(begin)
        , deltas(begin, end, deltas_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 64, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 524320};
    it begin() const { return systime_diff.begin(); }
    it end() const { return deltas.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime_diff;
    #else
    binary::field<uint32_t, sc_uint28, 0, it> systime_diff;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_echoes;
    #else
    binary::field<uint8_t, sc_uint4, 28, it> num_echoes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t line_angle_diff;
    #else
    binary::field<int16_t, sc_int16, 32, it> line_angle_diff;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t frame_angle_diff;
    #else
    binary::field<int16_t, sc_int16, 48, it> frame_angle_diff;
    #endif //DOXYGEN

    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : systime(begin, begin_bit)
            , line_angle(begin, begin_bit)
            , frame_angle(begin, begin_bit)
            , num_echoes(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int32_t systime;
        #else
        binary::field<int32_t, sc_int18, 0, it> systime;
        #endif
        #ifdef DOXYGEN
        int8_t line_angle;
        #else
        binary::field<int8_t, sc_int5, 18, it> line_angle;
        #endif
        #ifdef DOXYGEN
        int8_t frame_angle;
        #else
        binary::field<int8_t, sc_int5, 23, it> frame_angle;
        #endif
        #ifdef DOXYGEN
        uint8_t num_echoes;
        #else
        binary::field<uint8_t, sc_uint4, 28, it> num_echoes;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition deltas[16383];
    #else
    sequence<packed_frame_laser_shot_2angles_hr, 32, 64, it> deltas;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    packed_frame_laser_shot_2angles_hr& operator=(const packed_frame_laser_shot_2angles_hr<ito>& o) {
        systime_diff = o.systime_diff;
        num_echoes = o.num_echoes;
        line_angle_diff = o.line_angle_diff;
        frame_angle_diff = o.frame_angle_diff;
        deltas_size = o.deltas_size;
        deltas.clean();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].systime = o.deltas[n].systime;
            deltas[n].line_angle = o.deltas[n].line_angle;
            deltas[n].frame_angle = o.deltas[n].frame_angle;
            deltas[n].num_echoes = o.deltas[n].num_echoes;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_frame_laser_shot_2angles_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_laser_shot_2angles_hr<rebind_it> type;
    };

    enum { id_main = 64, id_sub = 0};

    uint32_t         systime_diff;
    uint8_t          num_echoes;
    int16_t          line_angle_diff;
    int16_t          frame_angle_diff;
    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition {
        int32_t          systime;
        int8_t           line_angle;
        int8_t           frame_angle;
        uint8_t          num_echoes;
    } deltas[16383];

    packed_frame_laser_shot_2angles_hr()
        : systime_diff()
        , num_echoes()
        , line_angle_diff()
        , frame_angle_diff()
    {}

    template<class it>
    packed_frame_laser_shot_2angles_hr(const packed_frame_laser_shot_2angles_hr<it>& o) {
        systime_diff = o.systime_diff;
        num_echoes = o.num_echoes;
        line_angle_diff = o.line_angle_diff;
        frame_angle_diff = o.frame_angle_diff;
        deltas_size = o.deltas.size();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].systime = o.deltas[n].systime;
            deltas[n].line_angle = o.deltas[n].line_angle;
            deltas[n].frame_angle = o.deltas[n].frame_angle;
            deltas[n].num_echoes = o.deltas[n].num_echoes;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_frame_laser_shot_2angles_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime_diff;
        s << ", " << x.num_echoes;
        s << ", " << x.line_angle_diff;
        s << ", " << x.frame_angle_diff;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.deltas_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.deltas[n].systime
            << ", " << x.deltas[n].line_angle
            << ", " << x.deltas[n].frame_angle
            << ", " << x.deltas[n].num_echoes
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_frame_laser_shot_2angles_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime_diff;
        s >> ',' >> x.num_echoes;
        s >> ',' >> x.line_angle_diff;
        s >> ',' >> x.frame_angle_diff;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.deltas_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.deltas_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.deltas[x.deltas_size-1].systime)
            >> ',' >> (x.deltas[x.deltas_size-1].line_angle)
            >> ',' >> (x.deltas[x.deltas_size-1].frame_angle)
            >> ',' >> (x.deltas[x.deltas_size-1].num_echoes)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_frame_laser_shot_2angles_rad
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_laser_shot_2angles_rad<rebind_it> type;
    };

    typedef it iterator_type;

    packed_frame_laser_shot_2angles_rad(it begin, it end, bool dirty=false)
        : systime_diff(begin)
        , num_echoes(begin)
        , line_angle_diff(begin)
        , frame_angle_diff(begin)
        , backgnd_rad(begin)
        , deltas(begin, end, deltas_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 52, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 524320};
    it begin() const { return systime_diff.begin(); }
    it end() const { return deltas.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t systime_diff;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> systime_diff;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_echoes;
    #else
    binary::field<uint8_t, sc_uint8, 8, it> num_echoes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t line_angle_diff;
    #else
    binary::field<int16_t, sc_int16, 16, it> line_angle_diff;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t frame_angle_diff;
    #else
    binary::field<int16_t, sc_int16, 32, it> frame_angle_diff;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t backgnd_rad;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> backgnd_rad;
    #endif //DOXYGEN

    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : systime(begin, begin_bit)
            , line_angle(begin, begin_bit)
            , frame_angle(begin, begin_bit)
            , num_echoes(begin, begin_bit)
            , backgnd_rad(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int8_t systime;
        #else
        binary::field<int8_t, sc_int2, 0, it> systime;
        #endif
        #ifdef DOXYGEN
        int8_t line_angle;
        #else
        binary::field<int8_t, sc_int5, 2, it> line_angle;
        #endif
        #ifdef DOXYGEN
        int8_t frame_angle;
        #else
        binary::field<int8_t, sc_int5, 7, it> frame_angle;
        #endif
        #ifdef DOXYGEN
        uint8_t num_echoes;
        #else
        binary::field<uint8_t, sc_uint4, 12, it> num_echoes;
        #endif
        #ifdef DOXYGEN
        uint16_t backgnd_rad;
        #else
        binary::field<uint16_t, sc_uint16, 16, it> backgnd_rad;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition deltas[16383];
    #else
    sequence<packed_frame_laser_shot_2angles_rad, 32, 64, it> deltas;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    packed_frame_laser_shot_2angles_rad& operator=(const packed_frame_laser_shot_2angles_rad<ito>& o) {
        systime_diff = o.systime_diff;
        num_echoes = o.num_echoes;
        line_angle_diff = o.line_angle_diff;
        frame_angle_diff = o.frame_angle_diff;
        backgnd_rad = o.backgnd_rad;
        deltas_size = o.deltas_size;
        deltas.clean();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].systime = o.deltas[n].systime;
            deltas[n].line_angle = o.deltas[n].line_angle;
            deltas[n].frame_angle = o.deltas[n].frame_angle;
            deltas[n].num_echoes = o.deltas[n].num_echoes;
            deltas[n].backgnd_rad = o.deltas[n].backgnd_rad;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_frame_laser_shot_2angles_rad<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_frame_laser_shot_2angles_rad<rebind_it> type;
    };

    enum { id_main = 52, id_sub = 0};

    uint8_t          systime_diff;
    uint8_t          num_echoes;
    int16_t          line_angle_diff;
    int16_t          frame_angle_diff;
    uint16_t         backgnd_rad;
    std::size_t deltas_size;
    enum { deltas_max_size = 16383 };
    struct sequence_definition {
        int8_t           systime;
        int8_t           line_angle;
        int8_t           frame_angle;
        uint8_t          num_echoes;
        uint16_t         backgnd_rad;
    } deltas[16383];

    packed_frame_laser_shot_2angles_rad()
        : systime_diff()
        , num_echoes()
        , line_angle_diff()
        , frame_angle_diff()
        , backgnd_rad()
    {}

    template<class it>
    packed_frame_laser_shot_2angles_rad(const packed_frame_laser_shot_2angles_rad<it>& o) {
        systime_diff = o.systime_diff;
        num_echoes = o.num_echoes;
        line_angle_diff = o.line_angle_diff;
        frame_angle_diff = o.frame_angle_diff;
        backgnd_rad = o.backgnd_rad;
        deltas_size = o.deltas.size();
        for(unsigned n=0; n<deltas_size; ++n){
            deltas[n].systime = o.deltas[n].systime;
            deltas[n].line_angle = o.deltas[n].line_angle;
            deltas[n].frame_angle = o.deltas[n].frame_angle;
            deltas[n].num_echoes = o.deltas[n].num_echoes;
            deltas[n].backgnd_rad = o.deltas[n].backgnd_rad;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_frame_laser_shot_2angles_rad<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime_diff;
        s << ", " << x.num_echoes;
        s << ", " << x.line_angle_diff;
        s << ", " << x.frame_angle_diff;
        s << ", " << x.backgnd_rad;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.deltas_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.deltas[n].systime
            << ", " << x.deltas[n].line_angle
            << ", " << x.deltas[n].frame_angle
            << ", " << x.deltas[n].num_echoes
            << ", " << x.deltas[n].backgnd_rad
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_frame_laser_shot_2angles_rad<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime_diff;
        s >> ',' >> x.num_echoes;
        s >> ',' >> x.line_angle_diff;
        s >> ',' >> x.frame_angle_diff;
        s >> ',' >> x.backgnd_rad;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.deltas_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.deltas_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.deltas[x.deltas_size-1].systime)
            >> ',' >> (x.deltas[x.deltas_size-1].line_angle)
            >> ',' >> (x.deltas[x.deltas_size-1].frame_angle)
            >> ',' >> (x.deltas[x.deltas_size-1].num_echoes)
            >> ',' >> (x.deltas[x.deltas_size-1].backgnd_rad)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_key_echo
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_echo<rebind_it> type;
    };

    typedef it iterator_type;

    packed_key_echo(it begin, it end, bool dirty=false)
        : range(begin)
        , ampl(begin)
        , refl(begin)
        , flags(begin)
        , dev(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 47, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return range.begin(); }
    it end() const { return dev.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t range;
    #else
    binary::field<int32_t, sc_int32, 0, it> range;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t refl;
    #else
    binary::field<int16_t, sc_int16, 48, it> refl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t flags;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t dev;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> dev;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    packed_key_echo& operator=(const packed_key_echo<ito>& o) {
        range = o.range;
        ampl = o.ampl;
        refl = o.refl;
        flags = o.flags;
        dev = o.dev;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_key_echo<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_echo<rebind_it> type;
    };

    enum { id_main = 47, id_sub = 0};

    int32_t          range;
    uint16_t         ampl;
    int16_t          refl;
    uint16_t         flags;
    uint16_t         dev;

    packed_key_echo()
        : range()
        , ampl()
        , refl()
        , flags()
        , dev()
    {}

    template<class it>
    packed_key_echo(const packed_key_echo<it>& o) {
        range = o.range;
        ampl = o.ampl;
        refl = o.refl;
        flags = o.flags;
        dev = o.dev;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_key_echo<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range;
        s << ", " << x.ampl;
        s << ", " << x.refl;
        s << ", " << x.flags;
        s << ", " << x.dev;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_key_echo<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range;
        s >> ',' >> x.ampl;
        s >> ',' >> x.refl;
        s >> ',' >> x.flags;
        s >> ',' >> x.dev;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_key_echo_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_echo_hr<rebind_it> type;
    };

    typedef it iterator_type;

    packed_key_echo_hr(it begin, it end, bool dirty=false)
        : range(begin)
        , ampl(begin)
        , refl(begin)
        , flags(begin)
        , dev(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 65, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return range.begin(); }
    it end() const { return dev.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t range;
    #else
    binary::field<int32_t, sc_int32, 0, it> range;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t refl;
    #else
    binary::field<int16_t, sc_int16, 48, it> refl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t flags;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t dev;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> dev;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    packed_key_echo_hr& operator=(const packed_key_echo_hr<ito>& o) {
        range = o.range;
        ampl = o.ampl;
        refl = o.refl;
        flags = o.flags;
        dev = o.dev;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_key_echo_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_echo_hr<rebind_it> type;
    };

    enum { id_main = 65, id_sub = 0};

    int32_t          range;
    uint16_t         ampl;
    int16_t          refl;
    uint16_t         flags;
    uint16_t         dev;

    packed_key_echo_hr()
        : range()
        , ampl()
        , refl()
        , flags()
        , dev()
    {}

    template<class it>
    packed_key_echo_hr(const packed_key_echo_hr<it>& o) {
        range = o.range;
        ampl = o.ampl;
        refl = o.refl;
        flags = o.flags;
        dev = o.dev;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_key_echo_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range;
        s << ", " << x.ampl;
        s << ", " << x.refl;
        s << ", " << x.flags;
        s << ", " << x.dev;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_key_echo_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range;
        s >> ',' >> x.ampl;
        s >> ',' >> x.refl;
        s >> ',' >> x.flags;
        s >> ',' >> x.dev;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_key_echo_hr_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_echo_hr_1<rebind_it> type;
    };

    typedef it iterator_type;

    packed_key_echo_hr_1(it begin, it end, bool dirty=false)
        : range(begin)
        , ampl(begin)
        , gain(begin)
        , flags(begin)
        , dev(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 92, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return range.begin(); }
    it end() const { return dev.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t range;
    #else
    binary::field<int32_t, sc_int32, 0, it> range;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t gain;
    #else
    binary::field<int16_t, sc_int16, 48, it> gain;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t flags;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t dev;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> dev;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    packed_key_echo_hr_1& operator=(const packed_key_echo_hr_1<ito>& o) {
        range = o.range;
        ampl = o.ampl;
        gain = o.gain;
        flags = o.flags;
        dev = o.dev;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_key_echo_hr_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_echo_hr_1<rebind_it> type;
    };

    enum { id_main = 92, id_sub = 0};

    int32_t          range;
    uint16_t         ampl;
    int16_t          gain;
    uint16_t         flags;
    uint16_t         dev;

    packed_key_echo_hr_1()
        : range()
        , ampl()
        , gain()
        , flags()
        , dev()
    {}

    template<class it>
    packed_key_echo_hr_1(const packed_key_echo_hr_1<it>& o) {
        range = o.range;
        ampl = o.ampl;
        gain = o.gain;
        flags = o.flags;
        dev = o.dev;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_key_echo_hr_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range;
        s << ", " << x.ampl;
        s << ", " << x.gain;
        s << ", " << x.flags;
        s << ", " << x.dev;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_key_echo_hr_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range;
        s >> ',' >> x.ampl;
        s >> ',' >> x.gain;
        s >> ',' >> x.flags;
        s >> ',' >> x.dev;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_key_laser_shot_2angles
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_laser_shot_2angles<rebind_it> type;
    };

    typedef it iterator_type;

    packed_key_laser_shot_2angles(it begin, it end, bool dirty=false)
        : systime(begin)
        , num_echoes(begin)
        , line_angle(begin)
        , frame_angle(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 45, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return systime.begin(); }
    it end() const { return frame_angle.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_echoes;
    #else
    binary::field<uint8_t, sc_uint8, 32, it> num_echoes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;
    #else
    binary::field<uint32_t, sc_uint24, 40, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_angle;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    packed_key_laser_shot_2angles& operator=(const packed_key_laser_shot_2angles<ito>& o) {
        systime = o.systime;
        num_echoes = o.num_echoes;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_key_laser_shot_2angles<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_laser_shot_2angles<rebind_it> type;
    };

    enum { id_main = 45, id_sub = 0};

    uint32_t         systime;
    uint8_t          num_echoes;
    uint32_t         line_angle;
    uint32_t         frame_angle;

    packed_key_laser_shot_2angles()
        : systime()
        , num_echoes()
        , line_angle()
        , frame_angle()
    {}

    template<class it>
    packed_key_laser_shot_2angles(const packed_key_laser_shot_2angles<it>& o) {
        systime = o.systime;
        num_echoes = o.num_echoes;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_key_laser_shot_2angles<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.num_echoes;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_key_laser_shot_2angles<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.num_echoes;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_key_laser_shot_2angles_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_laser_shot_2angles_hr<rebind_it> type;
    };

    typedef it iterator_type;

    packed_key_laser_shot_2angles_hr(it begin, it end, bool dirty=false)
        : systime(begin)
        , num_echoes(begin)
        , line_angle(begin)
        , frame_angle(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 63, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return systime.begin(); }
    it end() const { return frame_angle.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_echoes;
    #else
    binary::field<uint8_t, sc_uint8, 64, it> num_echoes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;
    #else
    binary::field<uint32_t, sc_uint24, 72, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> frame_angle;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    packed_key_laser_shot_2angles_hr& operator=(const packed_key_laser_shot_2angles_hr<ito>& o) {
        systime = o.systime;
        num_echoes = o.num_echoes;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_key_laser_shot_2angles_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_laser_shot_2angles_hr<rebind_it> type;
    };

    enum { id_main = 63, id_sub = 0};

    uint64_t         systime;
    uint8_t          num_echoes;
    uint32_t         line_angle;
    uint32_t         frame_angle;

    packed_key_laser_shot_2angles_hr()
        : systime()
        , num_echoes()
        , line_angle()
        , frame_angle()
    {}

    template<class it>
    packed_key_laser_shot_2angles_hr(const packed_key_laser_shot_2angles_hr<it>& o) {
        systime = o.systime;
        num_echoes = o.num_echoes;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_key_laser_shot_2angles_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.num_echoes;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_key_laser_shot_2angles_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.num_echoes;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_key_laser_shot_2angles_hr_mta
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_laser_shot_2angles_hr_mta<rebind_it> type;
    };

    typedef it iterator_type;

    packed_key_laser_shot_2angles_hr_mta(it begin, it end, bool dirty=false)
        : systime(begin)
        , num_echoes(begin)
        , line_angle(begin)
        , frame_angle(begin)
        , m_sequence_phase(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 63, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 160};
    it begin() const { return systime.begin(); }
    it end() const { return m_sequence_phase.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_echoes;
    #else
    binary::field<uint8_t, sc_uint8, 64, it> num_echoes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;
    #else
    binary::field<uint32_t, sc_uint24, 72, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t m_sequence_phase;
    #else
    binary::field<uint32_t, sc_uint32, 128, it> m_sequence_phase;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    packed_key_laser_shot_2angles_hr_mta& operator=(const packed_key_laser_shot_2angles_hr_mta<ito>& o) {
        systime = o.systime;
        num_echoes = o.num_echoes;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        m_sequence_phase = o.m_sequence_phase;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_key_laser_shot_2angles_hr_mta<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_laser_shot_2angles_hr_mta<rebind_it> type;
    };

    enum { id_main = 63, id_sub = 1};

    uint64_t         systime;
    uint8_t          num_echoes;
    uint32_t         line_angle;
    uint32_t         frame_angle;
    uint32_t         m_sequence_phase;

    packed_key_laser_shot_2angles_hr_mta()
        : systime()
        , num_echoes()
        , line_angle()
        , frame_angle()
        , m_sequence_phase()
    {}

    template<class it>
    packed_key_laser_shot_2angles_hr_mta(const packed_key_laser_shot_2angles_hr_mta<it>& o) {
        systime = o.systime;
        num_echoes = o.num_echoes;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        m_sequence_phase = o.m_sequence_phase;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_key_laser_shot_2angles_hr_mta<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.num_echoes;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
        s << ", " << x.m_sequence_phase;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_key_laser_shot_2angles_hr_mta<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.num_echoes;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.m_sequence_phase;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_key_laser_shot_2angles_rad
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_laser_shot_2angles_rad<rebind_it> type;
    };

    typedef it iterator_type;

    packed_key_laser_shot_2angles_rad(it begin, it end, bool dirty=false)
        : systime(begin)
        , num_echoes(begin)
        , line_angle(begin)
        , frame_angle(begin)
        , backgnd_rad(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 51, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return systime.begin(); }
    it end() const { return backgnd_rad.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_echoes;
    #else
    binary::field<uint8_t, sc_uint8, 32, it> num_echoes;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;
    #else
    binary::field<uint32_t, sc_uint24, 40, it> line_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t backgnd_rad;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> backgnd_rad;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    packed_key_laser_shot_2angles_rad& operator=(const packed_key_laser_shot_2angles_rad<ito>& o) {
        systime = o.systime;
        num_echoes = o.num_echoes;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        backgnd_rad = o.backgnd_rad;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_key_laser_shot_2angles_rad<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_key_laser_shot_2angles_rad<rebind_it> type;
    };

    enum { id_main = 51, id_sub = 0};

    uint32_t         systime;
    uint8_t          num_echoes;
    uint32_t         line_angle;
    uint32_t         frame_angle;
    uint16_t         backgnd_rad;

    packed_key_laser_shot_2angles_rad()
        : systime()
        , num_echoes()
        , line_angle()
        , frame_angle()
        , backgnd_rad()
    {}

    template<class it>
    packed_key_laser_shot_2angles_rad(const packed_key_laser_shot_2angles_rad<it>& o) {
        systime = o.systime;
        num_echoes = o.num_echoes;
        line_angle = o.line_angle;
        frame_angle = o.frame_angle;
        backgnd_rad = o.backgnd_rad;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_key_laser_shot_2angles_rad<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.num_echoes;
        s << ", " << x.line_angle;
        s << ", " << x.frame_angle;
        s << ", " << x.backgnd_rad;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_key_laser_shot_2angles_rad<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.num_echoes;
        s >> ',' >> x.line_angle;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.backgnd_rad;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_sdf
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_sdf<rebind_it> type;
    };

    typedef it iterator_type;

    packed_sdf(it begin, it end, bool dirty=false)
        : data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 108, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 65536};
    it begin() const { return data.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : dwords(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t dwords;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> dwords;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[2048];
    #else
    sequence<packed_sdf, 32, 0, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    packed_sdf& operator=(const packed_sdf<ito>& o) {
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].dwords = o.data[n].dwords;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_sdf<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_sdf<rebind_it> type;
    };

    enum { id_main = 108, id_sub = 0};

    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition {
        uint32_t         dwords;
    } data[2048];

    packed_sdf()
    {}

    template<class it>
    packed_sdf(const packed_sdf<it>& o) {
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].dwords = o.data[n].dwords;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_sdf<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].dwords
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_sdf<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].dwords)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_shot_echos_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_shot_echos_hr<rebind_it> type;
    };

    typedef it iterator_type;

    packed_shot_echos_hr(it begin, it end, bool dirty=false)
        : data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 86, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 65536};
    it begin() const { return data.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : dwords(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t dwords;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> dwords;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[2048];
    #else
    sequence<packed_shot_echos_hr, 32, 0, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    packed_shot_echos_hr& operator=(const packed_shot_echos_hr<ito>& o) {
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].dwords = o.data[n].dwords;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_shot_echos_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_shot_echos_hr<rebind_it> type;
    };

    enum { id_main = 86, id_sub = 0};

    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition {
        uint32_t         dwords;
    } data[2048];

    packed_shot_echos_hr()
    {}

    template<class it>
    packed_shot_echos_hr(const packed_shot_echos_hr<it>& o) {
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].dwords = o.data[n].dwords;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_shot_echos_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].dwords
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_shot_echos_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].dwords)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct packed_shot_echos_sbl_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef packed_shot_echos_sbl_hr<rebind_it> type;
    };

    typedef it iterator_type;

    packed_shot_echos_sbl_hr(it begin, it end, bool dirty=false)
        : data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 109, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 65536};
    it begin() const { return data.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : dwords(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t dwords;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> dwords;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[2048];
    #else
    sequence<packed_shot_echos_sbl_hr, 32, 0, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    packed_shot_echos_sbl_hr& operator=(const packed_shot_echos_sbl_hr<ito>& o) {
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].dwords = o.data[n].dwords;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct packed_shot_echos_sbl_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef packed_shot_echos_sbl_hr<rebind_it> type;
    };

    enum { id_main = 109, id_sub = 0};

    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition {
        uint32_t         dwords;
    } data[2048];

    packed_shot_echos_sbl_hr()
    {}

    template<class it>
    packed_shot_echos_sbl_hr(const packed_shot_echos_sbl_hr<it>& o) {
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].dwords = o.data[n].dwords;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const packed_shot_echos_sbl_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].dwords
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, packed_shot_echos_sbl_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].dwords)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! pulse per second, external time synchronisation

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct pps_sync
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef pps_sync<rebind_it> type;
    };

    typedef it iterator_type;

    pps_sync(it begin, it end, bool dirty=false)
        : systime(begin)
        , pps(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 12, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 64};
    it begin() const { return systime.begin(); }
    it end() const { return pps.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time of external PPS pulse in units of units.time_uint 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t pps;//!<  absolute time of pps pulse since begin of week or start of day [msec] 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> pps;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    pps_sync& operator=(const pps_sync<ito>& o) {
        systime = o.systime;
        pps = o.pps;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct pps_sync<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef pps_sync<rebind_it> type;
    };

    enum { id_main = 12, id_sub = 0};

    uint32_t         systime;
    uint32_t         pps;

    pps_sync()
        : systime()
        , pps()
    {}

    template<class it>
    pps_sync(const pps_sync<it>& o) {
        systime = o.systime;
        pps = o.pps;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const pps_sync<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.pps;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, pps_sync<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.pps;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! pulse per second, external time synchronisation

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct pps_sync_ext
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef pps_sync_ext<rebind_it> type;
    };

    typedef it iterator_type;

    pps_sync_ext(it begin, it end, bool dirty=false)
        : systime(begin)
        , pps(begin)
        , year(begin)
        , mon(begin)
        , day(begin)
        , hour(begin)
        , min(begin)
        , sec(begin)
        , flags(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 12, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return systime.begin(); }
    it end() const { return flags.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  internal time of external PPS pulse in units of units.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t pps;//!<  absolute time of pps pulse since begin of week or start of day [msec] 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> pps;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t year;//!<  UTC year                       in units of year 
    #else
    binary::field<uint16_t, sc_uint16, 64, it> year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t mon;//!<  UTC month, 1..12               in units of mon 
    #else
    binary::field<uint8_t, sc_uint8, 80, it> mon;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t day;//!<  UTC day of month, 1..31        in units of day 
    #else
    binary::field<uint8_t, sc_uint8, 88, it> day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hour;//!<  UTC hour of day, 0 .. 23       in units of hour 
    #else
    binary::field<uint8_t, sc_uint8, 96, it> hour;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t min;//!<  UTC minute of hour, 0 .. 59    in units of min 
    #else
    binary::field<uint8_t, sc_uint8, 104, it> min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t sec;//!<  UTC second of minute, 0 .. 59  in units of sec 
    #else
    binary::field<uint8_t, sc_uint8, 112, it> sec;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t flags;//!<  B0 .. Time of week valid; B1 .. valid week number; B2 .. leap seconds known 
    #else
    binary::field<uint8_t, sc_uint8, 120, it> flags;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    pps_sync_ext& operator=(const pps_sync_ext<ito>& o) {
        systime = o.systime;
        pps = o.pps;
        year = o.year;
        mon = o.mon;
        day = o.day;
        hour = o.hour;
        min = o.min;
        sec = o.sec;
        flags = o.flags;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct pps_sync_ext<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef pps_sync_ext<rebind_it> type;
    };

    enum { id_main = 12, id_sub = 1};

    uint32_t         systime;
    uint32_t         pps;
    uint16_t         year;
    uint8_t          mon;
    uint8_t          day;
    uint8_t          hour;
    uint8_t          min;
    uint8_t          sec;
    uint8_t          flags;

    pps_sync_ext()
        : systime()
        , pps()
        , year()
        , mon()
        , day()
        , hour()
        , min()
        , sec()
        , flags()
    {}

    template<class it>
    pps_sync_ext(const pps_sync_ext<it>& o) {
        systime = o.systime;
        pps = o.pps;
        year = o.year;
        mon = o.mon;
        day = o.day;
        hour = o.hour;
        min = o.min;
        sec = o.sec;
        flags = o.flags;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const pps_sync_ext<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.pps;
        s << ", " << x.year;
        s << ", " << x.mon;
        s << ", " << x.day;
        s << ", " << x.hour;
        s << ", " << x.min;
        s << ", " << x.sec;
        s << ", " << x.flags;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, pps_sync_ext<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.pps;
        s >> ',' >> x.year;
        s >> ',' >> x.mon;
        s >> ',' >> x.day;
        s >> ',' >> x.hour;
        s >> ',' >> x.min;
        s >> ',' >> x.sec;
        s >> ',' >> x.flags;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! pulse per second, external time synchronisation

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct pps_sync_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef pps_sync_hr<rebind_it> type;
    };

    typedef it iterator_type;

    pps_sync_hr(it begin, it end, bool dirty=false)
        : systime(begin)
        , pps(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 70, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return systime.begin(); }
    it end() const { return pps.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;//!<  internal time of external PPS pulse in units of units.time_unit_hi_prec 
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t pps;//!<  absolute time of pps pulse since begin of week or start of day in usec 
    #else
    binary::field<uint64_t, sc_uint64, 64, it> pps;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    pps_sync_hr& operator=(const pps_sync_hr<ito>& o) {
        systime = o.systime;
        pps = o.pps;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct pps_sync_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef pps_sync_hr<rebind_it> type;
    };

    enum { id_main = 70, id_sub = 0};

    uint64_t         systime;
    uint64_t         pps;

    pps_sync_hr()
        : systime()
        , pps()
    {}

    template<class it>
    pps_sync_hr(const pps_sync_hr<it>& o) {
        systime = o.systime;
        pps = o.pps;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const pps_sync_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.pps;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, pps_sync_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.pps;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! pulse per second, external time synchronisation

//! <para>This package belongs to the predefined selectors:</para>
//! <para>data, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct pps_sync_hr_ext
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef pps_sync_hr_ext<rebind_it> type;
    };

    typedef it iterator_type;

    pps_sync_hr_ext(it begin, it end, bool dirty=false)
        : systime(begin)
        , pps(begin)
        , year(begin)
        , mon(begin)
        , day(begin)
        , hour(begin)
        , min(begin)
        , sec(begin)
        , flags(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 70, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 192};
    it begin() const { return systime.begin(); }
    it end() const { return flags.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;//!<  internal time of external PPS pulse in units of units.time_unit_hi_prec 
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t pps;//!<  absolute time of pps pulse since begin of week or start of day in usec 
    #else
    binary::field<uint64_t, sc_uint64, 64, it> pps;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t year;//!<  UTC year                       in units of year 
    #else
    binary::field<uint16_t, sc_uint16, 128, it> year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t mon;//!<  UTC month, 1..12               in units of mon 
    #else
    binary::field<uint8_t, sc_uint8, 144, it> mon;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t day;//!<  UTC day of month, 1..31        in units of day 
    #else
    binary::field<uint8_t, sc_uint8, 152, it> day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hour;//!<  UTC hour of day, 0 .. 23       in units of hour 
    #else
    binary::field<uint8_t, sc_uint8, 160, it> hour;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t min;//!<  UTC minute of hour, 0 .. 59    in units of min 
    #else
    binary::field<uint8_t, sc_uint8, 168, it> min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t sec;//!<  UTC second of minute, 0 .. 59  in units of sec 
    #else
    binary::field<uint8_t, sc_uint8, 176, it> sec;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t flags;//!<  B0 .. Time of week valid; B1 .. valid week number; B2 .. leap seconds known 
    #else
    binary::field<uint8_t, sc_uint8, 184, it> flags;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    pps_sync_hr_ext& operator=(const pps_sync_hr_ext<ito>& o) {
        systime = o.systime;
        pps = o.pps;
        year = o.year;
        mon = o.mon;
        day = o.day;
        hour = o.hour;
        min = o.min;
        sec = o.sec;
        flags = o.flags;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct pps_sync_hr_ext<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef pps_sync_hr_ext<rebind_it> type;
    };

    enum { id_main = 70, id_sub = 1};

    uint64_t         systime;
    uint64_t         pps;
    uint16_t         year;
    uint8_t          mon;
    uint8_t          day;
    uint8_t          hour;
    uint8_t          min;
    uint8_t          sec;
    uint8_t          flags;

    pps_sync_hr_ext()
        : systime()
        , pps()
        , year()
        , mon()
        , day()
        , hour()
        , min()
        , sec()
        , flags()
    {}

    template<class it>
    pps_sync_hr_ext(const pps_sync_hr_ext<it>& o) {
        systime = o.systime;
        pps = o.pps;
        year = o.year;
        mon = o.mon;
        day = o.day;
        hour = o.hour;
        min = o.min;
        sec = o.sec;
        flags = o.flags;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const pps_sync_hr_ext<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.pps;
        s << ", " << x.year;
        s << ", " << x.mon;
        s << ", " << x.day;
        s << ", " << x.hour;
        s << ", " << x.min;
        s << ", " << x.sec;
        s << ", " << x.flags;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, pps_sync_hr_ext<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.pps;
        s >> ',' >> x.year;
        s >> ',' >> x.mon;
        s >> ',' >> x.day;
        s >> ',' >> x.hour;
        s >> ',' >> x.min;
        s >> ',' >> x.sec;
        s >> ',' >> x.flags;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct pulse_model_expsum
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef pulse_model_expsum<rebind_it> type;
    };

    typedef it iterator_type;

    pulse_model_expsum(it begin, it end, bool dirty=false)
        : delay(begin)
        , scale(begin)
        , parameter(begin, end, parameter_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 107, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 25728};
    it begin() const { return delay.begin(); }
    it end() const { return parameter.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    double delay;
    #else
    binary::field<double, sc_float64, 0, it> delay;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double scale;
    #else
    binary::field<double, sc_float64, 64, it> scale;
    #endif //DOXYGEN

    std::size_t parameter_size;
    enum { parameter_max_size = 100 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : c_real(begin, begin_bit)
            , c_imag(begin, begin_bit)
            , g_real(begin, begin_bit)
            , g_imag(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        double c_real;
        #else
        binary::field<double, sc_float64, 0, it> c_real;
        #endif
        #ifdef DOXYGEN
        double c_imag;
        #else
        binary::field<double, sc_float64, 64, it> c_imag;
        #endif
        #ifdef DOXYGEN
        double g_real;
        #else
        binary::field<double, sc_float64, 128, it> g_real;
        #endif
        #ifdef DOXYGEN
        double g_imag;
        #else
        binary::field<double, sc_float64, 192, it> g_imag;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition parameter[100];
    #else
    sequence<pulse_model_expsum, 256, 128, it> parameter;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    pulse_model_expsum& operator=(const pulse_model_expsum<ito>& o) {
        delay = o.delay;
        scale = o.scale;
        parameter_size = o.parameter_size;
        parameter.clean();
        for(unsigned n=0; n<parameter_size; ++n){
            parameter[n].c_real = o.parameter[n].c_real;
            parameter[n].c_imag = o.parameter[n].c_imag;
            parameter[n].g_real = o.parameter[n].g_real;
            parameter[n].g_imag = o.parameter[n].g_imag;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct pulse_model_expsum<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef pulse_model_expsum<rebind_it> type;
    };

    enum { id_main = 107, id_sub = 0};

    double           delay;
    double           scale;
    std::size_t parameter_size;
    enum { parameter_max_size = 100 };
    struct sequence_definition {
        double           c_real;
        double           c_imag;
        double           g_real;
        double           g_imag;
    } parameter[100];

    pulse_model_expsum()
        : delay()
        , scale()
    {}

    template<class it>
    pulse_model_expsum(const pulse_model_expsum<it>& o) {
        delay = o.delay;
        scale = o.scale;
        parameter_size = o.parameter.size();
        for(unsigned n=0; n<parameter_size; ++n){
            parameter[n].c_real = o.parameter[n].c_real;
            parameter[n].c_imag = o.parameter[n].c_imag;
            parameter[n].g_real = o.parameter[n].g_real;
            parameter[n].g_imag = o.parameter[n].g_imag;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const pulse_model_expsum<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.delay;
        s << ", " << x.scale;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.parameter_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.parameter[n].c_real
            << ", " << x.parameter[n].c_imag
            << ", " << x.parameter[n].g_real
            << ", " << x.parameter[n].g_imag
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, pulse_model_expsum<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.delay;
        s >> ',' >> x.scale;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.parameter_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.parameter_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.parameter[x.parameter_size-1].c_real)
            >> ',' >> (x.parameter[x.parameter_size-1].c_imag)
            >> ',' >> (x.parameter[x.parameter_size-1].g_real)
            >> ',' >> (x.parameter[x.parameter_size-1].g_imag)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct pulse_position_modulation
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef pulse_position_modulation<rebind_it> type;
    };

    typedef it iterator_type;

    pulse_position_modulation(it begin, it end, bool dirty=false)
        : length(begin)
        , num_mod_ampl(begin)
        , seq(begin, end, seq_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 120, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32800};
    it begin() const { return length.begin(); }
    it end() const { return seq.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t length;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> length;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t num_mod_ampl;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> num_mod_ampl;
    #endif //DOXYGEN

    std::size_t seq_size;
    enum { seq_max_size = 1024 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : pulse_interval(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float pulse_interval;
        #else
        binary::field<float, sc_float32, 0, it> pulse_interval;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition seq[1024];
    #else
    sequence<pulse_position_modulation, 32, 32, it> seq;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    pulse_position_modulation& operator=(const pulse_position_modulation<ito>& o) {
        length = o.length;
        num_mod_ampl = o.num_mod_ampl;
        seq_size = o.seq_size;
        seq.clean();
        for(unsigned n=0; n<seq_size; ++n){
            seq[n].pulse_interval = o.seq[n].pulse_interval;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct pulse_position_modulation<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef pulse_position_modulation<rebind_it> type;
    };

    enum { id_main = 120, id_sub = 0};

    uint16_t         length;
    uint16_t         num_mod_ampl;
    std::size_t seq_size;
    enum { seq_max_size = 1024 };
    struct sequence_definition {
        float            pulse_interval;
    } seq[1024];

    pulse_position_modulation()
        : length()
        , num_mod_ampl()
    {}

    template<class it>
    pulse_position_modulation(const pulse_position_modulation<it>& o) {
        length = o.length;
        num_mod_ampl = o.num_mod_ampl;
        seq_size = o.seq.size();
        for(unsigned n=0; n<seq_size; ++n){
            seq[n].pulse_interval = o.seq[n].pulse_interval;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const pulse_position_modulation<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.length;
        s << ", " << x.num_mod_ampl;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.seq_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.seq[n].pulse_interval
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, pulse_position_modulation<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.length;
        s >> ',' >> x.num_mod_ampl;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.seq_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.seq_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.seq[x.seq_size-1].pulse_interval)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct pulse_position_modulation_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef pulse_position_modulation_1<rebind_it> type;
    };

    typedef it iterator_type;

    pulse_position_modulation_1(it begin, it end, bool dirty=false)
        : length(begin)
        , num_mod_ampl(begin)
        , code_phase_mode(begin)
        , phase_step(begin)
        , seq(begin, end, seq_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 131, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8224};
    it begin() const { return length.begin(); }
    it end() const { return seq.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t length;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> length;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_mod_ampl;
    #else
    binary::field<uint8_t, sc_uint8, 8, it> num_mod_ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t code_phase_mode;
    #else
    binary::field<uint8_t, sc_uint8, 16, it> code_phase_mode;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t phase_step;
    #else
    binary::field<uint8_t, sc_uint8, 24, it> phase_step;
    #endif //DOXYGEN

    std::size_t seq_size;
    enum { seq_max_size = 256 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : pulse_interval(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float pulse_interval;
        #else
        binary::field<float, sc_float32, 0, it> pulse_interval;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition seq[256];
    #else
    sequence<pulse_position_modulation_1, 32, 32, it> seq;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    pulse_position_modulation_1& operator=(const pulse_position_modulation_1<ito>& o) {
        length = o.length;
        num_mod_ampl = o.num_mod_ampl;
        code_phase_mode = o.code_phase_mode;
        phase_step = o.phase_step;
        seq_size = o.seq_size;
        seq.clean();
        for(unsigned n=0; n<seq_size; ++n){
            seq[n].pulse_interval = o.seq[n].pulse_interval;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct pulse_position_modulation_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef pulse_position_modulation_1<rebind_it> type;
    };

    enum { id_main = 131, id_sub = 0};

    uint8_t          length;
    uint8_t          num_mod_ampl;
    uint8_t          code_phase_mode;
    uint8_t          phase_step;
    std::size_t seq_size;
    enum { seq_max_size = 256 };
    struct sequence_definition {
        float            pulse_interval;
    } seq[256];

    pulse_position_modulation_1()
        : length()
        , num_mod_ampl()
        , code_phase_mode()
        , phase_step()
    {}

    template<class it>
    pulse_position_modulation_1(const pulse_position_modulation_1<it>& o) {
        length = o.length;
        num_mod_ampl = o.num_mod_ampl;
        code_phase_mode = o.code_phase_mode;
        phase_step = o.phase_step;
        seq_size = o.seq.size();
        for(unsigned n=0; n<seq_size; ++n){
            seq[n].pulse_interval = o.seq[n].pulse_interval;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const pulse_position_modulation_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.length;
        s << ", " << x.num_mod_ampl;
        s << ", " << x.code_phase_mode;
        s << ", " << x.phase_step;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.seq_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.seq[n].pulse_interval
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, pulse_position_modulation_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.length;
        s >> ',' >> x.num_mod_ampl;
        s >> ',' >> x.code_phase_mode;
        s >> ',' >> x.phase_step;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.seq_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.seq_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.seq[x.seq_size-1].pulse_interval)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! external pwm signal input

//! <para>This package belongs to the predefined selectors:</para>
//! <para>status</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct pwm_sync
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef pwm_sync<rebind_it> type;
    };

    typedef it iterator_type;

    pwm_sync(it begin, it end, bool dirty=false)
        : systime(begin)
        , pulseWidth(begin)
        , polarity(begin)
        , pulseCounter(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 97, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return systime.begin(); }
    it end() const { return pulseCounter.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t pulseWidth;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> pulseWidth;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t polarity;
    #else
    binary::field<uint8_t, sc_bit, 64, it> polarity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t pulseCounter;
    #else
    binary::field<uint32_t, sc_uint31, 65, it> pulseCounter;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    pwm_sync& operator=(const pwm_sync<ito>& o) {
        systime = o.systime;
        pulseWidth = o.pulseWidth;
        polarity = o.polarity;
        pulseCounter = o.pulseCounter;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct pwm_sync<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef pwm_sync<rebind_it> type;
    };

    enum { id_main = 97, id_sub = 0};

    uint32_t         systime;
    uint32_t         pulseWidth;
    uint8_t          polarity;
    uint32_t         pulseCounter;

    pwm_sync()
        : systime()
        , pulseWidth()
        , polarity()
        , pulseCounter()
    {}

    template<class it>
    pwm_sync(const pwm_sync<it>& o) {
        systime = o.systime;
        pulseWidth = o.pulseWidth;
        polarity = o.polarity;
        pulseCounter = o.pulseCounter;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const pwm_sync<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.pulseWidth;
        s << ", " << x.polarity;
        s << ", " << x.pulseCounter;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, pwm_sync<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.pulseWidth;
        s >> ',' >> x.polarity;
        s >> ',' >> x.pulseCounter;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_calc
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_calc<rebind_it> type;
    };

    typedef it iterator_type;

    range_calc(it begin, it end, bool dirty=false)
        : scale(begin)
        , offset(begin)
        , startpos(begin)
        , full_scale_adc_lp(begin)
        , full_scale_adc_hp(begin)
        , full_scale_adc_shp(begin)
        , full_scale_adc_i(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50005, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 160};
    it begin() const { return scale.begin(); }
    it end() const { return full_scale_adc_i.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float scale;
    #else
    binary::field<float, sc_float32, 0, it> scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float offset;
    #else
    binary::field<float, sc_float32, 32, it> offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t startpos;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> startpos;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t full_scale_adc_lp;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> full_scale_adc_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t full_scale_adc_hp;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> full_scale_adc_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t full_scale_adc_shp;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> full_scale_adc_shp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t full_scale_adc_i;
    #else
    binary::field<uint16_t, sc_uint16, 144, it> full_scale_adc_i;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_calc& operator=(const range_calc<ito>& o) {
        scale = o.scale;
        offset = o.offset;
        startpos = o.startpos;
        full_scale_adc_lp = o.full_scale_adc_lp;
        full_scale_adc_hp = o.full_scale_adc_hp;
        full_scale_adc_shp = o.full_scale_adc_shp;
        full_scale_adc_i = o.full_scale_adc_i;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_calc<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_calc<rebind_it> type;
    };

    enum { id_main = 50005, id_sub = 0};

    float            scale;
    float            offset;
    uint32_t         startpos;
    uint16_t         full_scale_adc_lp;
    uint16_t         full_scale_adc_hp;
    uint16_t         full_scale_adc_shp;
    uint16_t         full_scale_adc_i;

    range_calc()
        : scale()
        , offset()
        , startpos()
        , full_scale_adc_lp()
        , full_scale_adc_hp()
        , full_scale_adc_shp()
        , full_scale_adc_i()
    {}

    template<class it>
    range_calc(const range_calc<it>& o) {
        scale = o.scale;
        offset = o.offset;
        startpos = o.startpos;
        full_scale_adc_lp = o.full_scale_adc_lp;
        full_scale_adc_hp = o.full_scale_adc_hp;
        full_scale_adc_shp = o.full_scale_adc_shp;
        full_scale_adc_i = o.full_scale_adc_i;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_calc<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.scale;
        s << ", " << x.offset;
        s << ", " << x.startpos;
        s << ", " << x.full_scale_adc_lp;
        s << ", " << x.full_scale_adc_hp;
        s << ", " << x.full_scale_adc_shp;
        s << ", " << x.full_scale_adc_i;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_calc<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.scale;
        s >> ',' >> x.offset;
        s >> ',' >> x.startpos;
        s >> ',' >> x.full_scale_adc_lp;
        s >> ',' >> x.full_scale_adc_hp;
        s >> ',' >> x.full_scale_adc_shp;
        s >> ',' >> x.full_scale_adc_i;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_debug_acq
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_acq<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_debug_acq(it begin, it end, bool dirty=false)
        : sog(begin)
        , eog(begin)
        , acq_min_thresh_lp(begin)
        , acq_min_thresh_hp(begin)
        , thres_tab_time(begin)
        , thres_tab_date(begin)
        , thres_tab_crc(begin)
        , max_targets_lo(begin)
        , max_targets_hi(begin)
        , meas_max_targets(begin)
        , shp_ampl_thresh(begin)
        , shp_ofs_thresh(begin)
        , shp_integ_length(begin)
        , shp_ampl_div(begin)
        , meas_mode(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 35, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 368};
    it begin() const { return sog.begin(); }
    it end() const { return meas_mode.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sog;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> sog;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t eog;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> eog;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t acq_min_thresh_lp;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> acq_min_thresh_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t acq_min_thresh_hp;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> acq_min_thresh_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char thres_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 96, it> thres_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char thres_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 168, it> thres_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t thres_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 240, it> thres_tab_crc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t max_targets_lo;
    #else
    binary::field<uint8_t, sc_uint8, 256, it> max_targets_lo;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t max_targets_hi;
    #else
    binary::field<uint8_t, sc_uint8, 264, it> max_targets_hi;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t meas_max_targets;
    #else
    binary::field<uint8_t, sc_uint8, 272, it> meas_max_targets;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t shp_ampl_thresh;
    #else
    binary::field<uint32_t, sc_uint32, 280, it> shp_ampl_thresh;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t shp_ofs_thresh;
    #else
    binary::field<uint32_t, sc_uint32, 312, it> shp_ofs_thresh;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t shp_integ_length;
    #else
    binary::field<uint8_t, sc_uint8, 344, it> shp_integ_length;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t shp_ampl_div;
    #else
    binary::field<uint8_t, sc_uint8, 352, it> shp_ampl_div;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t meas_mode;
    #else
    binary::field<uint8_t, sc_uint8, 360, it> meas_mode;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_debug_acq& operator=(const range_finder_debug_acq<ito>& o) {
        sog = o.sog;
        eog = o.eog;
        acq_min_thresh_lp = o.acq_min_thresh_lp;
        acq_min_thresh_hp = o.acq_min_thresh_hp;
        for(unsigned n=0; n<9; ++n) thres_tab_time[n] = o.thres_tab_time[n];
        for(unsigned n=0; n<9; ++n) thres_tab_date[n] = o.thres_tab_date[n];
        thres_tab_crc = o.thres_tab_crc;
        max_targets_lo = o.max_targets_lo;
        max_targets_hi = o.max_targets_hi;
        meas_max_targets = o.meas_max_targets;
        shp_ampl_thresh = o.shp_ampl_thresh;
        shp_ofs_thresh = o.shp_ofs_thresh;
        shp_integ_length = o.shp_integ_length;
        shp_ampl_div = o.shp_ampl_div;
        meas_mode = o.meas_mode;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_debug_acq<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_acq<rebind_it> type;
    };

    enum { id_main = 35, id_sub = 0};

    uint16_t         sog;
    uint16_t         eog;
    uint32_t         acq_min_thresh_lp;
    uint32_t         acq_min_thresh_hp;
    char             thres_tab_time[9];
    char             thres_tab_date[9];
    uint16_t         thres_tab_crc;
    uint8_t          max_targets_lo;
    uint8_t          max_targets_hi;
    uint8_t          meas_max_targets;
    uint32_t         shp_ampl_thresh;
    uint32_t         shp_ofs_thresh;
    uint8_t          shp_integ_length;
    uint8_t          shp_ampl_div;
    uint8_t          meas_mode;

    range_finder_debug_acq()
        : sog()
        , eog()
        , acq_min_thresh_lp()
        , acq_min_thresh_hp()
        , thres_tab_time()
        , thres_tab_date()
        , thres_tab_crc()
        , max_targets_lo()
        , max_targets_hi()
        , meas_max_targets()
        , shp_ampl_thresh()
        , shp_ofs_thresh()
        , shp_integ_length()
        , shp_ampl_div()
        , meas_mode()
    {}

    template<class it>
    range_finder_debug_acq(const range_finder_debug_acq<it>& o) {
        sog = o.sog;
        eog = o.eog;
        acq_min_thresh_lp = o.acq_min_thresh_lp;
        acq_min_thresh_hp = o.acq_min_thresh_hp;
        for(unsigned n=0; n<9; ++n) thres_tab_time[n] = o.thres_tab_time[n];
        for(unsigned n=0; n<9; ++n) thres_tab_date[n] = o.thres_tab_date[n];
        thres_tab_crc = o.thres_tab_crc;
        max_targets_lo = o.max_targets_lo;
        max_targets_hi = o.max_targets_hi;
        meas_max_targets = o.meas_max_targets;
        shp_ampl_thresh = o.shp_ampl_thresh;
        shp_ofs_thresh = o.shp_ofs_thresh;
        shp_integ_length = o.shp_integ_length;
        shp_ampl_div = o.shp_ampl_div;
        meas_mode = o.meas_mode;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_debug_acq<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.sog;
        s << ", " << x.eog;
        s << ", " << x.acq_min_thresh_lp;
        s << ", " << x.acq_min_thresh_hp;
        s << ", "; write_array(s, 9, x.thres_tab_time);
        s << ", "; write_array(s, 9, x.thres_tab_date);
        s << ", " << x.thres_tab_crc;
        s << ", " << x.max_targets_lo;
        s << ", " << x.max_targets_hi;
        s << ", " << x.meas_max_targets;
        s << ", " << x.shp_ampl_thresh;
        s << ", " << x.shp_ofs_thresh;
        s << ", " << x.shp_integ_length;
        s << ", " << x.shp_ampl_div;
        s << ", " << x.meas_mode;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_debug_acq<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.sog;
        s >> ',' >> x.eog;
        s >> ',' >> x.acq_min_thresh_lp;
        s >> ',' >> x.acq_min_thresh_hp;
        s >> ','; read_array(s, 9, x.thres_tab_time);
        s >> ','; read_array(s, 9, x.thres_tab_date);
        s >> ',' >> x.thres_tab_crc;
        s >> ',' >> x.max_targets_lo;
        s >> ',' >> x.max_targets_hi;
        s >> ',' >> x.meas_max_targets;
        s >> ',' >> x.shp_ampl_thresh;
        s >> ',' >> x.shp_ofs_thresh;
        s >> ',' >> x.shp_integ_length;
        s >> ',' >> x.shp_ampl_div;
        s >> ',' >> x.meas_mode;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_debug_acq_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_acq_1<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_debug_acq_1(it begin, it end, bool dirty=false)
        : sog(begin)
        , eog(begin)
        , acq_min_thresh_lp(begin)
        , acq_min_thresh_hp(begin)
        , thres_tab_time(begin)
        , thres_tab_date(begin)
        , thres_tab_crc(begin)
        , max_targets_lo(begin)
        , max_targets_hi(begin)
        , meas_max_targets(begin)
        , shp_ampl_thresh(begin)
        , shp_ofs_thresh(begin)
        , shp_integ_length(begin)
        , shp_ampl_div(begin)
        , meas_mode(begin)
        , acs(begin)
        , rng_dep_trig_threshold(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 35, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 384};
    it begin() const { return sog.begin(); }
    it end() const { return rng_dep_trig_threshold.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sog;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> sog;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t eog;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> eog;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t acq_min_thresh_lp;
    #else
    binary::field<uint32_t, sc_uint32, 32, it> acq_min_thresh_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t acq_min_thresh_hp;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> acq_min_thresh_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char thres_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 96, it> thres_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char thres_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 168, it> thres_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t thres_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 240, it> thres_tab_crc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t max_targets_lo;
    #else
    binary::field<uint8_t, sc_uint8, 256, it> max_targets_lo;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t max_targets_hi;
    #else
    binary::field<uint8_t, sc_uint8, 264, it> max_targets_hi;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t meas_max_targets;
    #else
    binary::field<uint8_t, sc_uint8, 272, it> meas_max_targets;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t shp_ampl_thresh;
    #else
    binary::field<uint32_t, sc_uint32, 280, it> shp_ampl_thresh;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t shp_ofs_thresh;
    #else
    binary::field<uint32_t, sc_uint32, 312, it> shp_ofs_thresh;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t shp_integ_length;
    #else
    binary::field<uint8_t, sc_uint8, 344, it> shp_integ_length;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t shp_ampl_div;
    #else
    binary::field<uint8_t, sc_uint8, 352, it> shp_ampl_div;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t meas_mode;
    #else
    binary::field<uint8_t, sc_uint8, 360, it> meas_mode;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t acs;
    #else
    binary::field<uint8_t, sc_uint8, 368, it> acs;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t rng_dep_trig_threshold;
    #else
    binary::field<uint8_t, sc_uint8, 376, it> rng_dep_trig_threshold;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_debug_acq_1& operator=(const range_finder_debug_acq_1<ito>& o) {
        sog = o.sog;
        eog = o.eog;
        acq_min_thresh_lp = o.acq_min_thresh_lp;
        acq_min_thresh_hp = o.acq_min_thresh_hp;
        for(unsigned n=0; n<9; ++n) thres_tab_time[n] = o.thres_tab_time[n];
        for(unsigned n=0; n<9; ++n) thres_tab_date[n] = o.thres_tab_date[n];
        thres_tab_crc = o.thres_tab_crc;
        max_targets_lo = o.max_targets_lo;
        max_targets_hi = o.max_targets_hi;
        meas_max_targets = o.meas_max_targets;
        shp_ampl_thresh = o.shp_ampl_thresh;
        shp_ofs_thresh = o.shp_ofs_thresh;
        shp_integ_length = o.shp_integ_length;
        shp_ampl_div = o.shp_ampl_div;
        meas_mode = o.meas_mode;
        acs = o.acs;
        rng_dep_trig_threshold = o.rng_dep_trig_threshold;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_debug_acq_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_acq_1<rebind_it> type;
    };

    enum { id_main = 35, id_sub = 1};

    uint16_t         sog;
    uint16_t         eog;
    uint32_t         acq_min_thresh_lp;
    uint32_t         acq_min_thresh_hp;
    char             thres_tab_time[9];
    char             thres_tab_date[9];
    uint16_t         thres_tab_crc;
    uint8_t          max_targets_lo;
    uint8_t          max_targets_hi;
    uint8_t          meas_max_targets;
    uint32_t         shp_ampl_thresh;
    uint32_t         shp_ofs_thresh;
    uint8_t          shp_integ_length;
    uint8_t          shp_ampl_div;
    uint8_t          meas_mode;
    uint8_t          acs;
    uint8_t          rng_dep_trig_threshold;

    range_finder_debug_acq_1()
        : sog()
        , eog()
        , acq_min_thresh_lp()
        , acq_min_thresh_hp()
        , thres_tab_time()
        , thres_tab_date()
        , thres_tab_crc()
        , max_targets_lo()
        , max_targets_hi()
        , meas_max_targets()
        , shp_ampl_thresh()
        , shp_ofs_thresh()
        , shp_integ_length()
        , shp_ampl_div()
        , meas_mode()
        , acs()
        , rng_dep_trig_threshold()
    {}

    template<class it>
    range_finder_debug_acq_1(const range_finder_debug_acq_1<it>& o) {
        sog = o.sog;
        eog = o.eog;
        acq_min_thresh_lp = o.acq_min_thresh_lp;
        acq_min_thresh_hp = o.acq_min_thresh_hp;
        for(unsigned n=0; n<9; ++n) thres_tab_time[n] = o.thres_tab_time[n];
        for(unsigned n=0; n<9; ++n) thres_tab_date[n] = o.thres_tab_date[n];
        thres_tab_crc = o.thres_tab_crc;
        max_targets_lo = o.max_targets_lo;
        max_targets_hi = o.max_targets_hi;
        meas_max_targets = o.meas_max_targets;
        shp_ampl_thresh = o.shp_ampl_thresh;
        shp_ofs_thresh = o.shp_ofs_thresh;
        shp_integ_length = o.shp_integ_length;
        shp_ampl_div = o.shp_ampl_div;
        meas_mode = o.meas_mode;
        acs = o.acs;
        rng_dep_trig_threshold = o.rng_dep_trig_threshold;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_debug_acq_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.sog;
        s << ", " << x.eog;
        s << ", " << x.acq_min_thresh_lp;
        s << ", " << x.acq_min_thresh_hp;
        s << ", "; write_array(s, 9, x.thres_tab_time);
        s << ", "; write_array(s, 9, x.thres_tab_date);
        s << ", " << x.thres_tab_crc;
        s << ", " << x.max_targets_lo;
        s << ", " << x.max_targets_hi;
        s << ", " << x.meas_max_targets;
        s << ", " << x.shp_ampl_thresh;
        s << ", " << x.shp_ofs_thresh;
        s << ", " << x.shp_integ_length;
        s << ", " << x.shp_ampl_div;
        s << ", " << x.meas_mode;
        s << ", " << x.acs;
        s << ", " << x.rng_dep_trig_threshold;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_debug_acq_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.sog;
        s >> ',' >> x.eog;
        s >> ',' >> x.acq_min_thresh_lp;
        s >> ',' >> x.acq_min_thresh_hp;
        s >> ','; read_array(s, 9, x.thres_tab_time);
        s >> ','; read_array(s, 9, x.thres_tab_date);
        s >> ',' >> x.thres_tab_crc;
        s >> ',' >> x.max_targets_lo;
        s >> ',' >> x.max_targets_hi;
        s >> ',' >> x.meas_max_targets;
        s >> ',' >> x.shp_ampl_thresh;
        s >> ',' >> x.shp_ofs_thresh;
        s >> ',' >> x.shp_integ_length;
        s >> ',' >> x.shp_ampl_div;
        s >> ',' >> x.meas_mode;
        s >> ',' >> x.acs;
        s >> ',' >> x.rng_dep_trig_threshold;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_debug_calc
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_calc<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_debug_calc(it begin, it end, bool dirty=false)
        : pdae_tab_time(begin)
        , pdae_tab_date(begin)
        , pdae_tab_crc(begin)
        , ampl_tab_time(begin)
        , ampl_tab_date(begin)
        , ampl_tab_crc(begin)
        , filt_ampl_min(begin)
        , filt_rng_min(begin)
        , rng_offset(begin)
        , rng_scale(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 36, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 448};
    it begin() const { return pdae_tab_time.begin(); }
    it end() const { return rng_scale.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char pdae_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 0, it> pdae_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char pdae_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 72, it> pdae_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pdae_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 144, it> pdae_tab_crc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char ampl_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 160, it> ampl_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char ampl_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 232, it> ampl_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 304, it> ampl_tab_crc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t filt_ampl_min;
    #else
    binary::field<uint32_t, sc_uint32, 320, it> filt_ampl_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float filt_rng_min;
    #else
    binary::field<float, sc_float32, 352, it> filt_rng_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_offset;
    #else
    binary::field<float, sc_float32, 384, it> rng_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_scale;
    #else
    binary::field<float, sc_float32, 416, it> rng_scale;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_debug_calc& operator=(const range_finder_debug_calc<ito>& o) {
        for(unsigned n=0; n<9; ++n) pdae_tab_time[n] = o.pdae_tab_time[n];
        for(unsigned n=0; n<9; ++n) pdae_tab_date[n] = o.pdae_tab_date[n];
        pdae_tab_crc = o.pdae_tab_crc;
        for(unsigned n=0; n<9; ++n) ampl_tab_time[n] = o.ampl_tab_time[n];
        for(unsigned n=0; n<9; ++n) ampl_tab_date[n] = o.ampl_tab_date[n];
        ampl_tab_crc = o.ampl_tab_crc;
        filt_ampl_min = o.filt_ampl_min;
        filt_rng_min = o.filt_rng_min;
        rng_offset = o.rng_offset;
        rng_scale = o.rng_scale;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_debug_calc<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_calc<rebind_it> type;
    };

    enum { id_main = 36, id_sub = 0};

    char             pdae_tab_time[9];
    char             pdae_tab_date[9];
    uint16_t         pdae_tab_crc;
    char             ampl_tab_time[9];
    char             ampl_tab_date[9];
    uint16_t         ampl_tab_crc;
    uint32_t         filt_ampl_min;
    float            filt_rng_min;
    float            rng_offset;
    float            rng_scale;

    range_finder_debug_calc()
        : pdae_tab_time()
        , pdae_tab_date()
        , pdae_tab_crc()
        , ampl_tab_time()
        , ampl_tab_date()
        , ampl_tab_crc()
        , filt_ampl_min()
        , filt_rng_min()
        , rng_offset()
        , rng_scale()
    {}

    template<class it>
    range_finder_debug_calc(const range_finder_debug_calc<it>& o) {
        for(unsigned n=0; n<9; ++n) pdae_tab_time[n] = o.pdae_tab_time[n];
        for(unsigned n=0; n<9; ++n) pdae_tab_date[n] = o.pdae_tab_date[n];
        pdae_tab_crc = o.pdae_tab_crc;
        for(unsigned n=0; n<9; ++n) ampl_tab_time[n] = o.ampl_tab_time[n];
        for(unsigned n=0; n<9; ++n) ampl_tab_date[n] = o.ampl_tab_date[n];
        ampl_tab_crc = o.ampl_tab_crc;
        filt_ampl_min = o.filt_ampl_min;
        filt_rng_min = o.filt_rng_min;
        rng_offset = o.rng_offset;
        rng_scale = o.rng_scale;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_debug_calc<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 9, x.pdae_tab_time);
        s << ", "; write_array(s, 9, x.pdae_tab_date);
        s << ", " << x.pdae_tab_crc;
        s << ", "; write_array(s, 9, x.ampl_tab_time);
        s << ", "; write_array(s, 9, x.ampl_tab_date);
        s << ", " << x.ampl_tab_crc;
        s << ", " << x.filt_ampl_min;
        s << ", " << x.filt_rng_min;
        s << ", " << x.rng_offset;
        s << ", " << x.rng_scale;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_debug_calc<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 9, x.pdae_tab_time);
        s >> ','; read_array(s, 9, x.pdae_tab_date);
        s >> ',' >> x.pdae_tab_crc;
        s >> ','; read_array(s, 9, x.ampl_tab_time);
        s >> ','; read_array(s, 9, x.ampl_tab_date);
        s >> ',' >> x.ampl_tab_crc;
        s >> ',' >> x.filt_ampl_min;
        s >> ',' >> x.filt_rng_min;
        s >> ',' >> x.rng_offset;
        s >> ',' >> x.rng_scale;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_debug_calc_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_calc_1<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_debug_calc_1(it begin, it end, bool dirty=false)
        : pdae_tab_time(begin)
        , pdae_tab_date(begin)
        , pdae_tab_crc(begin)
        , ampl_tab_time(begin)
        , ampl_tab_date(begin)
        , ampl_tab_crc(begin)
        , filt_ampl_min(begin)
        , filt_rng_min(begin)
        , rng_offset(begin)
        , rng_scale(begin)
        , refl_tab_time(begin)
        , refl_tab_date(begin)
        , refl_tab_crc(begin)
        , nrc_tab_time(begin)
        , nrc_tab_date(begin)
        , nrc_tab_crc(begin)
        , filt_ampl_max(begin)
        , filt_rng_max(begin)
        , filt_dev_min(begin)
        , filt_dev_max(begin)
        , filt_refl_min(begin)
        , filt_refl_max(begin)
        , filt_wfm_dev_lim(begin)
        , filt_notch_rng_min(begin)
        , filt_notch_rng_max(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 36, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 1008};
    it begin() const { return pdae_tab_time.begin(); }
    it end() const { return filt_notch_rng_max.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char pdae_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 0, it> pdae_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char pdae_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 72, it> pdae_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pdae_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 144, it> pdae_tab_crc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char ampl_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 160, it> ampl_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char ampl_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 232, it> ampl_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 304, it> ampl_tab_crc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t filt_ampl_min;
    #else
    binary::field<uint32_t, sc_uint32, 320, it> filt_ampl_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float filt_rng_min;
    #else
    binary::field<float, sc_float32, 352, it> filt_rng_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_offset;
    #else
    binary::field<float, sc_float32, 384, it> rng_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_scale;
    #else
    binary::field<float, sc_float32, 416, it> rng_scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char refl_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 448, it> refl_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char refl_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 520, it> refl_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t refl_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 592, it> refl_tab_crc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char nrc_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 608, it> nrc_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char nrc_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 680, it> nrc_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t nrc_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 752, it> nrc_tab_crc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t filt_ampl_max;
    #else
    binary::field<uint32_t, sc_uint32, 768, it> filt_ampl_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float filt_rng_max;
    #else
    binary::field<float, sc_float32, 800, it> filt_rng_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t filt_dev_min;
    #else
    binary::field<uint16_t, sc_uint16, 832, it> filt_dev_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t filt_dev_max;
    #else
    binary::field<uint16_t, sc_uint16, 848, it> filt_dev_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float filt_refl_min;
    #else
    binary::field<float, sc_float32, 864, it> filt_refl_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float filt_refl_max;
    #else
    binary::field<float, sc_float32, 896, it> filt_refl_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t filt_wfm_dev_lim;
    #else
    binary::field<uint16_t, sc_uint16, 928, it> filt_wfm_dev_lim;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float filt_notch_rng_min;
    #else
    binary::field<float, sc_float32, 944, it> filt_notch_rng_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float filt_notch_rng_max;
    #else
    binary::field<float, sc_float32, 976, it> filt_notch_rng_max;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_debug_calc_1& operator=(const range_finder_debug_calc_1<ito>& o) {
        for(unsigned n=0; n<9; ++n) pdae_tab_time[n] = o.pdae_tab_time[n];
        for(unsigned n=0; n<9; ++n) pdae_tab_date[n] = o.pdae_tab_date[n];
        pdae_tab_crc = o.pdae_tab_crc;
        for(unsigned n=0; n<9; ++n) ampl_tab_time[n] = o.ampl_tab_time[n];
        for(unsigned n=0; n<9; ++n) ampl_tab_date[n] = o.ampl_tab_date[n];
        ampl_tab_crc = o.ampl_tab_crc;
        filt_ampl_min = o.filt_ampl_min;
        filt_rng_min = o.filt_rng_min;
        rng_offset = o.rng_offset;
        rng_scale = o.rng_scale;
        for(unsigned n=0; n<9; ++n) refl_tab_time[n] = o.refl_tab_time[n];
        for(unsigned n=0; n<9; ++n) refl_tab_date[n] = o.refl_tab_date[n];
        refl_tab_crc = o.refl_tab_crc;
        for(unsigned n=0; n<9; ++n) nrc_tab_time[n] = o.nrc_tab_time[n];
        for(unsigned n=0; n<9; ++n) nrc_tab_date[n] = o.nrc_tab_date[n];
        nrc_tab_crc = o.nrc_tab_crc;
        filt_ampl_max = o.filt_ampl_max;
        filt_rng_max = o.filt_rng_max;
        filt_dev_min = o.filt_dev_min;
        filt_dev_max = o.filt_dev_max;
        filt_refl_min = o.filt_refl_min;
        filt_refl_max = o.filt_refl_max;
        filt_wfm_dev_lim = o.filt_wfm_dev_lim;
        filt_notch_rng_min = o.filt_notch_rng_min;
        filt_notch_rng_max = o.filt_notch_rng_max;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_debug_calc_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_calc_1<rebind_it> type;
    };

    enum { id_main = 36, id_sub = 1};

    char             pdae_tab_time[9];
    char             pdae_tab_date[9];
    uint16_t         pdae_tab_crc;
    char             ampl_tab_time[9];
    char             ampl_tab_date[9];
    uint16_t         ampl_tab_crc;
    uint32_t         filt_ampl_min;
    float            filt_rng_min;
    float            rng_offset;
    float            rng_scale;
    char             refl_tab_time[9];
    char             refl_tab_date[9];
    uint16_t         refl_tab_crc;
    char             nrc_tab_time[9];
    char             nrc_tab_date[9];
    uint16_t         nrc_tab_crc;
    uint32_t         filt_ampl_max;
    float            filt_rng_max;
    uint16_t         filt_dev_min;
    uint16_t         filt_dev_max;
    float            filt_refl_min;
    float            filt_refl_max;
    uint16_t         filt_wfm_dev_lim;
    float            filt_notch_rng_min;
    float            filt_notch_rng_max;

    range_finder_debug_calc_1()
        : pdae_tab_time()
        , pdae_tab_date()
        , pdae_tab_crc()
        , ampl_tab_time()
        , ampl_tab_date()
        , ampl_tab_crc()
        , filt_ampl_min()
        , filt_rng_min()
        , rng_offset()
        , rng_scale()
        , refl_tab_time()
        , refl_tab_date()
        , refl_tab_crc()
        , nrc_tab_time()
        , nrc_tab_date()
        , nrc_tab_crc()
        , filt_ampl_max()
        , filt_rng_max()
        , filt_dev_min()
        , filt_dev_max()
        , filt_refl_min()
        , filt_refl_max()
        , filt_wfm_dev_lim()
        , filt_notch_rng_min()
        , filt_notch_rng_max()
    {}

    template<class it>
    range_finder_debug_calc_1(const range_finder_debug_calc_1<it>& o) {
        for(unsigned n=0; n<9; ++n) pdae_tab_time[n] = o.pdae_tab_time[n];
        for(unsigned n=0; n<9; ++n) pdae_tab_date[n] = o.pdae_tab_date[n];
        pdae_tab_crc = o.pdae_tab_crc;
        for(unsigned n=0; n<9; ++n) ampl_tab_time[n] = o.ampl_tab_time[n];
        for(unsigned n=0; n<9; ++n) ampl_tab_date[n] = o.ampl_tab_date[n];
        ampl_tab_crc = o.ampl_tab_crc;
        filt_ampl_min = o.filt_ampl_min;
        filt_rng_min = o.filt_rng_min;
        rng_offset = o.rng_offset;
        rng_scale = o.rng_scale;
        for(unsigned n=0; n<9; ++n) refl_tab_time[n] = o.refl_tab_time[n];
        for(unsigned n=0; n<9; ++n) refl_tab_date[n] = o.refl_tab_date[n];
        refl_tab_crc = o.refl_tab_crc;
        for(unsigned n=0; n<9; ++n) nrc_tab_time[n] = o.nrc_tab_time[n];
        for(unsigned n=0; n<9; ++n) nrc_tab_date[n] = o.nrc_tab_date[n];
        nrc_tab_crc = o.nrc_tab_crc;
        filt_ampl_max = o.filt_ampl_max;
        filt_rng_max = o.filt_rng_max;
        filt_dev_min = o.filt_dev_min;
        filt_dev_max = o.filt_dev_max;
        filt_refl_min = o.filt_refl_min;
        filt_refl_max = o.filt_refl_max;
        filt_wfm_dev_lim = o.filt_wfm_dev_lim;
        filt_notch_rng_min = o.filt_notch_rng_min;
        filt_notch_rng_max = o.filt_notch_rng_max;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_debug_calc_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 9, x.pdae_tab_time);
        s << ", "; write_array(s, 9, x.pdae_tab_date);
        s << ", " << x.pdae_tab_crc;
        s << ", "; write_array(s, 9, x.ampl_tab_time);
        s << ", "; write_array(s, 9, x.ampl_tab_date);
        s << ", " << x.ampl_tab_crc;
        s << ", " << x.filt_ampl_min;
        s << ", " << x.filt_rng_min;
        s << ", " << x.rng_offset;
        s << ", " << x.rng_scale;
        s << ", "; write_array(s, 9, x.refl_tab_time);
        s << ", "; write_array(s, 9, x.refl_tab_date);
        s << ", " << x.refl_tab_crc;
        s << ", "; write_array(s, 9, x.nrc_tab_time);
        s << ", "; write_array(s, 9, x.nrc_tab_date);
        s << ", " << x.nrc_tab_crc;
        s << ", " << x.filt_ampl_max;
        s << ", " << x.filt_rng_max;
        s << ", " << x.filt_dev_min;
        s << ", " << x.filt_dev_max;
        s << ", " << x.filt_refl_min;
        s << ", " << x.filt_refl_max;
        s << ", " << x.filt_wfm_dev_lim;
        s << ", " << x.filt_notch_rng_min;
        s << ", " << x.filt_notch_rng_max;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_debug_calc_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 9, x.pdae_tab_time);
        s >> ','; read_array(s, 9, x.pdae_tab_date);
        s >> ',' >> x.pdae_tab_crc;
        s >> ','; read_array(s, 9, x.ampl_tab_time);
        s >> ','; read_array(s, 9, x.ampl_tab_date);
        s >> ',' >> x.ampl_tab_crc;
        s >> ',' >> x.filt_ampl_min;
        s >> ',' >> x.filt_rng_min;
        s >> ',' >> x.rng_offset;
        s >> ',' >> x.rng_scale;
        s >> ','; read_array(s, 9, x.refl_tab_time);
        s >> ','; read_array(s, 9, x.refl_tab_date);
        s >> ',' >> x.refl_tab_crc;
        s >> ','; read_array(s, 9, x.nrc_tab_time);
        s >> ','; read_array(s, 9, x.nrc_tab_date);
        s >> ',' >> x.nrc_tab_crc;
        s >> ',' >> x.filt_ampl_max;
        s >> ',' >> x.filt_rng_max;
        s >> ',' >> x.filt_dev_min;
        s >> ',' >> x.filt_dev_max;
        s >> ',' >> x.filt_refl_min;
        s >> ',' >> x.filt_refl_max;
        s >> ',' >> x.filt_wfm_dev_lim;
        s >> ',' >> x.filt_notch_rng_min;
        s >> ',' >> x.filt_notch_rng_max;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_debug_laser
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_laser<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_debug_laser(it begin, it end, bool dirty=false)
        : laser_clock(begin)
        , laser_pump(begin)
        , laser_prr(begin)
        , laser_tec_w(begin)
        , shp_shutdown_th(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 34, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 120};
    it begin() const { return laser_clock.begin(); }
    it end() const { return shp_shutdown_th.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t laser_clock;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> laser_clock;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t laser_pump;
    #else
    binary::field<uint16_t, sc_uint16, 8, it> laser_pump;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_prr;
    #else
    binary::field<float, sc_float32, 24, it> laser_prr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_tec_w;
    #else
    binary::field<float, sc_float32, 56, it> laser_tec_w;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t shp_shutdown_th;
    #else
    binary::field<uint32_t, sc_uint32, 88, it> shp_shutdown_th;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_debug_laser& operator=(const range_finder_debug_laser<ito>& o) {
        laser_clock = o.laser_clock;
        laser_pump = o.laser_pump;
        laser_prr = o.laser_prr;
        laser_tec_w = o.laser_tec_w;
        shp_shutdown_th = o.shp_shutdown_th;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_debug_laser<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_laser<rebind_it> type;
    };

    enum { id_main = 34, id_sub = 0};

    uint8_t          laser_clock;
    uint16_t         laser_pump;
    float            laser_prr;
    float            laser_tec_w;
    uint32_t         shp_shutdown_th;

    range_finder_debug_laser()
        : laser_clock()
        , laser_pump()
        , laser_prr()
        , laser_tec_w()
        , shp_shutdown_th()
    {}

    template<class it>
    range_finder_debug_laser(const range_finder_debug_laser<it>& o) {
        laser_clock = o.laser_clock;
        laser_pump = o.laser_pump;
        laser_prr = o.laser_prr;
        laser_tec_w = o.laser_tec_w;
        shp_shutdown_th = o.shp_shutdown_th;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_debug_laser<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.laser_clock;
        s << ", " << x.laser_pump;
        s << ", " << x.laser_prr;
        s << ", " << x.laser_tec_w;
        s << ", " << x.shp_shutdown_th;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_debug_laser<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.laser_clock;
        s >> ',' >> x.laser_pump;
        s >> ',' >> x.laser_prr;
        s >> ',' >> x.laser_tec_w;
        s >> ',' >> x.shp_shutdown_th;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_debug_laser_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_laser_1<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_debug_laser_1(it begin, it end, bool dirty=false)
        : laser_clock(begin)
        , laser_pump(begin)
        , laser_prr(begin)
        , laser_tec_w(begin)
        , shp_shutdown_th(begin)
        , laser_power(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 34, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 152};
    it begin() const { return laser_clock.begin(); }
    it end() const { return laser_power.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t laser_clock;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> laser_clock;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t laser_pump;
    #else
    binary::field<uint16_t, sc_uint16, 8, it> laser_pump;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_prr;
    #else
    binary::field<float, sc_float32, 24, it> laser_prr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_tec_w;
    #else
    binary::field<float, sc_float32, 56, it> laser_tec_w;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t shp_shutdown_th;
    #else
    binary::field<uint32_t, sc_uint32, 88, it> shp_shutdown_th;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_power;
    #else
    binary::field<float, sc_float32, 120, it> laser_power;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_debug_laser_1& operator=(const range_finder_debug_laser_1<ito>& o) {
        laser_clock = o.laser_clock;
        laser_pump = o.laser_pump;
        laser_prr = o.laser_prr;
        laser_tec_w = o.laser_tec_w;
        shp_shutdown_th = o.shp_shutdown_th;
        laser_power = o.laser_power;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_debug_laser_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_laser_1<rebind_it> type;
    };

    enum { id_main = 34, id_sub = 1};

    uint8_t          laser_clock;
    uint16_t         laser_pump;
    float            laser_prr;
    float            laser_tec_w;
    uint32_t         shp_shutdown_th;
    float            laser_power;

    range_finder_debug_laser_1()
        : laser_clock()
        , laser_pump()
        , laser_prr()
        , laser_tec_w()
        , shp_shutdown_th()
        , laser_power()
    {}

    template<class it>
    range_finder_debug_laser_1(const range_finder_debug_laser_1<it>& o) {
        laser_clock = o.laser_clock;
        laser_pump = o.laser_pump;
        laser_prr = o.laser_prr;
        laser_tec_w = o.laser_tec_w;
        shp_shutdown_th = o.shp_shutdown_th;
        laser_power = o.laser_power;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_debug_laser_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.laser_clock;
        s << ", " << x.laser_pump;
        s << ", " << x.laser_prr;
        s << ", " << x.laser_tec_w;
        s << ", " << x.shp_shutdown_th;
        s << ", " << x.laser_power;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_debug_laser_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.laser_clock;
        s >> ',' >> x.laser_pump;
        s >> ',' >> x.laser_prr;
        s >> ',' >> x.laser_tec_w;
        s >> ',' >> x.shp_shutdown_th;
        s >> ',' >> x.laser_power;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_debug_rcv
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_rcv<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_debug_rcv(it begin, it end, bool dirty=false)
        : rcv_rpr_mode(begin)
        , rcv_rpr_w(begin)
        , rcv_hv_w(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 37, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 72};
    it begin() const { return rcv_rpr_mode.begin(); }
    it end() const { return rcv_hv_w.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t rcv_rpr_mode;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> rcv_rpr_mode;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rcv_rpr_w;
    #else
    binary::field<float, sc_float32, 8, it> rcv_rpr_w;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rcv_hv_w;
    #else
    binary::field<float, sc_float32, 40, it> rcv_hv_w;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_debug_rcv& operator=(const range_finder_debug_rcv<ito>& o) {
        rcv_rpr_mode = o.rcv_rpr_mode;
        rcv_rpr_w = o.rcv_rpr_w;
        rcv_hv_w = o.rcv_hv_w;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_debug_rcv<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_debug_rcv<rebind_it> type;
    };

    enum { id_main = 37, id_sub = 0};

    uint8_t          rcv_rpr_mode;
    float            rcv_rpr_w;
    float            rcv_hv_w;

    range_finder_debug_rcv()
        : rcv_rpr_mode()
        , rcv_rpr_w()
        , rcv_hv_w()
    {}

    template<class it>
    range_finder_debug_rcv(const range_finder_debug_rcv<it>& o) {
        rcv_rpr_mode = o.rcv_rpr_mode;
        rcv_rpr_w = o.rcv_rpr_w;
        rcv_hv_w = o.rcv_hv_w;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_debug_rcv<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.rcv_rpr_mode;
        s << ", " << x.rcv_rpr_w;
        s << ", " << x.rcv_hv_w;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_debug_rcv<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.rcv_rpr_mode;
        s >> ',' >> x.rcv_rpr_w;
        s >> ',' >> x.rcv_hv_w;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_program
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_program<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_program(it begin, it end, bool dirty=false)
        : meas_prog(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 38, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8};
    it begin() const { return meas_prog.begin(); }
    it end() const { return meas_prog.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t meas_prog;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> meas_prog;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_program& operator=(const range_finder_program<ito>& o) {
        meas_prog = o.meas_prog;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_program<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_program<rebind_it> type;
    };

    enum { id_main = 38, id_sub = 0};

    uint8_t          meas_prog;

    range_finder_program()
        : meas_prog()
    {}

    template<class it>
    range_finder_program(const range_finder_program<it>& o) {
        meas_prog = o.meas_prog;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_program<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.meas_prog;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_program<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.meas_prog;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_program_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_program_1<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_program_1(it begin, it end, bool dirty=false)
        : meas_prog(begin)
        , name(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 38, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 520};
    it begin() const { return meas_prog.begin(); }
    it end() const { return name.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t meas_prog;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> meas_prog;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char name[64];
    #else
    binary::array<char, 64, sc_char, 8, it> name;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_program_1& operator=(const range_finder_program_1<ito>& o) {
        meas_prog = o.meas_prog;
        for(unsigned n=0; n<64; ++n) name[n] = o.name[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_program_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_program_1<rebind_it> type;
    };

    enum { id_main = 38, id_sub = 1};

    uint8_t          meas_prog;
    char             name[64];

    range_finder_program_1()
        : meas_prog()
        , name()
    {}

    template<class it>
    range_finder_program_1(const range_finder_program_1<it>& o) {
        meas_prog = o.meas_prog;
        for(unsigned n=0; n<64; ++n) name[n] = o.name[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_program_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.meas_prog;
        s << ", "; write_array(s, 64, x.name);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_program_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.meas_prog;
        s >> ','; read_array(s, 64, x.name);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_program_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_program_2<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_program_2(it begin, it end, bool dirty=false)
        : meas_prog(begin)
        , name(begin)
        , prr(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 38, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 584};
    it begin() const { return meas_prog.begin(); }
    it end() const { return prr.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t meas_prog;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> meas_prog;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char name[64];
    #else
    binary::array<char, 64, sc_char, 8, it> name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double prr;
    #else
    binary::field<double, sc_float64, 520, it> prr;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_program_2& operator=(const range_finder_program_2<ito>& o) {
        meas_prog = o.meas_prog;
        for(unsigned n=0; n<64; ++n) name[n] = o.name[n];
        prr = o.prr;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_program_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_program_2<rebind_it> type;
    };

    enum { id_main = 38, id_sub = 2};

    uint8_t          meas_prog;
    char             name[64];
    double           prr;

    range_finder_program_2()
        : meas_prog()
        , name()
        , prr()
    {}

    template<class it>
    range_finder_program_2(const range_finder_program_2<it>& o) {
        meas_prog = o.meas_prog;
        for(unsigned n=0; n<64; ++n) name[n] = o.name[n];
        prr = o.prr;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_program_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.meas_prog;
        s << ", "; write_array(s, 64, x.name);
        s << ", " << x.prr;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_program_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.meas_prog;
        s >> ','; read_array(s, 64, x.name);
        s >> ',' >> x.prr;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct range_finder_settings
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_settings<rebind_it> type;
    };

    typedef it iterator_type;

    range_finder_settings(it begin, it end, bool dirty=false)
        : laser_clock(begin)
        , laser_pump(begin)
        , laser_prr(begin)
        , meas_mode(begin)
        , sog(begin)
        , eog(begin)
        , max_targets_lo(begin)
        , max_targets_hi(begin)
        , rng_offset(begin)
        , pdae_tab_time(begin)
        , pdae_tab_date(begin)
        , pdae_tab_crc(begin)
        , thres_tab_time(begin)
        , thres_tab_date(begin)
        , thres_tab_crc(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 7, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 464};
    it begin() const { return laser_clock.begin(); }
    it end() const { return thres_tab_crc.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t laser_clock;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> laser_clock;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t laser_pump;
    #else
    binary::field<uint16_t, sc_uint16, 8, it> laser_pump;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float laser_prr;
    #else
    binary::field<float, sc_float32, 24, it> laser_prr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t meas_mode;
    #else
    binary::field<uint8_t, sc_uint8, 56, it> meas_mode;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sog;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> sog;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t eog;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> eog;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t max_targets_lo;
    #else
    binary::field<uint8_t, sc_uint8, 96, it> max_targets_lo;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t max_targets_hi;
    #else
    binary::field<uint8_t, sc_uint8, 104, it> max_targets_hi;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rng_offset;
    #else
    binary::field<float, sc_float32, 112, it> rng_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char pdae_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 144, it> pdae_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char pdae_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 216, it> pdae_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pdae_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> pdae_tab_crc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char thres_tab_time[9];
    #else
    binary::array<char, 9, sc_char, 304, it> thres_tab_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char thres_tab_date[9];
    #else
    binary::array<char, 9, sc_char, 376, it> thres_tab_date;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t thres_tab_crc;
    #else
    binary::field<uint16_t, sc_uint16, 448, it> thres_tab_crc;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    range_finder_settings& operator=(const range_finder_settings<ito>& o) {
        laser_clock = o.laser_clock;
        laser_pump = o.laser_pump;
        laser_prr = o.laser_prr;
        meas_mode = o.meas_mode;
        sog = o.sog;
        eog = o.eog;
        max_targets_lo = o.max_targets_lo;
        max_targets_hi = o.max_targets_hi;
        rng_offset = o.rng_offset;
        for(unsigned n=0; n<9; ++n) pdae_tab_time[n] = o.pdae_tab_time[n];
        for(unsigned n=0; n<9; ++n) pdae_tab_date[n] = o.pdae_tab_date[n];
        pdae_tab_crc = o.pdae_tab_crc;
        for(unsigned n=0; n<9; ++n) thres_tab_time[n] = o.thres_tab_time[n];
        for(unsigned n=0; n<9; ++n) thres_tab_date[n] = o.thres_tab_date[n];
        thres_tab_crc = o.thres_tab_crc;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct range_finder_settings<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef range_finder_settings<rebind_it> type;
    };

    enum { id_main = 7, id_sub = 0};

    uint8_t          laser_clock;
    uint16_t         laser_pump;
    float            laser_prr;
    uint8_t          meas_mode;
    uint16_t         sog;
    uint16_t         eog;
    uint8_t          max_targets_lo;
    uint8_t          max_targets_hi;
    float            rng_offset;
    char             pdae_tab_time[9];
    char             pdae_tab_date[9];
    uint16_t         pdae_tab_crc;
    char             thres_tab_time[9];
    char             thres_tab_date[9];
    uint16_t         thres_tab_crc;

    range_finder_settings()
        : laser_clock()
        , laser_pump()
        , laser_prr()
        , meas_mode()
        , sog()
        , eog()
        , max_targets_lo()
        , max_targets_hi()
        , rng_offset()
        , pdae_tab_time()
        , pdae_tab_date()
        , pdae_tab_crc()
        , thres_tab_time()
        , thres_tab_date()
        , thres_tab_crc()
    {}

    template<class it>
    range_finder_settings(const range_finder_settings<it>& o) {
        laser_clock = o.laser_clock;
        laser_pump = o.laser_pump;
        laser_prr = o.laser_prr;
        meas_mode = o.meas_mode;
        sog = o.sog;
        eog = o.eog;
        max_targets_lo = o.max_targets_lo;
        max_targets_hi = o.max_targets_hi;
        rng_offset = o.rng_offset;
        for(unsigned n=0; n<9; ++n) pdae_tab_time[n] = o.pdae_tab_time[n];
        for(unsigned n=0; n<9; ++n) pdae_tab_date[n] = o.pdae_tab_date[n];
        pdae_tab_crc = o.pdae_tab_crc;
        for(unsigned n=0; n<9; ++n) thres_tab_time[n] = o.thres_tab_time[n];
        for(unsigned n=0; n<9; ++n) thres_tab_date[n] = o.thres_tab_date[n];
        thres_tab_crc = o.thres_tab_crc;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const range_finder_settings<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.laser_clock;
        s << ", " << x.laser_pump;
        s << ", " << x.laser_prr;
        s << ", " << x.meas_mode;
        s << ", " << x.sog;
        s << ", " << x.eog;
        s << ", " << x.max_targets_lo;
        s << ", " << x.max_targets_hi;
        s << ", " << x.rng_offset;
        s << ", "; write_array(s, 9, x.pdae_tab_time);
        s << ", "; write_array(s, 9, x.pdae_tab_date);
        s << ", " << x.pdae_tab_crc;
        s << ", "; write_array(s, 9, x.thres_tab_time);
        s << ", "; write_array(s, 9, x.thres_tab_date);
        s << ", " << x.thres_tab_crc;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, range_finder_settings<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.laser_clock;
        s >> ',' >> x.laser_pump;
        s >> ',' >> x.laser_prr;
        s >> ',' >> x.meas_mode;
        s >> ',' >> x.sog;
        s >> ',' >> x.eog;
        s >> ',' >> x.max_targets_lo;
        s >> ',' >> x.max_targets_hi;
        s >> ',' >> x.rng_offset;
        s >> ','; read_array(s, 9, x.pdae_tab_time);
        s >> ','; read_array(s, 9, x.pdae_tab_date);
        s >> ',' >> x.pdae_tab_crc;
        s >> ','; read_array(s, 9, x.thres_tab_time);
        s >> ','; read_array(s, 9, x.thres_tab_date);
        s >> ',' >> x.thres_tab_crc;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! description of receiver

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct receiver_geometry
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef receiver_geometry<rebind_it> type;
    };

    typedef it iterator_type;

    receiver_geometry(it begin, it end, bool dirty=false)
        : field_of_view(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 147, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32};
    it begin() const { return field_of_view.begin(); }
    it end() const { return field_of_view.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float field_of_view;//!<  field of view in radian 
    #else
    binary::field<float, sc_float32, 0, it> field_of_view;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    receiver_geometry& operator=(const receiver_geometry<ito>& o) {
        field_of_view = o.field_of_view;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct receiver_geometry<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef receiver_geometry<rebind_it> type;
    };

    enum { id_main = 147, id_sub = 0};

    float            field_of_view;

    receiver_geometry()
        : field_of_view()
    {}

    template<class it>
    receiver_geometry(const receiver_geometry<it>& o) {
        field_of_view = o.field_of_view;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const receiver_geometry<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.field_of_view;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, receiver_geometry<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.field_of_view;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct reftab_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef reftab_table<rebind_it> type;
    };

    typedef it iterator_type;

    reftab_table(it begin, it end, bool dirty=false)
        : rangescale(begin)
        , reftab(begin, end, reftab_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 69, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 31792};
    it begin() const { return rangescale.begin(); }
    it end() const { return reftab.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t rangescale;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> rangescale;
    #endif //DOXYGEN

    std::size_t reftab_size;
    enum { reftab_max_size = 1986 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : val(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int16_t val;
        #else
        binary::field<int16_t, sc_int16, 0, it> val;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition reftab[1986];
    #else
    sequence<reftab_table, 16, 16, it> reftab;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    reftab_table& operator=(const reftab_table<ito>& o) {
        rangescale = o.rangescale;
        reftab_size = o.reftab_size;
        reftab.clean();
        for(unsigned n=0; n<reftab_size; ++n){
            reftab[n].val = o.reftab[n].val;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct reftab_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef reftab_table<rebind_it> type;
    };

    enum { id_main = 69, id_sub = 0};

    uint16_t         rangescale;
    std::size_t reftab_size;
    enum { reftab_max_size = 1986 };
    struct sequence_definition {
        int16_t          val;
    } reftab[1986];

    reftab_table()
        : rangescale()
    {}

    template<class it>
    reftab_table(const reftab_table<it>& o) {
        rangescale = o.rangescale;
        reftab_size = o.reftab.size();
        for(unsigned n=0; n<reftab_size; ++n){
            reftab[n].val = o.reftab[n].val;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const reftab_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.rangescale;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.reftab_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.reftab[n].val
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, reftab_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.rangescale;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.reftab_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.reftab_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.reftab[x.reftab_size-1].val)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct rel_refl_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef rel_refl_table<rebind_it> type;
    };

    typedef it iterator_type;

    rel_refl_table(it begin, it end, bool dirty=false)
        : entries(begin, end, entries_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 33, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1024};
    it begin() const { return entries.begin(); }
    it end() const { return entries.end(); }

    #endif //DOXYGEN

    std::size_t entries_size;
    enum { entries_max_size = 16 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : rng(begin, begin_bit)
            , add(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float rng;
        #else
        binary::field<float, sc_float32, 0, it> rng;
        #endif
        #ifdef DOXYGEN
        float add;
        #else
        binary::field<float, sc_float32, 32, it> add;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition entries[16];
    #else
    sequence<rel_refl_table, 64, 0, it> entries;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    rel_refl_table& operator=(const rel_refl_table<ito>& o) {
        entries_size = o.entries_size;
        entries.clean();
        for(unsigned n=0; n<entries_size; ++n){
            entries[n].rng = o.entries[n].rng;
            entries[n].add = o.entries[n].add;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct rel_refl_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef rel_refl_table<rebind_it> type;
    };

    enum { id_main = 33, id_sub = 0};

    std::size_t entries_size;
    enum { entries_max_size = 16 };
    struct sequence_definition {
        float            rng;
        float            add;
    } entries[16];

    rel_refl_table()
    {}

    template<class it>
    rel_refl_table(const rel_refl_table<it>& o) {
        entries_size = o.entries.size();
        for(unsigned n=0; n<entries_size; ++n){
            entries[n].rng = o.entries[n].rng;
            entries[n].add = o.entries[n].add;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const rel_refl_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.entries_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.entries[n].rng
            << ", " << x.entries[n].add
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, rel_refl_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.entries_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.entries_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.entries[x.entries_size-1].rng)
            >> ',' >> (x.entries[x.entries_size-1].add)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct rxp_parameters
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef rxp_parameters<rebind_it> type;
    };

    typedef it iterator_type;

    rxp_parameters(it begin, it end, bool dirty=false)
        : size(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 119, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 33554464};
    it begin() const { return size.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t size;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> size;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 4194304 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        char value;
        #else
        binary::field<char, sc_char, 0, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[4194304];
    #else
    sequence<rxp_parameters, 8, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    rxp_parameters& operator=(const rxp_parameters<ito>& o) {
        size = o.size;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct rxp_parameters<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef rxp_parameters<rebind_it> type;
    };

    enum { id_main = 119, id_sub = 0};

    uint32_t         size;
    std::size_t data_size;
    enum { data_max_size = 4194304 };
    struct sequence_definition {
        char             value;
    } data[4194304];

    rxp_parameters()
        : size()
    {}

    template<class it>
    rxp_parameters(const rxp_parameters<it>& o) {
        size = o.size;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const rxp_parameters<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.size;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, rxp_parameters<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.size;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel(it begin, it end, bool dirty=false)
        : idx(begin)
        , name(begin)
        , adc_resolution(begin)
        , adc_samplerate(begin)
        , delta_st(begin)
        , wavelength(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 87, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 396};
    it begin() const { return idx.begin(); }
    it end() const { return wavelength.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t idx;
    #else
    binary::field<uint8_t, sc_uint4, 0, it> idx;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char name[32];
    #else
    binary::array<char, 32, sc_char, 4, it> name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t adc_resolution;
    #else
    binary::field<uint8_t, sc_uint8, 260, it> adc_resolution;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double adc_samplerate;
    #else
    binary::field<double, sc_float64, 268, it> adc_samplerate;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float delta_st;
    #else
    binary::field<float, sc_float32, 332, it> delta_st;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float wavelength;
    #else
    binary::field<float, sc_float32, 364, it> wavelength;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel& operator=(const sbl_dg_channel<ito>& o) {
        idx = o.idx;
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        adc_resolution = o.adc_resolution;
        adc_samplerate = o.adc_samplerate;
        delta_st = o.delta_st;
        wavelength = o.wavelength;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel<rebind_it> type;
    };

    enum { id_main = 87, id_sub = 0};

    uint8_t          idx;
    char             name[32];
    uint8_t          adc_resolution;
    double           adc_samplerate;
    float            delta_st;
    float            wavelength;

    sbl_dg_channel()
        : idx()
        , name()
        , adc_resolution()
        , adc_samplerate()
        , delta_st()
        , wavelength()
    {}

    template<class it>
    sbl_dg_channel(const sbl_dg_channel<it>& o) {
        idx = o.idx;
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        adc_resolution = o.adc_resolution;
        adc_samplerate = o.adc_samplerate;
        delta_st = o.delta_st;
        wavelength = o.wavelength;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.idx;
        s << ", "; write_array(s, 32, x.name);
        s << ", " << x.adc_resolution;
        s << ", " << x.adc_samplerate;
        s << ", " << x.delta_st;
        s << ", " << x.wavelength;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.idx;
        s >> ','; read_array(s, 32, x.name);
        s >> ',' >> x.adc_resolution;
        s >> ',' >> x.adc_samplerate;
        s >> ',' >> x.delta_st;
        s >> ',' >> x.wavelength;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_1<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_1(it begin, it end, bool dirty=false)
        : idx(begin)
        , name(begin)
        , adc_resolution(begin)
        , adc_samplerate(begin)
        , delta_st(begin)
        , wavelength(begin)
        , compression(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 87, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 404};
    it begin() const { return idx.begin(); }
    it end() const { return compression.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t idx;
    #else
    binary::field<uint8_t, sc_uint4, 0, it> idx;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char name[32];
    #else
    binary::array<char, 32, sc_char, 4, it> name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t adc_resolution;
    #else
    binary::field<uint8_t, sc_uint8, 260, it> adc_resolution;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double adc_samplerate;
    #else
    binary::field<double, sc_float64, 268, it> adc_samplerate;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float delta_st;
    #else
    binary::field<float, sc_float32, 332, it> delta_st;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float wavelength;
    #else
    binary::field<float, sc_float32, 364, it> wavelength;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t compression;
    #else
    binary::field<uint8_t, sc_uint8, 396, it> compression;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_1& operator=(const sbl_dg_channel_1<ito>& o) {
        idx = o.idx;
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        adc_resolution = o.adc_resolution;
        adc_samplerate = o.adc_samplerate;
        delta_st = o.delta_st;
        wavelength = o.wavelength;
        compression = o.compression;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_1<rebind_it> type;
    };

    enum { id_main = 87, id_sub = 1};

    uint8_t          idx;
    char             name[32];
    uint8_t          adc_resolution;
    double           adc_samplerate;
    float            delta_st;
    float            wavelength;
    uint8_t          compression;

    sbl_dg_channel_1()
        : idx()
        , name()
        , adc_resolution()
        , adc_samplerate()
        , delta_st()
        , wavelength()
        , compression()
    {}

    template<class it>
    sbl_dg_channel_1(const sbl_dg_channel_1<it>& o) {
        idx = o.idx;
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        adc_resolution = o.adc_resolution;
        adc_samplerate = o.adc_samplerate;
        delta_st = o.delta_st;
        wavelength = o.wavelength;
        compression = o.compression;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.idx;
        s << ", "; write_array(s, 32, x.name);
        s << ", " << x.adc_resolution;
        s << ", " << x.adc_samplerate;
        s << ", " << x.delta_st;
        s << ", " << x.wavelength;
        s << ", " << x.compression;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.idx;
        s >> ','; read_array(s, 32, x.name);
        s >> ',' >> x.adc_resolution;
        s >> ',' >> x.adc_samplerate;
        s >> ',' >> x.delta_st;
        s >> ',' >> x.wavelength;
        s >> ',' >> x.compression;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_2<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_2(it begin, it end, bool dirty=false)
        : idx(begin)
        , name(begin)
        , adc_resolution(begin)
        , adc_samplerate(begin)
        , delta_st(begin)
        , wavelength(begin)
        , compression(begin)
        , temperature(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 87, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 436};
    it begin() const { return idx.begin(); }
    it end() const { return temperature.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t idx;
    #else
    binary::field<uint8_t, sc_uint4, 0, it> idx;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char name[32];
    #else
    binary::array<char, 32, sc_char, 4, it> name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t adc_resolution;
    #else
    binary::field<uint8_t, sc_uint8, 260, it> adc_resolution;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double adc_samplerate;
    #else
    binary::field<double, sc_float64, 268, it> adc_samplerate;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float delta_st;
    #else
    binary::field<float, sc_float32, 332, it> delta_st;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float wavelength;
    #else
    binary::field<float, sc_float32, 364, it> wavelength;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t compression;
    #else
    binary::field<uint8_t, sc_uint8, 396, it> compression;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float temperature;
    #else
    binary::field<float, sc_float32, 404, it> temperature;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_2& operator=(const sbl_dg_channel_2<ito>& o) {
        idx = o.idx;
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        adc_resolution = o.adc_resolution;
        adc_samplerate = o.adc_samplerate;
        delta_st = o.delta_st;
        wavelength = o.wavelength;
        compression = o.compression;
        temperature = o.temperature;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_2<rebind_it> type;
    };

    enum { id_main = 87, id_sub = 2};

    uint8_t          idx;
    char             name[32];
    uint8_t          adc_resolution;
    double           adc_samplerate;
    float            delta_st;
    float            wavelength;
    uint8_t          compression;
    float            temperature;

    sbl_dg_channel_2()
        : idx()
        , name()
        , adc_resolution()
        , adc_samplerate()
        , delta_st()
        , wavelength()
        , compression()
        , temperature()
    {}

    template<class it>
    sbl_dg_channel_2(const sbl_dg_channel_2<it>& o) {
        idx = o.idx;
        for(unsigned n=0; n<32; ++n) name[n] = o.name[n];
        adc_resolution = o.adc_resolution;
        adc_samplerate = o.adc_samplerate;
        delta_st = o.delta_st;
        wavelength = o.wavelength;
        compression = o.compression;
        temperature = o.temperature;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.idx;
        s << ", "; write_array(s, 32, x.name);
        s << ", " << x.adc_resolution;
        s << ", " << x.adc_samplerate;
        s << ", " << x.delta_st;
        s << ", " << x.wavelength;
        s << ", " << x.compression;
        s << ", " << x.temperature;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.idx;
        s >> ','; read_array(s, 32, x.name);
        s >> ',' >> x.adc_resolution;
        s >> ',' >> x.adc_samplerate;
        s >> ',' >> x.delta_st;
        s >> ',' >> x.wavelength;
        s >> ',' >> x.compression;
        s >> ',' >> x.temperature;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_data
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_data<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_data(it begin, it end, bool dirty=false)
        : pos(begin)
        , idx(begin)
        , trail_bits(begin)
        , sample_width(begin)
        , bitstream(begin, end, bitstream_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 89, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 65568};
    it begin() const { return pos.begin(); }
    it end() const { return bitstream.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t pos;
    #else
    binary::field<int16_t, sc_int16, 0, it> pos;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t idx;
    #else
    binary::field<uint8_t, sc_uint4, 16, it> idx;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t trail_bits;
    #else
    binary::field<uint8_t, sc_uint5, 20, it> trail_bits;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t sample_width;
    #else
    binary::field<uint8_t, sc_uint7, 25, it> sample_width;
    #endif //DOXYGEN

    std::size_t bitstream_size;
    enum { bitstream_max_size = 2048 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : byte(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t byte;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> byte;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition bitstream[2048];
    #else
    sequence<sbl_dg_channel_data, 32, 32, it> bitstream;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_data& operator=(const sbl_dg_channel_data<ito>& o) {
        pos = o.pos;
        idx = o.idx;
        trail_bits = o.trail_bits;
        sample_width = o.sample_width;
        bitstream_size = o.bitstream_size;
        bitstream.clean();
        for(unsigned n=0; n<bitstream_size; ++n){
            bitstream[n].byte = o.bitstream[n].byte;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_data<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_data<rebind_it> type;
    };

    enum { id_main = 89, id_sub = 0};

    int16_t          pos;
    uint8_t          idx;
    uint8_t          trail_bits;
    uint8_t          sample_width;
    std::size_t bitstream_size;
    enum { bitstream_max_size = 2048 };
    struct sequence_definition {
        uint32_t         byte;
    } bitstream[2048];

    sbl_dg_channel_data()
        : pos()
        , idx()
        , trail_bits()
        , sample_width()
    {}

    template<class it>
    sbl_dg_channel_data(const sbl_dg_channel_data<it>& o) {
        pos = o.pos;
        idx = o.idx;
        trail_bits = o.trail_bits;
        sample_width = o.sample_width;
        bitstream_size = o.bitstream.size();
        for(unsigned n=0; n<bitstream_size; ++n){
            bitstream[n].byte = o.bitstream[n].byte;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_data<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.pos;
        s << ", " << x.idx;
        s << ", " << x.trail_bits;
        s << ", " << x.sample_width;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.bitstream_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.bitstream[n].byte
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_data<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.pos;
        s >> ',' >> x.idx;
        s >> ',' >> x.trail_bits;
        s >> ',' >> x.sample_width;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.bitstream_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.bitstream_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.bitstream[x.bitstream_size-1].byte)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_data_compressed
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_data_compressed<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_data_compressed(it begin, it end, bool dirty=false)
        : pos(begin)
        , idx(begin)
        , trail_bits(begin)
        , sample_width(begin)
        , bitstream(begin, end, bitstream_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 90, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 65568};
    it begin() const { return pos.begin(); }
    it end() const { return bitstream.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t pos;
    #else
    binary::field<int16_t, sc_int16, 0, it> pos;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t idx;
    #else
    binary::field<uint8_t, sc_uint4, 16, it> idx;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t trail_bits;
    #else
    binary::field<uint8_t, sc_uint5, 20, it> trail_bits;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t sample_width;
    #else
    binary::field<uint8_t, sc_uint7, 25, it> sample_width;
    #endif //DOXYGEN

    std::size_t bitstream_size;
    enum { bitstream_max_size = 2048 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : byte(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t byte;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> byte;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition bitstream[2048];
    #else
    sequence<sbl_dg_channel_data_compressed, 32, 32, it> bitstream;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_data_compressed& operator=(const sbl_dg_channel_data_compressed<ito>& o) {
        pos = o.pos;
        idx = o.idx;
        trail_bits = o.trail_bits;
        sample_width = o.sample_width;
        bitstream_size = o.bitstream_size;
        bitstream.clean();
        for(unsigned n=0; n<bitstream_size; ++n){
            bitstream[n].byte = o.bitstream[n].byte;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_data_compressed<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_data_compressed<rebind_it> type;
    };

    enum { id_main = 90, id_sub = 0};

    int16_t          pos;
    uint8_t          idx;
    uint8_t          trail_bits;
    uint8_t          sample_width;
    std::size_t bitstream_size;
    enum { bitstream_max_size = 2048 };
    struct sequence_definition {
        uint32_t         byte;
    } bitstream[2048];

    sbl_dg_channel_data_compressed()
        : pos()
        , idx()
        , trail_bits()
        , sample_width()
    {}

    template<class it>
    sbl_dg_channel_data_compressed(const sbl_dg_channel_data_compressed<it>& o) {
        pos = o.pos;
        idx = o.idx;
        trail_bits = o.trail_bits;
        sample_width = o.sample_width;
        bitstream_size = o.bitstream.size();
        for(unsigned n=0; n<bitstream_size; ++n){
            bitstream[n].byte = o.bitstream[n].byte;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_data_compressed<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.pos;
        s << ", " << x.idx;
        s << ", " << x.trail_bits;
        s << ", " << x.sample_width;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.bitstream_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.bitstream[n].byte
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_data_compressed<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.pos;
        s >> ',' >> x.idx;
        s >> ',' >> x.trail_bits;
        s >> ',' >> x.sample_width;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.bitstream_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.bitstream_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.bitstream[x.bitstream_size-1].byte)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_expsum
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_expsum<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_expsum(it begin, it end, bool dirty=false)
        : idx(begin)
        , delay(begin)
        , scale(begin)
        , parameter(begin, end, parameter_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 124, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 25732};
    it begin() const { return idx.begin(); }
    it end() const { return parameter.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t idx;
    #else
    binary::field<uint8_t, sc_uint4, 0, it> idx;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double delay;
    #else
    binary::field<double, sc_float64, 4, it> delay;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double scale;
    #else
    binary::field<double, sc_float64, 68, it> scale;
    #endif //DOXYGEN

    std::size_t parameter_size;
    enum { parameter_max_size = 100 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : A(begin, begin_bit)
            , B(begin, begin_bit)
            , gamma(begin, begin_bit)
            , omega(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        double A;
        #else
        binary::field<double, sc_float64, 0, it> A;
        #endif
        #ifdef DOXYGEN
        double B;
        #else
        binary::field<double, sc_float64, 64, it> B;
        #endif
        #ifdef DOXYGEN
        double gamma;
        #else
        binary::field<double, sc_float64, 128, it> gamma;
        #endif
        #ifdef DOXYGEN
        double omega;
        #else
        binary::field<double, sc_float64, 192, it> omega;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition parameter[100];
    #else
    sequence<sbl_dg_channel_expsum, 256, 132, it> parameter;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_expsum& operator=(const sbl_dg_channel_expsum<ito>& o) {
        idx = o.idx;
        delay = o.delay;
        scale = o.scale;
        parameter_size = o.parameter_size;
        parameter.clean();
        for(unsigned n=0; n<parameter_size; ++n){
            parameter[n].A = o.parameter[n].A;
            parameter[n].B = o.parameter[n].B;
            parameter[n].gamma = o.parameter[n].gamma;
            parameter[n].omega = o.parameter[n].omega;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_expsum<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_expsum<rebind_it> type;
    };

    enum { id_main = 124, id_sub = 0};

    uint8_t          idx;
    double           delay;
    double           scale;
    std::size_t parameter_size;
    enum { parameter_max_size = 100 };
    struct sequence_definition {
        double           A;
        double           B;
        double           gamma;
        double           omega;
    } parameter[100];

    sbl_dg_channel_expsum()
        : idx()
        , delay()
        , scale()
    {}

    template<class it>
    sbl_dg_channel_expsum(const sbl_dg_channel_expsum<it>& o) {
        idx = o.idx;
        delay = o.delay;
        scale = o.scale;
        parameter_size = o.parameter.size();
        for(unsigned n=0; n<parameter_size; ++n){
            parameter[n].A = o.parameter[n].A;
            parameter[n].B = o.parameter[n].B;
            parameter[n].gamma = o.parameter[n].gamma;
            parameter[n].omega = o.parameter[n].omega;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_expsum<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.idx;
        s << ", " << x.delay;
        s << ", " << x.scale;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.parameter_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.parameter[n].A
            << ", " << x.parameter[n].B
            << ", " << x.parameter[n].gamma
            << ", " << x.parameter[n].omega
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_expsum<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.idx;
        s >> ',' >> x.delay;
        s >> ',' >> x.scale;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.parameter_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.parameter_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.parameter[x.parameter_size-1].A)
            >> ',' >> (x.parameter[x.parameter_size-1].B)
            >> ',' >> (x.parameter[x.parameter_size-1].gamma)
            >> ',' >> (x.parameter[x.parameter_size-1].omega)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_expsum_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_expsum_1<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_expsum_1(it begin, it end, bool dirty=false)
        : idx(begin)
        , delay(begin)
        , scale(begin)
        , a_lin(begin)
        , parameter(begin, end, parameter_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 132, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 25796};
    it begin() const { return idx.begin(); }
    it end() const { return parameter.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t idx;
    #else
    binary::field<uint8_t, sc_uint4, 0, it> idx;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double delay;
    #else
    binary::field<double, sc_float64, 4, it> delay;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double scale;
    #else
    binary::field<double, sc_float64, 68, it> scale;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double a_lin;
    #else
    binary::field<double, sc_float64, 132, it> a_lin;
    #endif //DOXYGEN

    std::size_t parameter_size;
    enum { parameter_max_size = 100 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : A(begin, begin_bit)
            , B(begin, begin_bit)
            , gamma(begin, begin_bit)
            , omega(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        double A;
        #else
        binary::field<double, sc_float64, 0, it> A;
        #endif
        #ifdef DOXYGEN
        double B;
        #else
        binary::field<double, sc_float64, 64, it> B;
        #endif
        #ifdef DOXYGEN
        double gamma;
        #else
        binary::field<double, sc_float64, 128, it> gamma;
        #endif
        #ifdef DOXYGEN
        double omega;
        #else
        binary::field<double, sc_float64, 192, it> omega;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition parameter[100];
    #else
    sequence<sbl_dg_channel_expsum_1, 256, 196, it> parameter;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_expsum_1& operator=(const sbl_dg_channel_expsum_1<ito>& o) {
        idx = o.idx;
        delay = o.delay;
        scale = o.scale;
        a_lin = o.a_lin;
        parameter_size = o.parameter_size;
        parameter.clean();
        for(unsigned n=0; n<parameter_size; ++n){
            parameter[n].A = o.parameter[n].A;
            parameter[n].B = o.parameter[n].B;
            parameter[n].gamma = o.parameter[n].gamma;
            parameter[n].omega = o.parameter[n].omega;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_expsum_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_expsum_1<rebind_it> type;
    };

    enum { id_main = 132, id_sub = 0};

    uint8_t          idx;
    double           delay;
    double           scale;
    double           a_lin;
    std::size_t parameter_size;
    enum { parameter_max_size = 100 };
    struct sequence_definition {
        double           A;
        double           B;
        double           gamma;
        double           omega;
    } parameter[100];

    sbl_dg_channel_expsum_1()
        : idx()
        , delay()
        , scale()
        , a_lin()
    {}

    template<class it>
    sbl_dg_channel_expsum_1(const sbl_dg_channel_expsum_1<it>& o) {
        idx = o.idx;
        delay = o.delay;
        scale = o.scale;
        a_lin = o.a_lin;
        parameter_size = o.parameter.size();
        for(unsigned n=0; n<parameter_size; ++n){
            parameter[n].A = o.parameter[n].A;
            parameter[n].B = o.parameter[n].B;
            parameter[n].gamma = o.parameter[n].gamma;
            parameter[n].omega = o.parameter[n].omega;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_expsum_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.idx;
        s << ", " << x.delay;
        s << ", " << x.scale;
        s << ", " << x.a_lin;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.parameter_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.parameter[n].A
            << ", " << x.parameter[n].B
            << ", " << x.parameter[n].gamma
            << ", " << x.parameter[n].omega
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_expsum_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.idx;
        s >> ',' >> x.delay;
        s >> ',' >> x.scale;
        s >> ',' >> x.a_lin;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.parameter_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.parameter_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.parameter[x.parameter_size-1].A)
            >> ',' >> (x.parameter[x.parameter_size-1].B)
            >> ',' >> (x.parameter[x.parameter_size-1].gamma)
            >> ',' >> (x.parameter[x.parameter_size-1].omega)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_fp
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_fp<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_fp(it begin, it end, bool dirty=false)
        : idx(begin)
        , ampl_bits(begin)
        , osr(begin)
        , rows(begin)
        , cols(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 125, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8388672};
    it begin() const { return idx.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t idx;
    #else
    binary::field<uint8_t, sc_uint4, 0, it> idx;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl_bits;
    #else
    binary::field<uint16_t, sc_uint12, 4, it> ampl_bits;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t osr;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> osr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t rows;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> rows;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t cols;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> cols;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : val(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float val;
        #else
        binary::field<float, sc_float32, 0, it> val;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[262144];
    #else
    sequence<sbl_dg_channel_fp, 32, 64, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_fp& operator=(const sbl_dg_channel_fp<ito>& o) {
        idx = o.idx;
        ampl_bits = o.ampl_bits;
        osr = o.osr;
        rows = o.rows;
        cols = o.cols;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_fp<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_fp<rebind_it> type;
    };

    enum { id_main = 125, id_sub = 0};

    uint8_t          idx;
    uint16_t         ampl_bits;
    uint16_t         osr;
    uint16_t         rows;
    uint16_t         cols;
    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition {
        float            val;
    } data[262144];

    sbl_dg_channel_fp()
        : idx()
        , ampl_bits()
        , osr()
        , rows()
        , cols()
    {}

    template<class it>
    sbl_dg_channel_fp(const sbl_dg_channel_fp<it>& o) {
        idx = o.idx;
        ampl_bits = o.ampl_bits;
        osr = o.osr;
        rows = o.rows;
        cols = o.cols;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_fp<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.idx;
        s << ", " << x.ampl_bits;
        s << ", " << x.osr;
        s << ", " << x.rows;
        s << ", " << x.cols;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].val
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_fp<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.idx;
        s >> ',' >> x.ampl_bits;
        s >> ',' >> x.osr;
        s >> ',' >> x.rows;
        s >> ',' >> x.cols;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].val)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_header
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_header<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_header(it begin, it end, bool dirty=false)
        : systime(begin)
        , shp_ampl(begin)
        , ref_ampl(begin)
        , ltr_phase(begin)
        , statistic(begin, end, statistic_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 88, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 640};
    it begin() const { return systime.begin(); }
    it end() const { return statistic.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t shp_ampl;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> shp_ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ref_ampl;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> ref_ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t ltr_phase;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> ltr_phase;
    #endif //DOXYGEN

    std::size_t statistic_size;
    enum { statistic_max_size = 16 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : mean(begin, begin_bit)
            , stddev(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t mean;
        #else
        binary::field<uint32_t, sc_uint20, 0, it> mean;
        #endif
        #ifdef DOXYGEN
        uint16_t stddev;
        #else
        binary::field<uint16_t, sc_uint12, 20, it> stddev;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition statistic[16];
    #else
    sequence<sbl_dg_channel_header, 32, 128, it> statistic;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_header& operator=(const sbl_dg_channel_header<ito>& o) {
        systime = o.systime;
        shp_ampl = o.shp_ampl;
        ref_ampl = o.ref_ampl;
        ltr_phase = o.ltr_phase;
        statistic_size = o.statistic_size;
        statistic.clean();
        for(unsigned n=0; n<statistic_size; ++n){
            statistic[n].mean = o.statistic[n].mean;
            statistic[n].stddev = o.statistic[n].stddev;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_header<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_header<rebind_it> type;
    };

    enum { id_main = 88, id_sub = 0};

    uint64_t         systime;
    uint16_t         shp_ampl;
    uint16_t         ref_ampl;
    uint32_t         ltr_phase;
    std::size_t statistic_size;
    enum { statistic_max_size = 16 };
    struct sequence_definition {
        uint32_t         mean;
        uint16_t         stddev;
    } statistic[16];

    sbl_dg_channel_header()
        : systime()
        , shp_ampl()
        , ref_ampl()
        , ltr_phase()
    {}

    template<class it>
    sbl_dg_channel_header(const sbl_dg_channel_header<it>& o) {
        systime = o.systime;
        shp_ampl = o.shp_ampl;
        ref_ampl = o.ref_ampl;
        ltr_phase = o.ltr_phase;
        statistic_size = o.statistic.size();
        for(unsigned n=0; n<statistic_size; ++n){
            statistic[n].mean = o.statistic[n].mean;
            statistic[n].stddev = o.statistic[n].stddev;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_header<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.shp_ampl;
        s << ", " << x.ref_ampl;
        s << ", " << x.ltr_phase;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.statistic_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.statistic[n].mean
            << ", " << x.statistic[n].stddev
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_header<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.shp_ampl;
        s >> ',' >> x.ref_ampl;
        s >> ',' >> x.ltr_phase;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.statistic_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.statistic_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.statistic[x.statistic_size-1].mean)
            >> ',' >> (x.statistic[x.statistic_size-1].stddev)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_header_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_header_1<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_header_1(it begin, it end, bool dirty=false)
        : systime(begin)
        , shp_ampl(begin)
        , ref_ampl(begin)
        , ltr_phase(begin)
        , statistic(begin, end, statistic_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 110, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 640};
    it begin() const { return systime.begin(); }
    it end() const { return statistic.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t shp_ampl;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> shp_ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ref_ampl;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> ref_ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t ltr_phase;
    #else
    binary::field<uint32_t, sc_uint26, 96, it> ltr_phase;
    #endif //DOXYGEN

    std::size_t statistic_size;
    enum { statistic_max_size = 16 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : idx(begin, begin_bit)
            , mean(begin, begin_bit)
            , stddev(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint8_t idx;
        #else
        binary::field<uint8_t, sc_uint4, 0, it> idx;
        #endif
        #ifdef DOXYGEN
        uint32_t mean;
        #else
        binary::field<uint32_t, sc_uint18, 4, it> mean;
        #endif
        #ifdef DOXYGEN
        uint16_t stddev;
        #else
        binary::field<uint16_t, sc_uint10, 22, it> stddev;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition statistic[16];
    #else
    sequence<sbl_dg_channel_header_1, 32, 128, it> statistic;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_header_1& operator=(const sbl_dg_channel_header_1<ito>& o) {
        systime = o.systime;
        shp_ampl = o.shp_ampl;
        ref_ampl = o.ref_ampl;
        ltr_phase = o.ltr_phase;
        statistic_size = o.statistic_size;
        statistic.clean();
        for(unsigned n=0; n<statistic_size; ++n){
            statistic[n].idx = o.statistic[n].idx;
            statistic[n].mean = o.statistic[n].mean;
            statistic[n].stddev = o.statistic[n].stddev;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_header_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_header_1<rebind_it> type;
    };

    enum { id_main = 110, id_sub = 0};

    uint64_t         systime;
    uint16_t         shp_ampl;
    uint16_t         ref_ampl;
    uint32_t         ltr_phase;
    std::size_t statistic_size;
    enum { statistic_max_size = 16 };
    struct sequence_definition {
        uint8_t          idx;
        uint32_t         mean;
        uint16_t         stddev;
    } statistic[16];

    sbl_dg_channel_header_1()
        : systime()
        , shp_ampl()
        , ref_ampl()
        , ltr_phase()
    {}

    template<class it>
    sbl_dg_channel_header_1(const sbl_dg_channel_header_1<it>& o) {
        systime = o.systime;
        shp_ampl = o.shp_ampl;
        ref_ampl = o.ref_ampl;
        ltr_phase = o.ltr_phase;
        statistic_size = o.statistic.size();
        for(unsigned n=0; n<statistic_size; ++n){
            statistic[n].idx = o.statistic[n].idx;
            statistic[n].mean = o.statistic[n].mean;
            statistic[n].stddev = o.statistic[n].stddev;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_header_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.shp_ampl;
        s << ", " << x.ref_ampl;
        s << ", " << x.ltr_phase;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.statistic_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.statistic[n].idx
            << ", " << x.statistic[n].mean
            << ", " << x.statistic[n].stddev
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_header_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.shp_ampl;
        s >> ',' >> x.ref_ampl;
        s >> ',' >> x.ltr_phase;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.statistic_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.statistic_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.statistic[x.statistic_size-1].idx)
            >> ',' >> (x.statistic[x.statistic_size-1].mean)
            >> ',' >> (x.statistic[x.statistic_size-1].stddev)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_channel_logamp
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_logamp<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_channel_logamp(it begin, it end, bool dirty=false)
        : fbits(begin)
        , rows(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 126, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 4194336};
    it begin() const { return fbits.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t fbits;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> fbits;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t rows;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> rows;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : val(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        int16_t val;
        #else
        binary::field<int16_t, sc_int16, 0, it> val;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[262144];
    #else
    sequence<sbl_dg_channel_logamp, 16, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_channel_logamp& operator=(const sbl_dg_channel_logamp<ito>& o) {
        fbits = o.fbits;
        rows = o.rows;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_channel_logamp<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_channel_logamp<rebind_it> type;
    };

    enum { id_main = 126, id_sub = 0};

    uint16_t         fbits;
    uint16_t         rows;
    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition {
        int16_t          val;
    } data[262144];

    sbl_dg_channel_logamp()
        : fbits()
        , rows()
    {}

    template<class it>
    sbl_dg_channel_logamp(const sbl_dg_channel_logamp<it>& o) {
        fbits = o.fbits;
        rows = o.rows;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].val = o.data[n].val;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_channel_logamp<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.fbits;
        s << ", " << x.rows;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].val
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_channel_logamp<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.fbits;
        s >> ',' >> x.rows;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].val)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_data
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_data<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_data(it begin, it end, bool dirty=false)
        : smpl_cnt(begin)
        , channel_id(begin)
        , odd(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 19, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32800};
    it begin() const { return smpl_cnt.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t smpl_cnt;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> smpl_cnt;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t channel_id;
    #else
    binary::field<uint8_t, sc_uint2, 16, it> channel_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t odd;
    #else
    binary::field<uint8_t, sc_bit, 18, it> odd;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sample(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t sample;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> sample;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[2048];
    #else
    sequence<sbl_dg_data, 16, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_data& operator=(const sbl_dg_data<ito>& o) {
        smpl_cnt = o.smpl_cnt;
        channel_id = o.channel_id;
        odd = o.odd;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_data<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_data<rebind_it> type;
    };

    enum { id_main = 19, id_sub = 0};

    uint16_t         smpl_cnt;
    uint8_t          channel_id;
    uint8_t          odd;
    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition {
        uint16_t         sample;
    } data[2048];

    sbl_dg_data()
        : smpl_cnt()
        , channel_id()
        , odd()
    {}

    template<class it>
    sbl_dg_data(const sbl_dg_data<it>& o) {
        smpl_cnt = o.smpl_cnt;
        channel_id = o.channel_id;
        odd = o.odd;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_data<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.smpl_cnt;
        s << ", " << x.channel_id;
        s << ", " << x.odd;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sample
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_data<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.smpl_cnt;
        s >> ',' >> x.channel_id;
        s >> ',' >> x.odd;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sample)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_data_compressed
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_data_compressed<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_data_compressed(it begin, it end, bool dirty=false)
        : smpl_cnt(begin)
        , channel_id(begin)
        , odd(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 55, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32800};
    it begin() const { return smpl_cnt.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t smpl_cnt;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> smpl_cnt;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t channel_id;
    #else
    binary::field<uint8_t, sc_uint2, 16, it> channel_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t odd;
    #else
    binary::field<uint8_t, sc_bit, 18, it> odd;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sample(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t sample;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> sample;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[2048];
    #else
    sequence<sbl_dg_data_compressed, 16, 32, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_data_compressed& operator=(const sbl_dg_data_compressed<ito>& o) {
        smpl_cnt = o.smpl_cnt;
        channel_id = o.channel_id;
        odd = o.odd;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_data_compressed<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_data_compressed<rebind_it> type;
    };

    enum { id_main = 55, id_sub = 0};

    uint16_t         smpl_cnt;
    uint8_t          channel_id;
    uint8_t          odd;
    std::size_t data_size;
    enum { data_max_size = 2048 };
    struct sequence_definition {
        uint16_t         sample;
    } data[2048];

    sbl_dg_data_compressed()
        : smpl_cnt()
        , channel_id()
        , odd()
    {}

    template<class it>
    sbl_dg_data_compressed(const sbl_dg_data_compressed<it>& o) {
        smpl_cnt = o.smpl_cnt;
        channel_id = o.channel_id;
        odd = o.odd;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_data_compressed<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.smpl_cnt;
        s << ", " << x.channel_id;
        s << ", " << x.odd;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sample
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_data_compressed<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.smpl_cnt;
        s >> ',' >> x.channel_id;
        s >> ',' >> x.odd;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sample)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_data_compressed_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_data_compressed_hr<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_data_compressed_hr(it begin, it end, bool dirty=false)
        : smpl_cnt(begin)
        , channel_id(begin)
        , trail_bits(begin)
        , sample_width(begin)
        , bitstream(begin, end, bitstream_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 78, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 524320};
    it begin() const { return smpl_cnt.begin(); }
    it end() const { return bitstream.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t smpl_cnt;
    #else
    binary::field<int16_t, sc_int16, 0, it> smpl_cnt;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t channel_id;
    #else
    binary::field<uint8_t, sc_uint2, 16, it> channel_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t trail_bits;
    #else
    binary::field<uint8_t, sc_uint5, 18, it> trail_bits;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sample_width;
    #else
    binary::field<uint16_t, sc_uint9, 23, it> sample_width;
    #endif //DOXYGEN

    std::size_t bitstream_size;
    enum { bitstream_max_size = 16384 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : byte(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t byte;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> byte;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition bitstream[16384];
    #else
    sequence<sbl_dg_data_compressed_hr, 32, 32, it> bitstream;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_data_compressed_hr& operator=(const sbl_dg_data_compressed_hr<ito>& o) {
        smpl_cnt = o.smpl_cnt;
        channel_id = o.channel_id;
        trail_bits = o.trail_bits;
        sample_width = o.sample_width;
        bitstream_size = o.bitstream_size;
        bitstream.clean();
        for(unsigned n=0; n<bitstream_size; ++n){
            bitstream[n].byte = o.bitstream[n].byte;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_data_compressed_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_data_compressed_hr<rebind_it> type;
    };

    enum { id_main = 78, id_sub = 0};

    int16_t          smpl_cnt;
    uint8_t          channel_id;
    uint8_t          trail_bits;
    uint16_t         sample_width;
    std::size_t bitstream_size;
    enum { bitstream_max_size = 16384 };
    struct sequence_definition {
        uint32_t         byte;
    } bitstream[16384];

    sbl_dg_data_compressed_hr()
        : smpl_cnt()
        , channel_id()
        , trail_bits()
        , sample_width()
    {}

    template<class it>
    sbl_dg_data_compressed_hr(const sbl_dg_data_compressed_hr<it>& o) {
        smpl_cnt = o.smpl_cnt;
        channel_id = o.channel_id;
        trail_bits = o.trail_bits;
        sample_width = o.sample_width;
        bitstream_size = o.bitstream.size();
        for(unsigned n=0; n<bitstream_size; ++n){
            bitstream[n].byte = o.bitstream[n].byte;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_data_compressed_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.smpl_cnt;
        s << ", " << x.channel_id;
        s << ", " << x.trail_bits;
        s << ", " << x.sample_width;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.bitstream_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.bitstream[n].byte
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_data_compressed_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.smpl_cnt;
        s >> ',' >> x.channel_id;
        s >> ',' >> x.trail_bits;
        s >> ',' >> x.sample_width;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.bitstream_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.bitstream_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.bitstream[x.bitstream_size-1].byte)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_data_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_data_hr<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_data_hr(it begin, it end, bool dirty=false)
        : smpl_cnt(begin)
        , channel_id(begin)
        , trail_bits(begin)
        , sample_width(begin)
        , bitstream(begin, end, bitstream_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 77, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 524320};
    it begin() const { return smpl_cnt.begin(); }
    it end() const { return bitstream.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t smpl_cnt;
    #else
    binary::field<int16_t, sc_int16, 0, it> smpl_cnt;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t channel_id;
    #else
    binary::field<uint8_t, sc_uint2, 16, it> channel_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t trail_bits;
    #else
    binary::field<uint8_t, sc_uint5, 18, it> trail_bits;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sample_width;
    #else
    binary::field<uint16_t, sc_uint9, 23, it> sample_width;
    #endif //DOXYGEN

    std::size_t bitstream_size;
    enum { bitstream_max_size = 16384 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : byte(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t byte;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> byte;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition bitstream[16384];
    #else
    sequence<sbl_dg_data_hr, 32, 32, it> bitstream;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_data_hr& operator=(const sbl_dg_data_hr<ito>& o) {
        smpl_cnt = o.smpl_cnt;
        channel_id = o.channel_id;
        trail_bits = o.trail_bits;
        sample_width = o.sample_width;
        bitstream_size = o.bitstream_size;
        bitstream.clean();
        for(unsigned n=0; n<bitstream_size; ++n){
            bitstream[n].byte = o.bitstream[n].byte;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_data_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_data_hr<rebind_it> type;
    };

    enum { id_main = 77, id_sub = 0};

    int16_t          smpl_cnt;
    uint8_t          channel_id;
    uint8_t          trail_bits;
    uint16_t         sample_width;
    std::size_t bitstream_size;
    enum { bitstream_max_size = 16384 };
    struct sequence_definition {
        uint32_t         byte;
    } bitstream[16384];

    sbl_dg_data_hr()
        : smpl_cnt()
        , channel_id()
        , trail_bits()
        , sample_width()
    {}

    template<class it>
    sbl_dg_data_hr(const sbl_dg_data_hr<it>& o) {
        smpl_cnt = o.smpl_cnt;
        channel_id = o.channel_id;
        trail_bits = o.trail_bits;
        sample_width = o.sample_width;
        bitstream_size = o.bitstream.size();
        for(unsigned n=0; n<bitstream_size; ++n){
            bitstream[n].byte = o.bitstream[n].byte;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_data_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.smpl_cnt;
        s << ", " << x.channel_id;
        s << ", " << x.trail_bits;
        s << ", " << x.sample_width;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.bitstream_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.bitstream[n].byte
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_data_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.smpl_cnt;
        s >> ',' >> x.channel_id;
        s >> ',' >> x.trail_bits;
        s >> ',' >> x.sample_width;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.bitstream_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.bitstream_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.bitstream[x.bitstream_size-1].byte)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_filter
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_filter<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_filter(it begin, it end, bool dirty=false)
        : sbl_name(begin)
        , enabled(begin)
        , smart_enabled(begin)
        , smart_filter_mask(begin)
        , pass_rng_less(begin)
        , pass_rng_greater(begin)
        , pass_ampl_less(begin)
        , pass_ampl_greater(begin)
        , pass_dev_less(begin)
        , pass_dev_greater(begin)
        , logic_expression(begin)
        , channel_idx_mask(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 138, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 2386};
    it begin() const { return sbl_name.begin(); }
    it end() const { return channel_idx_mask.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char sbl_name[16];
    #else
    binary::array<char, 16, sc_char, 0, it> sbl_name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t enabled;
    #else
    binary::field<uint8_t, sc_bit, 128, it> enabled;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t smart_enabled;
    #else
    binary::field<uint8_t, sc_bit, 129, it> smart_enabled;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t smart_filter_mask;
    #else
    binary::field<uint32_t, sc_uint32, 130, it> smart_filter_mask;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pass_rng_less;
    #else
    binary::field<float, sc_float32, 162, it> pass_rng_less;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pass_rng_greater;
    #else
    binary::field<float, sc_float32, 194, it> pass_rng_greater;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pass_ampl_less;
    #else
    binary::field<float, sc_float32, 226, it> pass_ampl_less;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pass_ampl_greater;
    #else
    binary::field<float, sc_float32, 258, it> pass_ampl_greater;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pass_dev_less;
    #else
    binary::field<uint16_t, sc_uint16, 290, it> pass_dev_less;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t pass_dev_greater;
    #else
    binary::field<uint16_t, sc_uint16, 306, it> pass_dev_greater;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char logic_expression[256];
    #else
    binary::array<char, 256, sc_char, 322, it> logic_expression;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t channel_idx_mask;
    #else
    binary::field<uint16_t, sc_uint16, 2370, it> channel_idx_mask;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_filter& operator=(const sbl_dg_filter<ito>& o) {
        for(unsigned n=0; n<16; ++n) sbl_name[n] = o.sbl_name[n];
        enabled = o.enabled;
        smart_enabled = o.smart_enabled;
        smart_filter_mask = o.smart_filter_mask;
        pass_rng_less = o.pass_rng_less;
        pass_rng_greater = o.pass_rng_greater;
        pass_ampl_less = o.pass_ampl_less;
        pass_ampl_greater = o.pass_ampl_greater;
        pass_dev_less = o.pass_dev_less;
        pass_dev_greater = o.pass_dev_greater;
        for(unsigned n=0; n<256; ++n) logic_expression[n] = o.logic_expression[n];
        channel_idx_mask = o.channel_idx_mask;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_filter<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_filter<rebind_it> type;
    };

    enum { id_main = 138, id_sub = 0};

    char             sbl_name[16];
    uint8_t          enabled;
    uint8_t          smart_enabled;
    uint32_t         smart_filter_mask;
    float            pass_rng_less;
    float            pass_rng_greater;
    float            pass_ampl_less;
    float            pass_ampl_greater;
    uint16_t         pass_dev_less;
    uint16_t         pass_dev_greater;
    char             logic_expression[256];
    uint16_t         channel_idx_mask;

    sbl_dg_filter()
        : sbl_name()
        , enabled()
        , smart_enabled()
        , smart_filter_mask()
        , pass_rng_less()
        , pass_rng_greater()
        , pass_ampl_less()
        , pass_ampl_greater()
        , pass_dev_less()
        , pass_dev_greater()
        , logic_expression()
        , channel_idx_mask()
    {}

    template<class it>
    sbl_dg_filter(const sbl_dg_filter<it>& o) {
        for(unsigned n=0; n<16; ++n) sbl_name[n] = o.sbl_name[n];
        enabled = o.enabled;
        smart_enabled = o.smart_enabled;
        smart_filter_mask = o.smart_filter_mask;
        pass_rng_less = o.pass_rng_less;
        pass_rng_greater = o.pass_rng_greater;
        pass_ampl_less = o.pass_ampl_less;
        pass_ampl_greater = o.pass_ampl_greater;
        pass_dev_less = o.pass_dev_less;
        pass_dev_greater = o.pass_dev_greater;
        for(unsigned n=0; n<256; ++n) logic_expression[n] = o.logic_expression[n];
        channel_idx_mask = o.channel_idx_mask;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_filter<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 16, x.sbl_name);
        s << ", " << x.enabled;
        s << ", " << x.smart_enabled;
        s << ", " << x.smart_filter_mask;
        s << ", " << x.pass_rng_less;
        s << ", " << x.pass_rng_greater;
        s << ", " << x.pass_ampl_less;
        s << ", " << x.pass_ampl_greater;
        s << ", " << x.pass_dev_less;
        s << ", " << x.pass_dev_greater;
        s << ", "; write_array(s, 256, x.logic_expression);
        s << ", " << x.channel_idx_mask;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_filter<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 16, x.sbl_name);
        s >> ',' >> x.enabled;
        s >> ',' >> x.smart_enabled;
        s >> ',' >> x.smart_filter_mask;
        s >> ',' >> x.pass_rng_less;
        s >> ',' >> x.pass_rng_greater;
        s >> ',' >> x.pass_ampl_less;
        s >> ',' >> x.pass_ampl_greater;
        s >> ',' >> x.pass_dev_less;
        s >> ',' >> x.pass_dev_greater;
        s >> ','; read_array(s, 256, x.logic_expression);
        s >> ',' >> x.channel_idx_mask;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_header
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_header<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_header(it begin, it end, bool dirty=false)
        : systime(begin)
        , mean_lp_chn(begin)
        , mean_hp_chn(begin)
        , stddev_lp_chn(begin)
        , stddev_hp_chn(begin)
        , shp_ampl(begin)
        , refpulse_smpl_frac(begin)
        , refpulse_smpl_cnt(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 18, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return systime.begin(); }
    it end() const { return refpulse_smpl_cnt.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t mean_lp_chn;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> mean_lp_chn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t mean_hp_chn;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> mean_hp_chn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t stddev_lp_chn;
    #else
    binary::field<uint8_t, sc_uint8, 64, it> stddev_lp_chn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t stddev_hp_chn;
    #else
    binary::field<uint8_t, sc_uint8, 72, it> stddev_hp_chn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t shp_ampl;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> shp_ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t refpulse_smpl_frac;
    #else
    binary::field<uint32_t, sc_uint18, 96, it> refpulse_smpl_frac;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t refpulse_smpl_cnt;
    #else
    binary::field<uint16_t, sc_uint14, 114, it> refpulse_smpl_cnt;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_header& operator=(const sbl_dg_header<ito>& o) {
        systime = o.systime;
        mean_lp_chn = o.mean_lp_chn;
        mean_hp_chn = o.mean_hp_chn;
        stddev_lp_chn = o.stddev_lp_chn;
        stddev_hp_chn = o.stddev_hp_chn;
        shp_ampl = o.shp_ampl;
        refpulse_smpl_frac = o.refpulse_smpl_frac;
        refpulse_smpl_cnt = o.refpulse_smpl_cnt;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_header<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_header<rebind_it> type;
    };

    enum { id_main = 18, id_sub = 0};

    uint32_t         systime;
    uint16_t         mean_lp_chn;
    uint16_t         mean_hp_chn;
    uint8_t          stddev_lp_chn;
    uint8_t          stddev_hp_chn;
    uint16_t         shp_ampl;
    uint32_t         refpulse_smpl_frac;
    uint16_t         refpulse_smpl_cnt;

    sbl_dg_header()
        : systime()
        , mean_lp_chn()
        , mean_hp_chn()
        , stddev_lp_chn()
        , stddev_hp_chn()
        , shp_ampl()
        , refpulse_smpl_frac()
        , refpulse_smpl_cnt()
    {}

    template<class it>
    sbl_dg_header(const sbl_dg_header<it>& o) {
        systime = o.systime;
        mean_lp_chn = o.mean_lp_chn;
        mean_hp_chn = o.mean_hp_chn;
        stddev_lp_chn = o.stddev_lp_chn;
        stddev_hp_chn = o.stddev_hp_chn;
        shp_ampl = o.shp_ampl;
        refpulse_smpl_frac = o.refpulse_smpl_frac;
        refpulse_smpl_cnt = o.refpulse_smpl_cnt;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_header<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.mean_lp_chn;
        s << ", " << x.mean_hp_chn;
        s << ", " << x.stddev_lp_chn;
        s << ", " << x.stddev_hp_chn;
        s << ", " << x.shp_ampl;
        s << ", " << x.refpulse_smpl_frac;
        s << ", " << x.refpulse_smpl_cnt;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_header<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.mean_lp_chn;
        s >> ',' >> x.mean_hp_chn;
        s >> ',' >> x.stddev_lp_chn;
        s >> ',' >> x.stddev_hp_chn;
        s >> ',' >> x.shp_ampl;
        s >> ',' >> x.refpulse_smpl_frac;
        s >> ',' >> x.refpulse_smpl_cnt;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_header_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_header_hr<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_header_hr(it begin, it end, bool dirty=false)
        : systime(begin)
        , mean_lp_chn(begin)
        , mean_hp_chn(begin)
        , stddev_lp_chn(begin)
        , stddev_hp_chn(begin)
        , shp_ampl(begin)
        , ref_ampl(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 80, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 192};
    it begin() const { return systime.begin(); }
    it end() const { return ref_ampl.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t mean_lp_chn;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> mean_lp_chn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t mean_hp_chn;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> mean_hp_chn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t stddev_lp_chn;
    #else
    binary::field<uint8_t, sc_uint8, 96, it> stddev_lp_chn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t stddev_hp_chn;
    #else
    binary::field<uint8_t, sc_uint8, 104, it> stddev_hp_chn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t shp_ampl;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> shp_ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ref_ampl;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> ref_ampl;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_header_hr& operator=(const sbl_dg_header_hr<ito>& o) {
        systime = o.systime;
        mean_lp_chn = o.mean_lp_chn;
        mean_hp_chn = o.mean_hp_chn;
        stddev_lp_chn = o.stddev_lp_chn;
        stddev_hp_chn = o.stddev_hp_chn;
        shp_ampl = o.shp_ampl;
        ref_ampl = o.ref_ampl;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_header_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_header_hr<rebind_it> type;
    };

    enum { id_main = 80, id_sub = 0};

    uint64_t         systime;
    uint16_t         mean_lp_chn;
    uint16_t         mean_hp_chn;
    uint8_t          stddev_lp_chn;
    uint8_t          stddev_hp_chn;
    uint16_t         shp_ampl;
    uint16_t         ref_ampl;

    sbl_dg_header_hr()
        : systime()
        , mean_lp_chn()
        , mean_hp_chn()
        , stddev_lp_chn()
        , stddev_hp_chn()
        , shp_ampl()
        , ref_ampl()
    {}

    template<class it>
    sbl_dg_header_hr(const sbl_dg_header_hr<it>& o) {
        systime = o.systime;
        mean_lp_chn = o.mean_lp_chn;
        mean_hp_chn = o.mean_hp_chn;
        stddev_lp_chn = o.stddev_lp_chn;
        stddev_hp_chn = o.stddev_hp_chn;
        shp_ampl = o.shp_ampl;
        ref_ampl = o.ref_ampl;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_header_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.mean_lp_chn;
        s << ", " << x.mean_hp_chn;
        s << ", " << x.stddev_lp_chn;
        s << ", " << x.stddev_hp_chn;
        s << ", " << x.shp_ampl;
        s << ", " << x.ref_ampl;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_header_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.mean_lp_chn;
        s >> ',' >> x.mean_hp_chn;
        s >> ',' >> x.stddev_lp_chn;
        s >> ',' >> x.stddev_hp_chn;
        s >> ',' >> x.shp_ampl;
        s >> ',' >> x.ref_ampl;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct sbl_dg_parameters
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_parameters<rebind_it> type;
    };

    typedef it iterator_type;

    sbl_dg_parameters(it begin, it end, bool dirty=false)
        : group_velocity(begin)
        , sampling_time(begin)
        , delta_st(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 62, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return group_velocity.begin(); }
    it end() const { return delta_st.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float group_velocity;//!<  group velocity in m/s 
    #else
    binary::field<float, sc_float32, 0, it> group_velocity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float sampling_time;//!<  sample interval in s 
    #else
    binary::field<float, sc_float32, 32, it> sampling_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float delta_st;//!<  internal offset in s 
    #else
    binary::field<float, sc_float32, 64, it> delta_st;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    sbl_dg_parameters& operator=(const sbl_dg_parameters<ito>& o) {
        group_velocity = o.group_velocity;
        sampling_time = o.sampling_time;
        delta_st = o.delta_st;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct sbl_dg_parameters<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef sbl_dg_parameters<rebind_it> type;
    };

    enum { id_main = 62, id_sub = 0};

    float            group_velocity;
    float            sampling_time;
    float            delta_st;

    sbl_dg_parameters()
        : group_velocity()
        , sampling_time()
        , delta_st()
    {}

    template<class it>
    sbl_dg_parameters(const sbl_dg_parameters<it>& o) {
        group_velocity = o.group_velocity;
        sampling_time = o.sampling_time;
        delta_st = o.delta_st;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const sbl_dg_parameters<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.group_velocity;
        s << ", " << x.sampling_time;
        s << ", " << x.delta_st;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, sbl_dg_parameters<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.group_velocity;
        s >> ',' >> x.sampling_time;
        s >> ',' >> x.delta_st;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! scan pattern description

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct scan_rect_fov
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef scan_rect_fov<rebind_it> type;
    };

    typedef it iterator_type;

    scan_rect_fov(it begin, it end, bool dirty=false)
        : theta_min(begin)
        , theta_max(begin)
        , theta_incr(begin)
        , phi_min(begin)
        , phi_max(begin)
        , phi_incr(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 5, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 192};
    it begin() const { return theta_min.begin(); }
    it end() const { return phi_incr.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float theta_min;//!<  minimum of scan angle along line scan axis [deg] 
    #else
    binary::field<float, sc_float32, 0, it> theta_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float theta_max;//!<  maximum of scan angle along line scan axis [deg] 
    #else
    binary::field<float, sc_float32, 32, it> theta_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float theta_incr;//!<  nominal scan angle increment along line scan axis [deg] 
    #else
    binary::field<float, sc_float32, 64, it> theta_incr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float phi_min;//!<  minimum of scan angle along frame scan axis [deg] 
    #else
    binary::field<float, sc_float32, 96, it> phi_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float phi_max;//!<  maximum of scan angle along frame scan axis [deg] 
    #else
    binary::field<float, sc_float32, 128, it> phi_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float phi_incr;//!<  nominal scan angle increment along frame scan axis [deg] 
    #else
    binary::field<float, sc_float32, 160, it> phi_incr;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    scan_rect_fov& operator=(const scan_rect_fov<ito>& o) {
        theta_min = o.theta_min;
        theta_max = o.theta_max;
        theta_incr = o.theta_incr;
        phi_min = o.phi_min;
        phi_max = o.phi_max;
        phi_incr = o.phi_incr;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct scan_rect_fov<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef scan_rect_fov<rebind_it> type;
    };

    enum { id_main = 5, id_sub = 0};

    float            theta_min;
    float            theta_max;
    float            theta_incr;
    float            phi_min;
    float            phi_max;
    float            phi_incr;

    scan_rect_fov()
        : theta_min()
        , theta_max()
        , theta_incr()
        , phi_min()
        , phi_max()
        , phi_incr()
    {}

    template<class it>
    scan_rect_fov(const scan_rect_fov<it>& o) {
        theta_min = o.theta_min;
        theta_max = o.theta_max;
        theta_incr = o.theta_incr;
        phi_min = o.phi_min;
        phi_max = o.phi_max;
        phi_incr = o.phi_incr;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const scan_rect_fov<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.theta_min;
        s << ", " << x.theta_max;
        s << ", " << x.theta_incr;
        s << ", " << x.phi_min;
        s << ", " << x.phi_max;
        s << ", " << x.phi_incr;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, scan_rect_fov<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.theta_min;
        s >> ',' >> x.theta_max;
        s >> ',' >> x.theta_incr;
        s >> ',' >> x.phi_min;
        s >> ',' >> x.phi_max;
        s >> ',' >> x.phi_incr;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! scan pattern description

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct scan_rect_fov_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef scan_rect_fov_1<rebind_it> type;
    };

    typedef it iterator_type;

    scan_rect_fov_1(it begin, it end, bool dirty=false)
        : theta_min(begin)
        , theta_max(begin)
        , theta_incr(begin)
        , phi_min(begin)
        , phi_max(begin)
        , phi_incr(begin)
        , line_scan_mode(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 5, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 224};
    it begin() const { return theta_min.begin(); }
    it end() const { return line_scan_mode.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float theta_min;//!<  minimum of scan angle along line scan axis [deg] 
    #else
    binary::field<float, sc_float32, 0, it> theta_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float theta_max;//!<  maximum of scan angle along line scan axis [deg] 
    #else
    binary::field<float, sc_float32, 32, it> theta_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float theta_incr;//!<  nominal scan angle increment along line scan axis [deg] 
    #else
    binary::field<float, sc_float32, 64, it> theta_incr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float phi_min;//!<  minimum of scan angle along frame scan axis [deg] 
    #else
    binary::field<float, sc_float32, 96, it> phi_min;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float phi_max;//!<  maximum of scan angle along frame scan axis [deg] 
    #else
    binary::field<float, sc_float32, 128, it> phi_max;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float phi_incr;//!<  nominal scan angle increment along frame scan axis [deg] 
    #else
    binary::field<float, sc_float32, 160, it> phi_incr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t line_scan_mode;//!<  0 .. line scan rotating, 1 .. line scan oscillating 
    #else
    binary::field<uint8_t, sc_bit, 192, it> line_scan_mode;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    scan_rect_fov_1& operator=(const scan_rect_fov_1<ito>& o) {
        theta_min = o.theta_min;
        theta_max = o.theta_max;
        theta_incr = o.theta_incr;
        phi_min = o.phi_min;
        phi_max = o.phi_max;
        phi_incr = o.phi_incr;
        line_scan_mode = o.line_scan_mode;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct scan_rect_fov_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef scan_rect_fov_1<rebind_it> type;
    };

    enum { id_main = 5, id_sub = 1};

    float            theta_min;
    float            theta_max;
    float            theta_incr;
    float            phi_min;
    float            phi_max;
    float            phi_incr;
    uint8_t          line_scan_mode;

    scan_rect_fov_1()
        : theta_min()
        , theta_max()
        , theta_incr()
        , phi_min()
        , phi_max()
        , phi_incr()
        , line_scan_mode()
    {}

    template<class it>
    scan_rect_fov_1(const scan_rect_fov_1<it>& o) {
        theta_min = o.theta_min;
        theta_max = o.theta_max;
        theta_incr = o.theta_incr;
        phi_min = o.phi_min;
        phi_max = o.phi_max;
        phi_incr = o.phi_incr;
        line_scan_mode = o.line_scan_mode;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const scan_rect_fov_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.theta_min;
        s << ", " << x.theta_max;
        s << ", " << x.theta_incr;
        s << ", " << x.phi_min;
        s << ", " << x.phi_max;
        s << ", " << x.phi_incr;
        s << ", " << x.line_scan_mode;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, scan_rect_fov_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.theta_min;
        s >> ',' >> x.theta_max;
        s >> ',' >> x.theta_incr;
        s >> ',' >> x.phi_min;
        s >> ',' >> x.phi_max;
        s >> ',' >> x.phi_incr;
        s >> ',' >> x.line_scan_mode;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! scan pattern description

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct scan_segments_fov
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef scan_segments_fov<rebind_it> type;
    };

    typedef it iterator_type;

    scan_segments_fov(it begin, it end, bool dirty=false)
        : angles(begin, end, angles_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 105, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 288};
    it begin() const { return angles.begin(); }
    it end() const { return angles.end(); }

    #endif //DOXYGEN

    std::size_t angles_size;
    enum { angles_max_size = 3 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : min(begin, begin_bit)
            , max(begin, begin_bit)
            , incr(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        float min;//!<  starting scan angle for this segemnt in degrees 
        #else
        binary::field<float, sc_float32, 0, it> min;
        #endif
        #ifdef DOXYGEN
        float max;//!<  ending scan angle for this segment in degrees 
        #else
        binary::field<float, sc_float32, 32, it> max;
        #endif
        #ifdef DOXYGEN
        float incr;//!<  nominal scan increment for this segment in degrees 
        #else
        binary::field<float, sc_float32, 64, it> incr;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition angles[3];
    #else
    sequence<scan_segments_fov, 96, 0, it> angles;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    scan_segments_fov& operator=(const scan_segments_fov<ito>& o) {
        angles_size = o.angles_size;
        angles.clean();
        for(unsigned n=0; n<angles_size; ++n){
            angles[n].min = o.angles[n].min;
            angles[n].max = o.angles[n].max;
            angles[n].incr = o.angles[n].incr;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct scan_segments_fov<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef scan_segments_fov<rebind_it> type;
    };

    enum { id_main = 105, id_sub = 0};

    std::size_t angles_size;
    enum { angles_max_size = 3 };
    struct sequence_definition {
        float            min;
        float            max;
        float            incr;
    } angles[3];

    scan_segments_fov()
    {}

    template<class it>
    scan_segments_fov(const scan_segments_fov<it>& o) {
        angles_size = o.angles.size();
        for(unsigned n=0; n<angles_size; ++n){
            angles[n].min = o.angles[n].min;
            angles[n].max = o.angles[n].max;
            angles[n].incr = o.angles[n].incr;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const scan_segments_fov<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.angles_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.angles[n].min
            << ", " << x.angles[n].max
            << ", " << x.angles[n].incr
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, scan_segments_fov<it>& x) {
    package_istream_entry ok(s);
    if (ok) {

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.angles_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.angles_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.angles[x.angles_size-1].min)
            >> ',' >> (x.angles[x.angles_size-1].max)
            >> ',' >> (x.angles[x.angles_size-1].incr)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! scan pattern for mirror less scanners, e.g BDF

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct scan_trail_fov
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef scan_trail_fov<rebind_it> type;
    };

    typedef it iterator_type;

    scan_trail_fov(it begin, it end, bool dirty=false)
        : shot_count(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 121, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32};
    it begin() const { return shot_count.begin(); }
    it end() const { return shot_count.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t shot_count;//!<  default number of shots e.g. for averaging 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> shot_count;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    scan_trail_fov& operator=(const scan_trail_fov<ito>& o) {
        shot_count = o.shot_count;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct scan_trail_fov<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef scan_trail_fov<rebind_it> type;
    };

    enum { id_main = 121, id_sub = 0};

    uint32_t         shot_count;

    scan_trail_fov()
        : shot_count()
    {}

    template<class it>
    scan_trail_fov(const scan_trail_fov<it>& o) {
        shot_count = o.shot_count;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const scan_trail_fov<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.shot_count;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, scan_trail_fov<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.shot_count;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! scanner pose (position and orientation

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct scanner_pose
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose<rebind_it> type;
    };

    typedef it iterator_type;

    scanner_pose(it begin, it end, bool dirty=false)
        : LAT(begin)
        , LON(begin)
        , HEIGHT(begin)
        , HMSL(begin)
        , roll(begin)
        , pitch(begin)
        , yaw(begin)
        , hAcc(begin)
        , vAcc(begin)
        , rAcc(begin)
        , pAcc(begin)
        , yAcc(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 54, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 384};
    it begin() const { return LAT.begin(); }
    it end() const { return yAcc.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float LAT;//!<  Latitude [deg] 
    #else
    binary::field<float, sc_float32, 0, it> LAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float LON;//!<  Longitude [deg] 
    #else
    binary::field<float, sc_float32, 32, it> LON;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float HEIGHT;//!<  height above ellipsoid [m] 
    #else
    binary::field<float, sc_float32, 64, it> HEIGHT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float HMSL;//!<  height above mean sea level [m] 
    #else
    binary::field<float, sc_float32, 96, it> HMSL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float roll;//!<  roll angle about scanner x-axis [deg] 
    #else
    binary::field<float, sc_float32, 128, it> roll;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pitch;//!<  pitch angle about scanner y-axis [deg] 
    #else
    binary::field<float, sc_float32, 160, it> pitch;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yaw;//!<  yaw angle about scanner z-axis [deg] 
    #else
    binary::field<float, sc_float32, 192, it> yaw;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float hAcc;//!<  horizontal accuracy [m] 
    #else
    binary::field<float, sc_float32, 224, it> hAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float vAcc;//!<  vertical accuracy [m] 
    #else
    binary::field<float, sc_float32, 256, it> vAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rAcc;//!<  roll angle accuracy [deg] 
    #else
    binary::field<float, sc_float32, 288, it> rAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pAcc;//!<  pitch angle accuracy [deg] 
    #else
    binary::field<float, sc_float32, 320, it> pAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yAcc;//!<  yaw angle accuracy  [deg] 
    #else
    binary::field<float, sc_float32, 352, it> yAcc;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    scanner_pose& operator=(const scanner_pose<ito>& o) {
        LAT = o.LAT;
        LON = o.LON;
        HEIGHT = o.HEIGHT;
        HMSL = o.HMSL;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct scanner_pose<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose<rebind_it> type;
    };

    enum { id_main = 54, id_sub = 0};

    float            LAT;
    float            LON;
    float            HEIGHT;
    float            HMSL;
    float            roll;
    float            pitch;
    float            yaw;
    float            hAcc;
    float            vAcc;
    float            rAcc;
    float            pAcc;
    float            yAcc;

    scanner_pose()
        : LAT()
        , LON()
        , HEIGHT()
        , HMSL()
        , roll()
        , pitch()
        , yaw()
        , hAcc()
        , vAcc()
        , rAcc()
        , pAcc()
        , yAcc()
    {}

    template<class it>
    scanner_pose(const scanner_pose<it>& o) {
        LAT = o.LAT;
        LON = o.LON;
        HEIGHT = o.HEIGHT;
        HMSL = o.HMSL;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const scanner_pose<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.LAT;
        s << ", " << x.LON;
        s << ", " << x.HEIGHT;
        s << ", " << x.HMSL;
        s << ", " << x.roll;
        s << ", " << x.pitch;
        s << ", " << x.yaw;
        s << ", " << x.hAcc;
        s << ", " << x.vAcc;
        s << ", " << x.rAcc;
        s << ", " << x.pAcc;
        s << ", " << x.yAcc;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, scanner_pose<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.LAT;
        s >> ',' >> x.LON;
        s >> ',' >> x.HEIGHT;
        s >> ',' >> x.HMSL;
        s >> ',' >> x.roll;
        s >> ',' >> x.pitch;
        s >> ',' >> x.yaw;
        s >> ',' >> x.hAcc;
        s >> ',' >> x.vAcc;
        s >> ',' >> x.rAcc;
        s >> ',' >> x.pAcc;
        s >> ',' >> x.yAcc;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! scanner pose (position and orientation

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct scanner_pose_hr
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose_hr<rebind_it> type;
    };

    typedef it iterator_type;

    scanner_pose_hr(it begin, it end, bool dirty=false)
        : LAT(begin)
        , LON(begin)
        , HEIGHT(begin)
        , HMSL(begin)
        , roll(begin)
        , pitch(begin)
        , yaw(begin)
        , hAcc(begin)
        , vAcc(begin)
        , rAcc(begin)
        , pAcc(begin)
        , yAcc(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 72, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 512};
    it begin() const { return LAT.begin(); }
    it end() const { return yAcc.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    double LAT;//!<  Latitude [deg] 
    #else
    binary::field<double, sc_float64, 0, it> LAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double LON;//!<  Longitude [deg] 
    #else
    binary::field<double, sc_float64, 64, it> LON;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double HEIGHT;//!<  height above ellipsoid [m] 
    #else
    binary::field<double, sc_float64, 128, it> HEIGHT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double HMSL;//!<  height above mean sea level [m] 
    #else
    binary::field<double, sc_float64, 192, it> HMSL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float roll;//!<  roll angle about scanner x-axis [deg] 
    #else
    binary::field<float, sc_float32, 256, it> roll;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pitch;//!<  pitch angle about scanner y-axis [deg] 
    #else
    binary::field<float, sc_float32, 288, it> pitch;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yaw;//!<  yaw angle about scanner z-axis [deg] 
    #else
    binary::field<float, sc_float32, 320, it> yaw;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float hAcc;//!<  horizontal accuracy [m] 
    #else
    binary::field<float, sc_float32, 352, it> hAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float vAcc;//!<  vertical accuracy [m] 
    #else
    binary::field<float, sc_float32, 384, it> vAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rAcc;//!<  roll angle accuracy [deg] 
    #else
    binary::field<float, sc_float32, 416, it> rAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pAcc;//!<  pitch angle accuracy [deg] 
    #else
    binary::field<float, sc_float32, 448, it> pAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yAcc;//!<  yaw angle accuracy  [deg] 
    #else
    binary::field<float, sc_float32, 480, it> yAcc;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    scanner_pose_hr& operator=(const scanner_pose_hr<ito>& o) {
        LAT = o.LAT;
        LON = o.LON;
        HEIGHT = o.HEIGHT;
        HMSL = o.HMSL;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct scanner_pose_hr<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose_hr<rebind_it> type;
    };

    enum { id_main = 72, id_sub = 0};

    double           LAT;
    double           LON;
    double           HEIGHT;
    double           HMSL;
    float            roll;
    float            pitch;
    float            yaw;
    float            hAcc;
    float            vAcc;
    float            rAcc;
    float            pAcc;
    float            yAcc;

    scanner_pose_hr()
        : LAT()
        , LON()
        , HEIGHT()
        , HMSL()
        , roll()
        , pitch()
        , yaw()
        , hAcc()
        , vAcc()
        , rAcc()
        , pAcc()
        , yAcc()
    {}

    template<class it>
    scanner_pose_hr(const scanner_pose_hr<it>& o) {
        LAT = o.LAT;
        LON = o.LON;
        HEIGHT = o.HEIGHT;
        HMSL = o.HMSL;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const scanner_pose_hr<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.LAT;
        s << ", " << x.LON;
        s << ", " << x.HEIGHT;
        s << ", " << x.HMSL;
        s << ", " << x.roll;
        s << ", " << x.pitch;
        s << ", " << x.yaw;
        s << ", " << x.hAcc;
        s << ", " << x.vAcc;
        s << ", " << x.rAcc;
        s << ", " << x.pAcc;
        s << ", " << x.yAcc;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, scanner_pose_hr<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.LAT;
        s >> ',' >> x.LON;
        s >> ',' >> x.HEIGHT;
        s >> ',' >> x.HMSL;
        s >> ',' >> x.roll;
        s >> ',' >> x.pitch;
        s >> ',' >> x.yaw;
        s >> ',' >> x.hAcc;
        s >> ',' >> x.vAcc;
        s >> ',' >> x.rAcc;
        s >> ',' >> x.pAcc;
        s >> ',' >> x.yAcc;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! scanner pose (position and orientation

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct scanner_pose_hr_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose_hr_1<rebind_it> type;
    };

    typedef it iterator_type;

    scanner_pose_hr_1(it begin, it end, bool dirty=false)
        : LAT(begin)
        , LON(begin)
        , HEIGHT(begin)
        , HMSL(begin)
        , roll(begin)
        , pitch(begin)
        , yaw(begin)
        , hAcc(begin)
        , vAcc(begin)
        , rAcc(begin)
        , pAcc(begin)
        , yAcc(begin)
        , height_baro(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 72, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 544};
    it begin() const { return LAT.begin(); }
    it end() const { return height_baro.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    double LAT;//!<  Latitude in deg 
    #else
    binary::field<double, sc_float64, 0, it> LAT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double LON;//!<  Longitude in deg 
    #else
    binary::field<double, sc_float64, 64, it> LON;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double HEIGHT;//!<  height above ellipsoid in m 
    #else
    binary::field<double, sc_float64, 128, it> HEIGHT;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double HMSL;//!<  height above mean sea level in m 
    #else
    binary::field<double, sc_float64, 192, it> HMSL;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float roll;//!<  roll angle about scanner x-axis in deg 
    #else
    binary::field<float, sc_float32, 256, it> roll;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pitch;//!<  pitch angle about scanner y-axis in deg 
    #else
    binary::field<float, sc_float32, 288, it> pitch;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yaw;//!<  yaw angle about scanner z-axis in deg 
    #else
    binary::field<float, sc_float32, 320, it> yaw;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float hAcc;//!<  horizontal accuracy in m 
    #else
    binary::field<float, sc_float32, 352, it> hAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float vAcc;//!<  vertical accuracy in m 
    #else
    binary::field<float, sc_float32, 384, it> vAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rAcc;//!<  roll angle accuracy in deg 
    #else
    binary::field<float, sc_float32, 416, it> rAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pAcc;//!<  pitch angle accuracy in deg 
    #else
    binary::field<float, sc_float32, 448, it> pAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yAcc;//!<  yaw angle accuracy  in deg 
    #else
    binary::field<float, sc_float32, 480, it> yAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float height_baro;//!<  altitude determined based on the atmospheric pressure according to the standard atmosphere laws in m. 
    #else
    binary::field<float, sc_float32, 512, it> height_baro;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    scanner_pose_hr_1& operator=(const scanner_pose_hr_1<ito>& o) {
        LAT = o.LAT;
        LON = o.LON;
        HEIGHT = o.HEIGHT;
        HMSL = o.HMSL;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
        height_baro = o.height_baro;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct scanner_pose_hr_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose_hr_1<rebind_it> type;
    };

    enum { id_main = 72, id_sub = 1};

    double           LAT;
    double           LON;
    double           HEIGHT;
    double           HMSL;
    float            roll;
    float            pitch;
    float            yaw;
    float            hAcc;
    float            vAcc;
    float            rAcc;
    float            pAcc;
    float            yAcc;
    float            height_baro;

    scanner_pose_hr_1()
        : LAT()
        , LON()
        , HEIGHT()
        , HMSL()
        , roll()
        , pitch()
        , yaw()
        , hAcc()
        , vAcc()
        , rAcc()
        , pAcc()
        , yAcc()
        , height_baro()
    {}

    template<class it>
    scanner_pose_hr_1(const scanner_pose_hr_1<it>& o) {
        LAT = o.LAT;
        LON = o.LON;
        HEIGHT = o.HEIGHT;
        HMSL = o.HMSL;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
        height_baro = o.height_baro;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const scanner_pose_hr_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.LAT;
        s << ", " << x.LON;
        s << ", " << x.HEIGHT;
        s << ", " << x.HMSL;
        s << ", " << x.roll;
        s << ", " << x.pitch;
        s << ", " << x.yaw;
        s << ", " << x.hAcc;
        s << ", " << x.vAcc;
        s << ", " << x.rAcc;
        s << ", " << x.pAcc;
        s << ", " << x.yAcc;
        s << ", " << x.height_baro;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, scanner_pose_hr_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.LAT;
        s >> ',' >> x.LON;
        s >> ',' >> x.HEIGHT;
        s >> ',' >> x.HMSL;
        s >> ',' >> x.roll;
        s >> ',' >> x.pitch;
        s >> ',' >> x.yaw;
        s >> ',' >> x.hAcc;
        s >> ',' >> x.vAcc;
        s >> ',' >> x.rAcc;
        s >> ',' >> x.pAcc;
        s >> ',' >> x.yAcc;
        s >> ',' >> x.height_baro;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! scanner pose in user coordinate system (ucs);

//! the user coordinate system is a leveled coordinate system
//! rotated about the height axis by a certain well-known amount alpha;
//! positive angles alpha rotate the ucs counter-clockwise
//! altough in rotated ucs the wording "northing" and "easting " is not precise,
//! the terms are still used
//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct scanner_pose_ucs
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose_ucs<rebind_it> type;
    };

    typedef it iterator_type;

    scanner_pose_ucs(it begin, it end, bool dirty=false)
        : ucs_name(begin)
        , proj_name(begin)
        , scale_factor(begin)
        , northing(begin)
        , easting(begin)
        , height(begin)
        , roll(begin)
        , pitch(begin)
        , yaw(begin)
        , hAcc(begin)
        , vAcc(begin)
        , rAcc(begin)
        , pAcc(begin)
        , yAcc(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 71, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1504};
    it begin() const { return ucs_name.begin(); }
    it end() const { return yAcc.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char ucs_name[64];//!<  coordinate system name, zero terminated string 
    #else
    binary::array<char, 64, sc_char, 0, it> ucs_name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char proj_name[64];//!<  projection name, zero terminated string 
    #else
    binary::array<char, 64, sc_char, 512, it> proj_name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float scale_factor;//!<  scale factor (just for information) 
    #else
    binary::field<float, sc_float32, 1024, it> scale_factor;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double northing;//!<  "northing" in units of m 
    #else
    binary::field<double, sc_float64, 1056, it> northing;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double easting;//!<  "easting" in units of m 
    #else
    binary::field<double, sc_float64, 1120, it> easting;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double height;//!<  height in units of m 
    #else
    binary::field<double, sc_float64, 1184, it> height;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float roll;//!<  roll angle about scanner x-axis in units of deg 
    #else
    binary::field<float, sc_float32, 1248, it> roll;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pitch;//!<  pitch angle about scanner y-axis in units of deg 
    #else
    binary::field<float, sc_float32, 1280, it> pitch;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yaw;//!<  yaw angle about scanner z-axis in units of deg 
    #else
    binary::field<float, sc_float32, 1312, it> yaw;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float hAcc;//!<  horizontal accuracy in units of m 
    #else
    binary::field<float, sc_float32, 1344, it> hAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float vAcc;//!<  vertical accuracy in units of m 
    #else
    binary::field<float, sc_float32, 1376, it> vAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rAcc;//!<  roll angle accuracy in units of deg 
    #else
    binary::field<float, sc_float32, 1408, it> rAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pAcc;//!<  pitch angle accuracy in units of deg 
    #else
    binary::field<float, sc_float32, 1440, it> pAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yAcc;//!<  yaw angle accuracy  in units of deg 
    #else
    binary::field<float, sc_float32, 1472, it> yAcc;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    scanner_pose_ucs& operator=(const scanner_pose_ucs<ito>& o) {
        for(unsigned n=0; n<64; ++n) ucs_name[n] = o.ucs_name[n];
        for(unsigned n=0; n<64; ++n) proj_name[n] = o.proj_name[n];
        scale_factor = o.scale_factor;
        northing = o.northing;
        easting = o.easting;
        height = o.height;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct scanner_pose_ucs<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose_ucs<rebind_it> type;
    };

    enum { id_main = 71, id_sub = 0};

    char             ucs_name[64];
    char             proj_name[64];
    float            scale_factor;
    double           northing;
    double           easting;
    double           height;
    float            roll;
    float            pitch;
    float            yaw;
    float            hAcc;
    float            vAcc;
    float            rAcc;
    float            pAcc;
    float            yAcc;

    scanner_pose_ucs()
        : ucs_name()
        , proj_name()
        , scale_factor()
        , northing()
        , easting()
        , height()
        , roll()
        , pitch()
        , yaw()
        , hAcc()
        , vAcc()
        , rAcc()
        , pAcc()
        , yAcc()
    {}

    template<class it>
    scanner_pose_ucs(const scanner_pose_ucs<it>& o) {
        for(unsigned n=0; n<64; ++n) ucs_name[n] = o.ucs_name[n];
        for(unsigned n=0; n<64; ++n) proj_name[n] = o.proj_name[n];
        scale_factor = o.scale_factor;
        northing = o.northing;
        easting = o.easting;
        height = o.height;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const scanner_pose_ucs<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 64, x.ucs_name);
        s << ", "; write_array(s, 64, x.proj_name);
        s << ", " << x.scale_factor;
        s << ", " << x.northing;
        s << ", " << x.easting;
        s << ", " << x.height;
        s << ", " << x.roll;
        s << ", " << x.pitch;
        s << ", " << x.yaw;
        s << ", " << x.hAcc;
        s << ", " << x.vAcc;
        s << ", " << x.rAcc;
        s << ", " << x.pAcc;
        s << ", " << x.yAcc;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, scanner_pose_ucs<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 64, x.ucs_name);
        s >> ','; read_array(s, 64, x.proj_name);
        s >> ',' >> x.scale_factor;
        s >> ',' >> x.northing;
        s >> ',' >> x.easting;
        s >> ',' >> x.height;
        s >> ',' >> x.roll;
        s >> ',' >> x.pitch;
        s >> ',' >> x.yaw;
        s >> ',' >> x.hAcc;
        s >> ',' >> x.vAcc;
        s >> ',' >> x.rAcc;
        s >> ',' >> x.pAcc;
        s >> ',' >> x.yAcc;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! scanner pose in user coordinate system (ucs);

//! the user coordinate system is a leveled coordinate system
//! rotated about the height axis by a certain well-known amount alpha;
//! positive angles alpha rotate the ucs counter-clockwise
//! altough in rotated ucs the wording "northing" and "easting " is not precise,
//! the terms are still used
//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, scan</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct scanner_pose_ucs_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose_ucs_1<rebind_it> type;
    };

    typedef it iterator_type;

    scanner_pose_ucs_1(it begin, it end, bool dirty=false)
        : ucs_name(begin)
        , proj_name(begin)
        , scale_factor(begin)
        , northing(begin)
        , easting(begin)
        , height(begin)
        , roll(begin)
        , pitch(begin)
        , yaw(begin)
        , hAcc(begin)
        , vAcc(begin)
        , rAcc(begin)
        , pAcc(begin)
        , yAcc(begin)
        , height_baro(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 71, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 1536};
    it begin() const { return ucs_name.begin(); }
    it end() const { return height_baro.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    char ucs_name[64];//!<  coordinate system name, zero terminated string 
    #else
    binary::array<char, 64, sc_char, 0, it> ucs_name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char proj_name[64];//!<  projection name, zero terminated string 
    #else
    binary::array<char, 64, sc_char, 512, it> proj_name;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float scale_factor;//!<  scale factor (just for information) 
    #else
    binary::field<float, sc_float32, 1024, it> scale_factor;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double northing;//!<  "northing" in units of m 
    #else
    binary::field<double, sc_float64, 1056, it> northing;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double easting;//!<  "easting" in units of m 
    #else
    binary::field<double, sc_float64, 1120, it> easting;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    double height;//!<  height in units of m 
    #else
    binary::field<double, sc_float64, 1184, it> height;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float roll;//!<  roll angle about scanner x-axis in units of deg 
    #else
    binary::field<float, sc_float32, 1248, it> roll;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pitch;//!<  pitch angle about scanner y-axis in units of deg 
    #else
    binary::field<float, sc_float32, 1280, it> pitch;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yaw;//!<  yaw angle about scanner z-axis in units of deg 
    #else
    binary::field<float, sc_float32, 1312, it> yaw;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float hAcc;//!<  horizontal accuracy in units of m 
    #else
    binary::field<float, sc_float32, 1344, it> hAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float vAcc;//!<  vertical accuracy in units of m 
    #else
    binary::field<float, sc_float32, 1376, it> vAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float rAcc;//!<  roll angle accuracy in units of deg 
    #else
    binary::field<float, sc_float32, 1408, it> rAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float pAcc;//!<  pitch angle accuracy in units of deg 
    #else
    binary::field<float, sc_float32, 1440, it> pAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float yAcc;//!<  yaw angle accuracy  in units of deg 
    #else
    binary::field<float, sc_float32, 1472, it> yAcc;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float height_baro;//!<  altitude determined based on the atmospheric pressure according to the standard atmosphere laws in m. 
    #else
    binary::field<float, sc_float32, 1504, it> height_baro;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    scanner_pose_ucs_1& operator=(const scanner_pose_ucs_1<ito>& o) {
        for(unsigned n=0; n<64; ++n) ucs_name[n] = o.ucs_name[n];
        for(unsigned n=0; n<64; ++n) proj_name[n] = o.proj_name[n];
        scale_factor = o.scale_factor;
        northing = o.northing;
        easting = o.easting;
        height = o.height;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
        height_baro = o.height_baro;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct scanner_pose_ucs_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef scanner_pose_ucs_1<rebind_it> type;
    };

    enum { id_main = 71, id_sub = 1};

    char             ucs_name[64];
    char             proj_name[64];
    float            scale_factor;
    double           northing;
    double           easting;
    double           height;
    float            roll;
    float            pitch;
    float            yaw;
    float            hAcc;
    float            vAcc;
    float            rAcc;
    float            pAcc;
    float            yAcc;
    float            height_baro;

    scanner_pose_ucs_1()
        : ucs_name()
        , proj_name()
        , scale_factor()
        , northing()
        , easting()
        , height()
        , roll()
        , pitch()
        , yaw()
        , hAcc()
        , vAcc()
        , rAcc()
        , pAcc()
        , yAcc()
        , height_baro()
    {}

    template<class it>
    scanner_pose_ucs_1(const scanner_pose_ucs_1<it>& o) {
        for(unsigned n=0; n<64; ++n) ucs_name[n] = o.ucs_name[n];
        for(unsigned n=0; n<64; ++n) proj_name[n] = o.proj_name[n];
        scale_factor = o.scale_factor;
        northing = o.northing;
        easting = o.easting;
        height = o.height;
        roll = o.roll;
        pitch = o.pitch;
        yaw = o.yaw;
        hAcc = o.hAcc;
        vAcc = o.vAcc;
        rAcc = o.rAcc;
        pAcc = o.pAcc;
        yAcc = o.yAcc;
        height_baro = o.height_baro;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const scanner_pose_ucs_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 64, x.ucs_name);
        s << ", "; write_array(s, 64, x.proj_name);
        s << ", " << x.scale_factor;
        s << ", " << x.northing;
        s << ", " << x.easting;
        s << ", " << x.height;
        s << ", " << x.roll;
        s << ", " << x.pitch;
        s << ", " << x.yaw;
        s << ", " << x.hAcc;
        s << ", " << x.vAcc;
        s << ", " << x.rAcc;
        s << ", " << x.pAcc;
        s << ", " << x.yAcc;
        s << ", " << x.height_baro;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, scanner_pose_ucs_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 64, x.ucs_name);
        s >> ','; read_array(s, 64, x.proj_name);
        s >> ',' >> x.scale_factor;
        s >> ',' >> x.northing;
        s >> ',' >> x.easting;
        s >> ',' >> x.height;
        s >> ',' >> x.roll;
        s >> ',' >> x.pitch;
        s >> ',' >> x.yaw;
        s >> ',' >> x.hAcc;
        s >> ',' >> x.vAcc;
        s >> ',' >> x.rAcc;
        s >> ',' >> x.pAcc;
        s >> ',' >> x.yAcc;
        s >> ',' >> x.height_baro;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct slt_dg
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg<rebind_it> type;
    };

    typedef it iterator_type;

    slt_dg(it begin, it end, bool dirty=false)
        : cnt_ls(begin)
        , fg_rp(begin)
        , ch_id(begin)
        , cnt_smpl_hi(begin)
        , cnt_smpl_lo(begin)
        , s_0(begin)
        , s_1(begin)
        , s_2(begin)
        , s_3(begin)
        , ampl(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50000, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 112};
    it begin() const { return cnt_ls.begin(); }
    it end() const { return ampl.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_ls;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> cnt_ls;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t fg_rp;
    #else
    binary::field<uint8_t, sc_bit, 8, it> fg_rp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ch_id;
    #else
    binary::field<uint8_t, sc_bit, 9, it> ch_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_smpl_hi;
    #else
    binary::field<uint8_t, sc_uint2, 14, it> cnt_smpl_hi;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t cnt_smpl_lo;
    #else
    binary::field<uint16_t, sc_uint12, 16, it> cnt_smpl_lo;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_0;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> s_0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_1;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> s_1;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_2;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> s_2;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_3;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> s_3;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> ampl;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    slt_dg& operator=(const slt_dg<ito>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        s_0 = o.s_0;
        s_1 = o.s_1;
        s_2 = o.s_2;
        s_3 = o.s_3;
        ampl = o.ampl;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct slt_dg<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg<rebind_it> type;
    };

    enum { id_main = 50000, id_sub = 0};

    uint8_t          cnt_ls;
    uint8_t          fg_rp;
    uint8_t          ch_id;
    uint8_t          cnt_smpl_hi;
    uint16_t         cnt_smpl_lo;
    uint16_t         s_0;
    uint16_t         s_1;
    uint16_t         s_2;
    uint16_t         s_3;
    uint16_t         ampl;

    slt_dg()
        : cnt_ls()
        , fg_rp()
        , ch_id()
        , cnt_smpl_hi()
        , cnt_smpl_lo()
        , s_0()
        , s_1()
        , s_2()
        , s_3()
        , ampl()
    {}

    template<class it>
    slt_dg(const slt_dg<it>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        s_0 = o.s_0;
        s_1 = o.s_1;
        s_2 = o.s_2;
        s_3 = o.s_3;
        ampl = o.ampl;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const slt_dg<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.cnt_ls;
        s << ", " << x.fg_rp;
        s << ", " << x.ch_id;
        s << ", " << x.cnt_smpl_hi;
        s << ", " << x.cnt_smpl_lo;
        s << ", " << x.s_0;
        s << ", " << x.s_1;
        s << ", " << x.s_2;
        s << ", " << x.s_3;
        s << ", " << x.ampl;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, slt_dg<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.cnt_ls;
        s >> ',' >> x.fg_rp;
        s >> ',' >> x.ch_id;
        s >> ',' >> x.cnt_smpl_hi;
        s >> ',' >> x.cnt_smpl_lo;
        s >> ',' >> x.s_0;
        s >> ',' >> x.s_1;
        s >> ',' >> x.s_2;
        s >> ',' >> x.s_3;
        s >> ',' >> x.ampl;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct slt_dg_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg_1<rebind_it> type;
    };

    typedef it iterator_type;

    slt_dg_1(it begin, it end, bool dirty=false)
        : cnt_ls(begin)
        , fg_rp(begin)
        , ch_id(begin)
        , cnt_smpl_hi(begin)
        , cnt_smpl_lo(begin)
        , s_0_lp(begin)
        , s_1_lp(begin)
        , s_2_lp(begin)
        , s_3_lp(begin)
        , s_4_lp(begin)
        , s_0_hp(begin)
        , s_1_hp(begin)
        , s_2_hp(begin)
        , s_3_hp(begin)
        , s_4_hp(begin)
        , est_ampl_shp(begin)
        , options(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50007, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 224};
    it begin() const { return cnt_ls.begin(); }
    it end() const { return options.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_ls;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> cnt_ls;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t fg_rp;
    #else
    binary::field<uint8_t, sc_bit, 8, it> fg_rp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ch_id;
    #else
    binary::field<uint8_t, sc_bit, 9, it> ch_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_smpl_hi;
    #else
    binary::field<uint8_t, sc_uint2, 14, it> cnt_smpl_hi;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t cnt_smpl_lo;
    #else
    binary::field<uint16_t, sc_uint12, 16, it> cnt_smpl_lo;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_0_lp;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> s_0_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_1_lp;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> s_1_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_2_lp;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> s_2_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_3_lp;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> s_3_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_4_lp;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> s_4_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_0_hp;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> s_0_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_1_hp;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> s_1_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_2_hp;
    #else
    binary::field<uint16_t, sc_uint16, 144, it> s_2_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_3_hp;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> s_3_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_4_hp;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> s_4_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t est_ampl_shp;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> est_ampl_shp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t options;
    #else
    binary::field<uint16_t, sc_uint16, 208, it> options;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    slt_dg_1& operator=(const slt_dg_1<ito>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        s_0_lp = o.s_0_lp;
        s_1_lp = o.s_1_lp;
        s_2_lp = o.s_2_lp;
        s_3_lp = o.s_3_lp;
        s_4_lp = o.s_4_lp;
        s_0_hp = o.s_0_hp;
        s_1_hp = o.s_1_hp;
        s_2_hp = o.s_2_hp;
        s_3_hp = o.s_3_hp;
        s_4_hp = o.s_4_hp;
        est_ampl_shp = o.est_ampl_shp;
        options = o.options;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct slt_dg_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg_1<rebind_it> type;
    };

    enum { id_main = 50007, id_sub = 0};

    uint8_t          cnt_ls;
    uint8_t          fg_rp;
    uint8_t          ch_id;
    uint8_t          cnt_smpl_hi;
    uint16_t         cnt_smpl_lo;
    uint16_t         s_0_lp;
    uint16_t         s_1_lp;
    uint16_t         s_2_lp;
    uint16_t         s_3_lp;
    uint16_t         s_4_lp;
    uint16_t         s_0_hp;
    uint16_t         s_1_hp;
    uint16_t         s_2_hp;
    uint16_t         s_3_hp;
    uint16_t         s_4_hp;
    uint16_t         est_ampl_shp;
    uint16_t         options;

    slt_dg_1()
        : cnt_ls()
        , fg_rp()
        , ch_id()
        , cnt_smpl_hi()
        , cnt_smpl_lo()
        , s_0_lp()
        , s_1_lp()
        , s_2_lp()
        , s_3_lp()
        , s_4_lp()
        , s_0_hp()
        , s_1_hp()
        , s_2_hp()
        , s_3_hp()
        , s_4_hp()
        , est_ampl_shp()
        , options()
    {}

    template<class it>
    slt_dg_1(const slt_dg_1<it>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        s_0_lp = o.s_0_lp;
        s_1_lp = o.s_1_lp;
        s_2_lp = o.s_2_lp;
        s_3_lp = o.s_3_lp;
        s_4_lp = o.s_4_lp;
        s_0_hp = o.s_0_hp;
        s_1_hp = o.s_1_hp;
        s_2_hp = o.s_2_hp;
        s_3_hp = o.s_3_hp;
        s_4_hp = o.s_4_hp;
        est_ampl_shp = o.est_ampl_shp;
        options = o.options;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const slt_dg_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.cnt_ls;
        s << ", " << x.fg_rp;
        s << ", " << x.ch_id;
        s << ", " << x.cnt_smpl_hi;
        s << ", " << x.cnt_smpl_lo;
        s << ", " << x.s_0_lp;
        s << ", " << x.s_1_lp;
        s << ", " << x.s_2_lp;
        s << ", " << x.s_3_lp;
        s << ", " << x.s_4_lp;
        s << ", " << x.s_0_hp;
        s << ", " << x.s_1_hp;
        s << ", " << x.s_2_hp;
        s << ", " << x.s_3_hp;
        s << ", " << x.s_4_hp;
        s << ", " << x.est_ampl_shp;
        s << ", " << x.options;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, slt_dg_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.cnt_ls;
        s >> ',' >> x.fg_rp;
        s >> ',' >> x.ch_id;
        s >> ',' >> x.cnt_smpl_hi;
        s >> ',' >> x.cnt_smpl_lo;
        s >> ',' >> x.s_0_lp;
        s >> ',' >> x.s_1_lp;
        s >> ',' >> x.s_2_lp;
        s >> ',' >> x.s_3_lp;
        s >> ',' >> x.s_4_lp;
        s >> ',' >> x.s_0_hp;
        s >> ',' >> x.s_1_hp;
        s >> ',' >> x.s_2_hp;
        s >> ',' >> x.s_3_hp;
        s >> ',' >> x.s_4_hp;
        s >> ',' >> x.est_ampl_shp;
        s >> ',' >> x.options;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct slt_dg_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg_2<rebind_it> type;
    };

    typedef it iterator_type;

    slt_dg_2(it begin, it end, bool dirty=false)
        : cnt_ls(begin)
        , fg_rp(begin)
        , ch_id(begin)
        , cnt_smpl_hi(begin)
        , cnt_smpl_lo(begin)
        , s_0_lp(begin)
        , s_1_lp(begin)
        , s_2_lp(begin)
        , s_3_lp(begin)
        , s_4_lp(begin)
        , s_0_hp(begin)
        , s_1_hp(begin)
        , s_2_hp(begin)
        , s_3_hp(begin)
        , s_4_hp(begin)
        , est_ampl_shp(begin)
        , options(begin)
        , para_di(begin)
        , para_da(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50007, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 256};
    it begin() const { return cnt_ls.begin(); }
    it end() const { return para_da.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_ls;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> cnt_ls;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t fg_rp;
    #else
    binary::field<uint8_t, sc_bit, 8, it> fg_rp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ch_id;
    #else
    binary::field<uint8_t, sc_bit, 9, it> ch_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_smpl_hi;
    #else
    binary::field<uint8_t, sc_uint2, 14, it> cnt_smpl_hi;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t cnt_smpl_lo;
    #else
    binary::field<uint16_t, sc_uint12, 16, it> cnt_smpl_lo;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_0_lp;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> s_0_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_1_lp;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> s_1_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_2_lp;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> s_2_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_3_lp;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> s_3_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_4_lp;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> s_4_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_0_hp;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> s_0_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_1_hp;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> s_1_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_2_hp;
    #else
    binary::field<uint16_t, sc_uint16, 144, it> s_2_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_3_hp;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> s_3_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_4_hp;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> s_4_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t est_ampl_shp;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> est_ampl_shp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t options;
    #else
    binary::field<uint16_t, sc_uint16, 208, it> options;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t para_di;
    #else
    binary::field<uint16_t, sc_uint16, 224, it> para_di;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t para_da;
    #else
    binary::field<uint16_t, sc_uint16, 240, it> para_da;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    slt_dg_2& operator=(const slt_dg_2<ito>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        s_0_lp = o.s_0_lp;
        s_1_lp = o.s_1_lp;
        s_2_lp = o.s_2_lp;
        s_3_lp = o.s_3_lp;
        s_4_lp = o.s_4_lp;
        s_0_hp = o.s_0_hp;
        s_1_hp = o.s_1_hp;
        s_2_hp = o.s_2_hp;
        s_3_hp = o.s_3_hp;
        s_4_hp = o.s_4_hp;
        est_ampl_shp = o.est_ampl_shp;
        options = o.options;
        para_di = o.para_di;
        para_da = o.para_da;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct slt_dg_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg_2<rebind_it> type;
    };

    enum { id_main = 50007, id_sub = 1};

    uint8_t          cnt_ls;
    uint8_t          fg_rp;
    uint8_t          ch_id;
    uint8_t          cnt_smpl_hi;
    uint16_t         cnt_smpl_lo;
    uint16_t         s_0_lp;
    uint16_t         s_1_lp;
    uint16_t         s_2_lp;
    uint16_t         s_3_lp;
    uint16_t         s_4_lp;
    uint16_t         s_0_hp;
    uint16_t         s_1_hp;
    uint16_t         s_2_hp;
    uint16_t         s_3_hp;
    uint16_t         s_4_hp;
    uint16_t         est_ampl_shp;
    uint16_t         options;
    uint16_t         para_di;
    uint16_t         para_da;

    slt_dg_2()
        : cnt_ls()
        , fg_rp()
        , ch_id()
        , cnt_smpl_hi()
        , cnt_smpl_lo()
        , s_0_lp()
        , s_1_lp()
        , s_2_lp()
        , s_3_lp()
        , s_4_lp()
        , s_0_hp()
        , s_1_hp()
        , s_2_hp()
        , s_3_hp()
        , s_4_hp()
        , est_ampl_shp()
        , options()
        , para_di()
        , para_da()
    {}

    template<class it>
    slt_dg_2(const slt_dg_2<it>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        s_0_lp = o.s_0_lp;
        s_1_lp = o.s_1_lp;
        s_2_lp = o.s_2_lp;
        s_3_lp = o.s_3_lp;
        s_4_lp = o.s_4_lp;
        s_0_hp = o.s_0_hp;
        s_1_hp = o.s_1_hp;
        s_2_hp = o.s_2_hp;
        s_3_hp = o.s_3_hp;
        s_4_hp = o.s_4_hp;
        est_ampl_shp = o.est_ampl_shp;
        options = o.options;
        para_di = o.para_di;
        para_da = o.para_da;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const slt_dg_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.cnt_ls;
        s << ", " << x.fg_rp;
        s << ", " << x.ch_id;
        s << ", " << x.cnt_smpl_hi;
        s << ", " << x.cnt_smpl_lo;
        s << ", " << x.s_0_lp;
        s << ", " << x.s_1_lp;
        s << ", " << x.s_2_lp;
        s << ", " << x.s_3_lp;
        s << ", " << x.s_4_lp;
        s << ", " << x.s_0_hp;
        s << ", " << x.s_1_hp;
        s << ", " << x.s_2_hp;
        s << ", " << x.s_3_hp;
        s << ", " << x.s_4_hp;
        s << ", " << x.est_ampl_shp;
        s << ", " << x.options;
        s << ", " << x.para_di;
        s << ", " << x.para_da;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, slt_dg_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.cnt_ls;
        s >> ',' >> x.fg_rp;
        s >> ',' >> x.ch_id;
        s >> ',' >> x.cnt_smpl_hi;
        s >> ',' >> x.cnt_smpl_lo;
        s >> ',' >> x.s_0_lp;
        s >> ',' >> x.s_1_lp;
        s >> ',' >> x.s_2_lp;
        s >> ',' >> x.s_3_lp;
        s >> ',' >> x.s_4_lp;
        s >> ',' >> x.s_0_hp;
        s >> ',' >> x.s_1_hp;
        s >> ',' >> x.s_2_hp;
        s >> ',' >> x.s_3_hp;
        s >> ',' >> x.s_4_hp;
        s >> ',' >> x.est_ampl_shp;
        s >> ',' >> x.options;
        s >> ',' >> x.para_di;
        s >> ',' >> x.para_da;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct slt_dg_3
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg_3<rebind_it> type;
    };

    typedef it iterator_type;

    slt_dg_3(it begin, it end, bool dirty=false)
        : cnt_ls(begin)
        , fg_rp(begin)
        , ch_id(begin)
        , cnt_smpl_hi(begin)
        , cnt_smpl_lo(begin)
        , s_0_lp(begin)
        , s_1_lp(begin)
        , s_2_lp(begin)
        , s_3_lp(begin)
        , s_4_lp(begin)
        , s_0_hp(begin)
        , s_1_hp(begin)
        , s_2_hp(begin)
        , s_3_hp(begin)
        , s_4_hp(begin)
        , est_ampl_shp(begin)
        , options(begin)
        , para_di(begin)
        , para_da(begin)
        , offset_lp(begin)
        , offset_hp(begin)
        , sigma_lp(begin)
        , sigma_hp(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50007, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 320};
    it begin() const { return cnt_ls.begin(); }
    it end() const { return sigma_hp.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_ls;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> cnt_ls;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t fg_rp;
    #else
    binary::field<uint8_t, sc_bit, 8, it> fg_rp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ch_id;
    #else
    binary::field<uint8_t, sc_bit, 9, it> ch_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_smpl_hi;
    #else
    binary::field<uint8_t, sc_uint2, 14, it> cnt_smpl_hi;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t cnt_smpl_lo;
    #else
    binary::field<uint16_t, sc_uint12, 16, it> cnt_smpl_lo;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_0_lp;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> s_0_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_1_lp;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> s_1_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_2_lp;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> s_2_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_3_lp;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> s_3_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_4_lp;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> s_4_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_0_hp;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> s_0_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_1_hp;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> s_1_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_2_hp;
    #else
    binary::field<uint16_t, sc_uint16, 144, it> s_2_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_3_hp;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> s_3_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_4_hp;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> s_4_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t est_ampl_shp;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> est_ampl_shp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t options;
    #else
    binary::field<uint16_t, sc_uint16, 208, it> options;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t para_di;
    #else
    binary::field<uint16_t, sc_uint16, 224, it> para_di;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t para_da;
    #else
    binary::field<uint16_t, sc_uint16, 240, it> para_da;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t offset_lp;
    #else
    binary::field<uint16_t, sc_uint16, 256, it> offset_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t offset_hp;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> offset_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sigma_lp;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> sigma_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sigma_hp;
    #else
    binary::field<uint16_t, sc_uint16, 304, it> sigma_hp;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    slt_dg_3& operator=(const slt_dg_3<ito>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        s_0_lp = o.s_0_lp;
        s_1_lp = o.s_1_lp;
        s_2_lp = o.s_2_lp;
        s_3_lp = o.s_3_lp;
        s_4_lp = o.s_4_lp;
        s_0_hp = o.s_0_hp;
        s_1_hp = o.s_1_hp;
        s_2_hp = o.s_2_hp;
        s_3_hp = o.s_3_hp;
        s_4_hp = o.s_4_hp;
        est_ampl_shp = o.est_ampl_shp;
        options = o.options;
        para_di = o.para_di;
        para_da = o.para_da;
        offset_lp = o.offset_lp;
        offset_hp = o.offset_hp;
        sigma_lp = o.sigma_lp;
        sigma_hp = o.sigma_hp;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct slt_dg_3<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg_3<rebind_it> type;
    };

    enum { id_main = 50007, id_sub = 2};

    uint8_t          cnt_ls;
    uint8_t          fg_rp;
    uint8_t          ch_id;
    uint8_t          cnt_smpl_hi;
    uint16_t         cnt_smpl_lo;
    uint16_t         s_0_lp;
    uint16_t         s_1_lp;
    uint16_t         s_2_lp;
    uint16_t         s_3_lp;
    uint16_t         s_4_lp;
    uint16_t         s_0_hp;
    uint16_t         s_1_hp;
    uint16_t         s_2_hp;
    uint16_t         s_3_hp;
    uint16_t         s_4_hp;
    uint16_t         est_ampl_shp;
    uint16_t         options;
    uint16_t         para_di;
    uint16_t         para_da;
    uint16_t         offset_lp;
    uint16_t         offset_hp;
    uint16_t         sigma_lp;
    uint16_t         sigma_hp;

    slt_dg_3()
        : cnt_ls()
        , fg_rp()
        , ch_id()
        , cnt_smpl_hi()
        , cnt_smpl_lo()
        , s_0_lp()
        , s_1_lp()
        , s_2_lp()
        , s_3_lp()
        , s_4_lp()
        , s_0_hp()
        , s_1_hp()
        , s_2_hp()
        , s_3_hp()
        , s_4_hp()
        , est_ampl_shp()
        , options()
        , para_di()
        , para_da()
        , offset_lp()
        , offset_hp()
        , sigma_lp()
        , sigma_hp()
    {}

    template<class it>
    slt_dg_3(const slt_dg_3<it>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        s_0_lp = o.s_0_lp;
        s_1_lp = o.s_1_lp;
        s_2_lp = o.s_2_lp;
        s_3_lp = o.s_3_lp;
        s_4_lp = o.s_4_lp;
        s_0_hp = o.s_0_hp;
        s_1_hp = o.s_1_hp;
        s_2_hp = o.s_2_hp;
        s_3_hp = o.s_3_hp;
        s_4_hp = o.s_4_hp;
        est_ampl_shp = o.est_ampl_shp;
        options = o.options;
        para_di = o.para_di;
        para_da = o.para_da;
        offset_lp = o.offset_lp;
        offset_hp = o.offset_hp;
        sigma_lp = o.sigma_lp;
        sigma_hp = o.sigma_hp;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const slt_dg_3<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.cnt_ls;
        s << ", " << x.fg_rp;
        s << ", " << x.ch_id;
        s << ", " << x.cnt_smpl_hi;
        s << ", " << x.cnt_smpl_lo;
        s << ", " << x.s_0_lp;
        s << ", " << x.s_1_lp;
        s << ", " << x.s_2_lp;
        s << ", " << x.s_3_lp;
        s << ", " << x.s_4_lp;
        s << ", " << x.s_0_hp;
        s << ", " << x.s_1_hp;
        s << ", " << x.s_2_hp;
        s << ", " << x.s_3_hp;
        s << ", " << x.s_4_hp;
        s << ", " << x.est_ampl_shp;
        s << ", " << x.options;
        s << ", " << x.para_di;
        s << ", " << x.para_da;
        s << ", " << x.offset_lp;
        s << ", " << x.offset_hp;
        s << ", " << x.sigma_lp;
        s << ", " << x.sigma_hp;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, slt_dg_3<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.cnt_ls;
        s >> ',' >> x.fg_rp;
        s >> ',' >> x.ch_id;
        s >> ',' >> x.cnt_smpl_hi;
        s >> ',' >> x.cnt_smpl_lo;
        s >> ',' >> x.s_0_lp;
        s >> ',' >> x.s_1_lp;
        s >> ',' >> x.s_2_lp;
        s >> ',' >> x.s_3_lp;
        s >> ',' >> x.s_4_lp;
        s >> ',' >> x.s_0_hp;
        s >> ',' >> x.s_1_hp;
        s >> ',' >> x.s_2_hp;
        s >> ',' >> x.s_3_hp;
        s >> ',' >> x.s_4_hp;
        s >> ',' >> x.est_ampl_shp;
        s >> ',' >> x.options;
        s >> ',' >> x.para_di;
        s >> ',' >> x.para_da;
        s >> ',' >> x.offset_lp;
        s >> ',' >> x.offset_hp;
        s >> ',' >> x.sigma_lp;
        s >> ',' >> x.sigma_hp;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct slt_dg_4
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg_4<rebind_it> type;
    };

    typedef it iterator_type;

    slt_dg_4(it begin, it end, bool dirty=false)
        : slt_flags(begin)
        , cnt_smpl(begin)
        , s_0_lp(begin)
        , s_1_lp(begin)
        , s_2_lp(begin)
        , s_3_lp(begin)
        , s_4_lp(begin)
        , s_0_hp(begin)
        , s_1_hp(begin)
        , s_2_hp(begin)
        , s_3_hp(begin)
        , s_4_hp(begin)
        , est_ampl_shp(begin)
        , del_r(begin)
        , del_parabola(begin)
        , ampl_r(begin)
        , ampl_parabola(begin)
        , ltrphase(begin)
        , ref_ampl(begin)
        , ref_pos_rnggt(begin)
        , offset_lp(begin)
        , offset_hp(begin)
        , sigma_lp(begin)
        , sigma_hp(begin)
        , reserved_0(begin)
        , reserved_1(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50008, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 416};
    it begin() const { return slt_flags.begin(); }
    it end() const { return reserved_1.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t slt_flags;
    #else
    binary::field<uint16_t, sc_uint16, 0, it> slt_flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t cnt_smpl;
    #else
    binary::field<uint16_t, sc_uint16, 16, it> cnt_smpl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_0_lp;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> s_0_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_1_lp;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> s_1_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_2_lp;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> s_2_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_3_lp;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> s_3_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_4_lp;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> s_4_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_0_hp;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> s_0_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_1_hp;
    #else
    binary::field<uint16_t, sc_uint16, 128, it> s_1_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_2_hp;
    #else
    binary::field<uint16_t, sc_uint16, 144, it> s_2_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_3_hp;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> s_3_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t s_4_hp;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> s_4_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t est_ampl_shp;
    #else
    binary::field<uint16_t, sc_uint16, 192, it> est_ampl_shp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t del_r;
    #else
    binary::field<uint16_t, sc_uint16, 208, it> del_r;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t del_parabola;
    #else
    binary::field<uint16_t, sc_uint16, 224, it> del_parabola;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t ampl_r;
    #else
    binary::field<int16_t, sc_int16, 240, it> ampl_r;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t ampl_parabola;
    #else
    binary::field<int16_t, sc_int16, 256, it> ampl_parabola;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ltrphase;
    #else
    binary::field<uint16_t, sc_uint16, 272, it> ltrphase;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ref_ampl;
    #else
    binary::field<uint16_t, sc_uint16, 288, it> ref_ampl;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ref_pos_rnggt;
    #else
    binary::field<uint16_t, sc_uint16, 304, it> ref_pos_rnggt;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t offset_lp;
    #else
    binary::field<uint16_t, sc_uint16, 320, it> offset_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t offset_hp;
    #else
    binary::field<uint16_t, sc_uint16, 336, it> offset_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sigma_lp;
    #else
    binary::field<uint16_t, sc_uint16, 352, it> sigma_lp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t sigma_hp;
    #else
    binary::field<uint16_t, sc_uint16, 368, it> sigma_hp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t reserved_0;
    #else
    binary::field<uint16_t, sc_uint16, 384, it> reserved_0;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t reserved_1;
    #else
    binary::field<uint16_t, sc_uint16, 400, it> reserved_1;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    slt_dg_4& operator=(const slt_dg_4<ito>& o) {
        slt_flags = o.slt_flags;
        cnt_smpl = o.cnt_smpl;
        s_0_lp = o.s_0_lp;
        s_1_lp = o.s_1_lp;
        s_2_lp = o.s_2_lp;
        s_3_lp = o.s_3_lp;
        s_4_lp = o.s_4_lp;
        s_0_hp = o.s_0_hp;
        s_1_hp = o.s_1_hp;
        s_2_hp = o.s_2_hp;
        s_3_hp = o.s_3_hp;
        s_4_hp = o.s_4_hp;
        est_ampl_shp = o.est_ampl_shp;
        del_r = o.del_r;
        del_parabola = o.del_parabola;
        ampl_r = o.ampl_r;
        ampl_parabola = o.ampl_parabola;
        ltrphase = o.ltrphase;
        ref_ampl = o.ref_ampl;
        ref_pos_rnggt = o.ref_pos_rnggt;
        offset_lp = o.offset_lp;
        offset_hp = o.offset_hp;
        sigma_lp = o.sigma_lp;
        sigma_hp = o.sigma_hp;
        reserved_0 = o.reserved_0;
        reserved_1 = o.reserved_1;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct slt_dg_4<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef slt_dg_4<rebind_it> type;
    };

    enum { id_main = 50008, id_sub = 0};

    uint16_t         slt_flags;
    uint16_t         cnt_smpl;
    uint16_t         s_0_lp;
    uint16_t         s_1_lp;
    uint16_t         s_2_lp;
    uint16_t         s_3_lp;
    uint16_t         s_4_lp;
    uint16_t         s_0_hp;
    uint16_t         s_1_hp;
    uint16_t         s_2_hp;
    uint16_t         s_3_hp;
    uint16_t         s_4_hp;
    uint16_t         est_ampl_shp;
    uint16_t         del_r;
    uint16_t         del_parabola;
    int16_t          ampl_r;
    int16_t          ampl_parabola;
    uint16_t         ltrphase;
    uint16_t         ref_ampl;
    uint16_t         ref_pos_rnggt;
    uint16_t         offset_lp;
    uint16_t         offset_hp;
    uint16_t         sigma_lp;
    uint16_t         sigma_hp;
    uint16_t         reserved_0;
    uint16_t         reserved_1;

    slt_dg_4()
        : slt_flags()
        , cnt_smpl()
        , s_0_lp()
        , s_1_lp()
        , s_2_lp()
        , s_3_lp()
        , s_4_lp()
        , s_0_hp()
        , s_1_hp()
        , s_2_hp()
        , s_3_hp()
        , s_4_hp()
        , est_ampl_shp()
        , del_r()
        , del_parabola()
        , ampl_r()
        , ampl_parabola()
        , ltrphase()
        , ref_ampl()
        , ref_pos_rnggt()
        , offset_lp()
        , offset_hp()
        , sigma_lp()
        , sigma_hp()
        , reserved_0()
        , reserved_1()
    {}

    template<class it>
    slt_dg_4(const slt_dg_4<it>& o) {
        slt_flags = o.slt_flags;
        cnt_smpl = o.cnt_smpl;
        s_0_lp = o.s_0_lp;
        s_1_lp = o.s_1_lp;
        s_2_lp = o.s_2_lp;
        s_3_lp = o.s_3_lp;
        s_4_lp = o.s_4_lp;
        s_0_hp = o.s_0_hp;
        s_1_hp = o.s_1_hp;
        s_2_hp = o.s_2_hp;
        s_3_hp = o.s_3_hp;
        s_4_hp = o.s_4_hp;
        est_ampl_shp = o.est_ampl_shp;
        del_r = o.del_r;
        del_parabola = o.del_parabola;
        ampl_r = o.ampl_r;
        ampl_parabola = o.ampl_parabola;
        ltrphase = o.ltrphase;
        ref_ampl = o.ref_ampl;
        ref_pos_rnggt = o.ref_pos_rnggt;
        offset_lp = o.offset_lp;
        offset_hp = o.offset_hp;
        sigma_lp = o.sigma_lp;
        sigma_hp = o.sigma_hp;
        reserved_0 = o.reserved_0;
        reserved_1 = o.reserved_1;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const slt_dg_4<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.slt_flags;
        s << ", " << x.cnt_smpl;
        s << ", " << x.s_0_lp;
        s << ", " << x.s_1_lp;
        s << ", " << x.s_2_lp;
        s << ", " << x.s_3_lp;
        s << ", " << x.s_4_lp;
        s << ", " << x.s_0_hp;
        s << ", " << x.s_1_hp;
        s << ", " << x.s_2_hp;
        s << ", " << x.s_3_hp;
        s << ", " << x.s_4_hp;
        s << ", " << x.est_ampl_shp;
        s << ", " << x.del_r;
        s << ", " << x.del_parabola;
        s << ", " << x.ampl_r;
        s << ", " << x.ampl_parabola;
        s << ", " << x.ltrphase;
        s << ", " << x.ref_ampl;
        s << ", " << x.ref_pos_rnggt;
        s << ", " << x.offset_lp;
        s << ", " << x.offset_hp;
        s << ", " << x.sigma_lp;
        s << ", " << x.sigma_hp;
        s << ", " << x.reserved_0;
        s << ", " << x.reserved_1;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, slt_dg_4<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.slt_flags;
        s >> ',' >> x.cnt_smpl;
        s >> ',' >> x.s_0_lp;
        s >> ',' >> x.s_1_lp;
        s >> ',' >> x.s_2_lp;
        s >> ',' >> x.s_3_lp;
        s >> ',' >> x.s_4_lp;
        s >> ',' >> x.s_0_hp;
        s >> ',' >> x.s_1_hp;
        s >> ',' >> x.s_2_hp;
        s >> ',' >> x.s_3_hp;
        s >> ',' >> x.s_4_hp;
        s >> ',' >> x.est_ampl_shp;
        s >> ',' >> x.del_r;
        s >> ',' >> x.del_parabola;
        s >> ',' >> x.ampl_r;
        s >> ',' >> x.ampl_parabola;
        s >> ',' >> x.ltrphase;
        s >> ',' >> x.ref_ampl;
        s >> ',' >> x.ref_pos_rnggt;
        s >> ',' >> x.offset_lp;
        s >> ',' >> x.offset_hp;
        s >> ',' >> x.sigma_lp;
        s >> ',' >> x.sigma_hp;
        s >> ',' >> x.reserved_0;
        s >> ',' >> x.reserved_1;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct tgt_dg
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef tgt_dg<rebind_it> type;
    };

    typedef it iterator_type;

    tgt_dg(it begin, it end, bool dirty=false)
        : cnt_ls(begin)
        , fg_rp(begin)
        , ch_id(begin)
        , cnt_smpl_hi(begin)
        , cnt_smpl_lo(begin)
        , del_r(begin)
        , del_parabola(begin)
        , ampl_r(begin)
        , ampl_parabola(begin)
        , flags(begin)
        , dev(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 50001, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return cnt_ls.begin(); }
    it end() const { return dev.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_ls;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> cnt_ls;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t fg_rp;
    #else
    binary::field<uint8_t, sc_bit, 8, it> fg_rp;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ch_id;
    #else
    binary::field<uint8_t, sc_bit, 9, it> ch_id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_smpl_hi;
    #else
    binary::field<uint8_t, sc_uint2, 14, it> cnt_smpl_hi;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t cnt_smpl_lo;
    #else
    binary::field<uint16_t, sc_uint12, 16, it> cnt_smpl_lo;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t del_r;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> del_r;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t del_parabola;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> del_parabola;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl_r;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> ampl_r;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ampl_parabola;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> ampl_parabola;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t flags;
    #else
    binary::field<uint16_t, sc_uint16, 96, it> flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t dev;
    #else
    binary::field<uint16_t, sc_uint16, 112, it> dev;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    tgt_dg& operator=(const tgt_dg<ito>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        del_r = o.del_r;
        del_parabola = o.del_parabola;
        ampl_r = o.ampl_r;
        ampl_parabola = o.ampl_parabola;
        flags = o.flags;
        dev = o.dev;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct tgt_dg<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef tgt_dg<rebind_it> type;
    };

    enum { id_main = 50001, id_sub = 0};

    uint8_t          cnt_ls;
    uint8_t          fg_rp;
    uint8_t          ch_id;
    uint8_t          cnt_smpl_hi;
    uint16_t         cnt_smpl_lo;
    uint16_t         del_r;
    uint16_t         del_parabola;
    uint16_t         ampl_r;
    uint16_t         ampl_parabola;
    uint16_t         flags;
    uint16_t         dev;

    tgt_dg()
        : cnt_ls()
        , fg_rp()
        , ch_id()
        , cnt_smpl_hi()
        , cnt_smpl_lo()
        , del_r()
        , del_parabola()
        , ampl_r()
        , ampl_parabola()
        , flags()
        , dev()
    {}

    template<class it>
    tgt_dg(const tgt_dg<it>& o) {
        cnt_ls = o.cnt_ls;
        fg_rp = o.fg_rp;
        ch_id = o.ch_id;
        cnt_smpl_hi = o.cnt_smpl_hi;
        cnt_smpl_lo = o.cnt_smpl_lo;
        del_r = o.del_r;
        del_parabola = o.del_parabola;
        ampl_r = o.ampl_r;
        ampl_parabola = o.ampl_parabola;
        flags = o.flags;
        dev = o.dev;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const tgt_dg<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.cnt_ls;
        s << ", " << x.fg_rp;
        s << ", " << x.ch_id;
        s << ", " << x.cnt_smpl_hi;
        s << ", " << x.cnt_smpl_lo;
        s << ", " << x.del_r;
        s << ", " << x.del_parabola;
        s << ", " << x.ampl_r;
        s << ", " << x.ampl_parabola;
        s << ", " << x.flags;
        s << ", " << x.dev;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, tgt_dg<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.cnt_ls;
        s >> ',' >> x.fg_rp;
        s >> ',' >> x.ch_id;
        s >> ',' >> x.cnt_smpl_hi;
        s >> ',' >> x.cnt_smpl_lo;
        s >> ',' >> x.del_r;
        s >> ',' >> x.del_parabola;
        s >> ',' >> x.ampl_r;
        s >> ',' >> x.ampl_parabola;
        s >> ',' >> x.flags;
        s >> ',' >> x.dev;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct timed_blob
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef timed_blob<rebind_it> type;
    };

    typedef it iterator_type;

    timed_blob(it begin, it end, bool dirty=false)
        : systime(begin)
        , id(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 139, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 8388704};
    it begin() const { return systime.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t systime;
    #else
    binary::field<uint64_t, sc_uint64, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t id;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> id;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : value(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t value;
        #else
        binary::field<uint32_t, sc_uint32, 0, it> value;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[262144];
    #else
    sequence<timed_blob, 32, 96, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    timed_blob& operator=(const timed_blob<ito>& o) {
        systime = o.systime;
        id = o.id;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct timed_blob<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef timed_blob<rebind_it> type;
    };

    enum { id_main = 139, id_sub = 0};

    uint64_t         systime;
    uint32_t         id;
    std::size_t data_size;
    enum { data_max_size = 262144 };
    struct sequence_definition {
        uint32_t         value;
    } data[262144];

    timed_blob()
        : systime()
        , id()
    {}

    template<class it>
    timed_blob(const timed_blob<it>& o) {
        systime = o.systime;
        id = o.id;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].value = o.data[n].value;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const timed_blob<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.id;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].value
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, timed_blob<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.id;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].value)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct trigger_debug_dyntrig_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef trigger_debug_dyntrig_table<rebind_it> type;
    };

    typedef it iterator_type;

    trigger_debug_dyntrig_table(it begin, it end, bool dirty=false)
        : ch_id_own(begin)
        , ch_id_result(begin)
        , trigtable(begin, end, trigtable_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 95, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 32776};
    it begin() const { return ch_id_own.begin(); }
    it end() const { return trigtable.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ch_id_own;
    #else
    binary::field<uint8_t, sc_uint4, 0, it> ch_id_own;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ch_id_result;
    #else
    binary::field<uint8_t, sc_uint4, 4, it> ch_id_result;
    #endif //DOXYGEN

    std::size_t trigtable_size;
    enum { trigtable_max_size = 512 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : ampl(begin, begin_bit)
            , thres(begin, begin_bit)
            , delay(begin, begin_bit)
            , decay(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t ampl;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> ampl;
        #endif
        #ifdef DOXYGEN
        uint16_t thres;
        #else
        binary::field<uint16_t, sc_uint16, 16, it> thres;
        #endif
        #ifdef DOXYGEN
        uint16_t delay;
        #else
        binary::field<uint16_t, sc_uint16, 32, it> delay;
        #endif
        #ifdef DOXYGEN
        uint16_t decay;
        #else
        binary::field<uint16_t, sc_uint16, 48, it> decay;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition trigtable[512];
    #else
    sequence<trigger_debug_dyntrig_table, 64, 8, it> trigtable;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    trigger_debug_dyntrig_table& operator=(const trigger_debug_dyntrig_table<ito>& o) {
        ch_id_own = o.ch_id_own;
        ch_id_result = o.ch_id_result;
        trigtable_size = o.trigtable_size;
        trigtable.clean();
        for(unsigned n=0; n<trigtable_size; ++n){
            trigtable[n].ampl = o.trigtable[n].ampl;
            trigtable[n].thres = o.trigtable[n].thres;
            trigtable[n].delay = o.trigtable[n].delay;
            trigtable[n].decay = o.trigtable[n].decay;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct trigger_debug_dyntrig_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef trigger_debug_dyntrig_table<rebind_it> type;
    };

    enum { id_main = 95, id_sub = 0};

    uint8_t          ch_id_own;
    uint8_t          ch_id_result;
    std::size_t trigtable_size;
    enum { trigtable_max_size = 512 };
    struct sequence_definition {
        uint16_t         ampl;
        uint16_t         thres;
        uint16_t         delay;
        uint16_t         decay;
    } trigtable[512];

    trigger_debug_dyntrig_table()
        : ch_id_own()
        , ch_id_result()
    {}

    template<class it>
    trigger_debug_dyntrig_table(const trigger_debug_dyntrig_table<it>& o) {
        ch_id_own = o.ch_id_own;
        ch_id_result = o.ch_id_result;
        trigtable_size = o.trigtable.size();
        for(unsigned n=0; n<trigtable_size; ++n){
            trigtable[n].ampl = o.trigtable[n].ampl;
            trigtable[n].thres = o.trigtable[n].thres;
            trigtable[n].delay = o.trigtable[n].delay;
            trigtable[n].decay = o.trigtable[n].decay;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const trigger_debug_dyntrig_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.ch_id_own;
        s << ", " << x.ch_id_result;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.trigtable_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.trigtable[n].ampl
            << ", " << x.trigtable[n].thres
            << ", " << x.trigtable[n].delay
            << ", " << x.trigtable[n].decay
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, trigger_debug_dyntrig_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.ch_id_own;
        s >> ',' >> x.ch_id_result;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.trigtable_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.trigtable_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.trigtable[x.trigtable_size-1].ampl)
            >> ',' >> (x.trigtable[x.trigtable_size-1].thres)
            >> ',' >> (x.trigtable[x.trigtable_size-1].delay)
            >> ',' >> (x.trigtable[x.trigtable_size-1].decay)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct trigger_debug_stattrig_table
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef trigger_debug_stattrig_table<rebind_it> type;
    };

    typedef it iterator_type;

    trigger_debug_stattrig_table(it begin, it end, bool dirty=false)
        : ch_id(begin)
        , trigtable(begin, end, trigtable_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 96, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 73732};
    it begin() const { return ch_id.begin(); }
    it end() const { return trigtable.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ch_id;
    #else
    binary::field<uint8_t, sc_uint4, 0, it> ch_id;
    #endif //DOXYGEN

    std::size_t trigtable_size;
    enum { trigtable_max_size = 2048 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : rnggt_idx(begin, begin_bit)
            , thres(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint32_t rnggt_idx;
        #else
        binary::field<uint32_t, sc_uint20, 0, it> rnggt_idx;
        #endif
        #ifdef DOXYGEN
        uint16_t thres;
        #else
        binary::field<uint16_t, sc_uint16, 20, it> thres;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition trigtable[2048];
    #else
    sequence<trigger_debug_stattrig_table, 36, 4, it> trigtable;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    trigger_debug_stattrig_table& operator=(const trigger_debug_stattrig_table<ito>& o) {
        ch_id = o.ch_id;
        trigtable_size = o.trigtable_size;
        trigtable.clean();
        for(unsigned n=0; n<trigtable_size; ++n){
            trigtable[n].rnggt_idx = o.trigtable[n].rnggt_idx;
            trigtable[n].thres = o.trigtable[n].thres;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct trigger_debug_stattrig_table<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef trigger_debug_stattrig_table<rebind_it> type;
    };

    enum { id_main = 96, id_sub = 0};

    uint8_t          ch_id;
    std::size_t trigtable_size;
    enum { trigtable_max_size = 2048 };
    struct sequence_definition {
        uint32_t         rnggt_idx;
        uint16_t         thres;
    } trigtable[2048];

    trigger_debug_stattrig_table()
        : ch_id()
    {}

    template<class it>
    trigger_debug_stattrig_table(const trigger_debug_stattrig_table<it>& o) {
        ch_id = o.ch_id;
        trigtable_size = o.trigtable.size();
        for(unsigned n=0; n<trigtable_size; ++n){
            trigtable[n].rnggt_idx = o.trigtable[n].rnggt_idx;
            trigtable[n].thres = o.trigtable[n].thres;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const trigger_debug_stattrig_table<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.ch_id;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.trigtable_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.trigtable[n].rnggt_idx
            << ", " << x.trigtable[n].thres
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, trigger_debug_stattrig_table<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.ch_id;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.trigtable_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.trigtable_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.trigtable[x.trigtable_size-1].rnggt_idx)
            >> ',' >> (x.trigtable[x.trigtable_size-1].thres)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct ttip_config
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef ttip_config<rebind_it> type;
    };

    typedef it iterator_type;

    ttip_config(it begin, it end, bool dirty=false)
        : ttip_version(begin)
        , num_channel(begin)
        , ext_channel(begin)
        , ext_signal(begin)
        , ext_delay(begin)
        , ext_subdivider(begin)
        , ext_bitmask(begin)
        , dmi_incr(begin)
        , dmi_min_time(begin)
        , dmi_max_time(begin)
        , dmi_dist_per_tick(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 134, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 224};
    it begin() const { return ttip_version.begin(); }
    it end() const { return dmi_dist_per_tick.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t ttip_version;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> ttip_version;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t num_channel;
    #else
    binary::field<uint8_t, sc_uint8, 32, it> num_channel;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ext_channel;
    #else
    binary::field<uint8_t, sc_uint7, 40, it> ext_channel;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t ext_signal;
    #else
    binary::field<uint8_t, sc_bit, 47, it> ext_signal;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t ext_delay;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> ext_delay;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t ext_subdivider;
    #else
    binary::field<uint32_t, sc_uint32, 64, it> ext_subdivider;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t ext_bitmask;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> ext_bitmask;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t dmi_incr;
    #else
    binary::field<int32_t, sc_int32, 128, it> dmi_incr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t dmi_min_time;
    #else
    binary::field<uint16_t, sc_uint16, 160, it> dmi_min_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t dmi_max_time;
    #else
    binary::field<uint16_t, sc_uint16, 176, it> dmi_max_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float dmi_dist_per_tick;
    #else
    binary::field<float, sc_float32, 192, it> dmi_dist_per_tick;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    ttip_config& operator=(const ttip_config<ito>& o) {
        ttip_version = o.ttip_version;
        num_channel = o.num_channel;
        ext_channel = o.ext_channel;
        ext_signal = o.ext_signal;
        ext_delay = o.ext_delay;
        ext_subdivider = o.ext_subdivider;
        ext_bitmask = o.ext_bitmask;
        dmi_incr = o.dmi_incr;
        dmi_min_time = o.dmi_min_time;
        dmi_max_time = o.dmi_max_time;
        dmi_dist_per_tick = o.dmi_dist_per_tick;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct ttip_config<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef ttip_config<rebind_it> type;
    };

    enum { id_main = 134, id_sub = 0};

    uint32_t         ttip_version;
    uint8_t          num_channel;
    uint8_t          ext_channel;
    uint8_t          ext_signal;
    uint16_t         ext_delay;
    uint32_t         ext_subdivider;
    uint32_t         ext_bitmask;
    int32_t          dmi_incr;
    uint16_t         dmi_min_time;
    uint16_t         dmi_max_time;
    float            dmi_dist_per_tick;

    ttip_config()
        : ttip_version()
        , num_channel()
        , ext_channel()
        , ext_signal()
        , ext_delay()
        , ext_subdivider()
        , ext_bitmask()
        , dmi_incr()
        , dmi_min_time()
        , dmi_max_time()
        , dmi_dist_per_tick()
    {}

    template<class it>
    ttip_config(const ttip_config<it>& o) {
        ttip_version = o.ttip_version;
        num_channel = o.num_channel;
        ext_channel = o.ext_channel;
        ext_signal = o.ext_signal;
        ext_delay = o.ext_delay;
        ext_subdivider = o.ext_subdivider;
        ext_bitmask = o.ext_bitmask;
        dmi_incr = o.dmi_incr;
        dmi_min_time = o.dmi_min_time;
        dmi_max_time = o.dmi_max_time;
        dmi_dist_per_tick = o.dmi_dist_per_tick;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const ttip_config<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.ttip_version;
        s << ", " << x.num_channel;
        s << ", " << x.ext_channel;
        s << ", " << x.ext_signal;
        s << ", " << x.ext_delay;
        s << ", " << x.ext_subdivider;
        s << ", " << x.ext_bitmask;
        s << ", " << x.dmi_incr;
        s << ", " << x.dmi_min_time;
        s << ", " << x.dmi_max_time;
        s << ", " << x.dmi_dist_per_tick;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, ttip_config<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.ttip_version;
        s >> ',' >> x.num_channel;
        s >> ',' >> x.ext_channel;
        s >> ',' >> x.ext_signal;
        s >> ',' >> x.ext_delay;
        s >> ',' >> x.ext_subdivider;
        s >> ',' >> x.ext_bitmask;
        s >> ',' >> x.dmi_incr;
        s >> ',' >> x.dmi_min_time;
        s >> ',' >> x.dmi_max_time;
        s >> ',' >> x.dmi_dist_per_tick;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct ttip_config_channel
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef ttip_config_channel<rebind_it> type;
    };

    typedef it iterator_type;

    ttip_config_channel(it begin, it end, bool dirty=false)
        : channel(begin)
        , output_descr(begin)
        , input_descr(begin)
        , output_usage(begin)
        , input_usage(begin)
        , out_polarity(begin)
        , out_duration(begin)
        , out_interval(begin)
        , out_delay(begin)
        , out_num_pulses(begin)
        , in_polarity(begin)
        , in_min_duration(begin)
        , in_max_duration(begin)
        , in_max_delay(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 135, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 648};
    it begin() const { return channel.begin(); }
    it end() const { return in_max_delay.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t channel;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> channel;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char output_descr[32];
    #else
    binary::array<char, 32, sc_char, 8, it> output_descr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char input_descr[32];
    #else
    binary::array<char, 32, sc_char, 264, it> input_descr;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t output_usage;
    #else
    binary::field<uint8_t, sc_uint8, 520, it> output_usage;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t input_usage;
    #else
    binary::field<uint8_t, sc_uint8, 528, it> input_usage;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t out_polarity;
    #else
    binary::field<uint8_t, sc_bit, 536, it> out_polarity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t out_duration;
    #else
    binary::field<uint16_t, sc_uint15, 537, it> out_duration;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t out_interval;
    #else
    binary::field<uint16_t, sc_uint16, 552, it> out_interval;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t out_delay;
    #else
    binary::field<uint16_t, sc_uint16, 568, it> out_delay;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t out_num_pulses;
    #else
    binary::field<uint16_t, sc_uint16, 584, it> out_num_pulses;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t in_polarity;
    #else
    binary::field<uint8_t, sc_bit, 600, it> in_polarity;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t in_min_duration;
    #else
    binary::field<uint16_t, sc_uint15, 601, it> in_min_duration;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t in_max_duration;
    #else
    binary::field<uint16_t, sc_uint16, 616, it> in_max_duration;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t in_max_delay;
    #else
    binary::field<uint16_t, sc_uint16, 632, it> in_max_delay;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    ttip_config_channel& operator=(const ttip_config_channel<ito>& o) {
        channel = o.channel;
        for(unsigned n=0; n<32; ++n) output_descr[n] = o.output_descr[n];
        for(unsigned n=0; n<32; ++n) input_descr[n] = o.input_descr[n];
        output_usage = o.output_usage;
        input_usage = o.input_usage;
        out_polarity = o.out_polarity;
        out_duration = o.out_duration;
        out_interval = o.out_interval;
        out_delay = o.out_delay;
        out_num_pulses = o.out_num_pulses;
        in_polarity = o.in_polarity;
        in_min_duration = o.in_min_duration;
        in_max_duration = o.in_max_duration;
        in_max_delay = o.in_max_delay;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct ttip_config_channel<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef ttip_config_channel<rebind_it> type;
    };

    enum { id_main = 135, id_sub = 0};

    uint8_t          channel;
    char             output_descr[32];
    char             input_descr[32];
    uint8_t          output_usage;
    uint8_t          input_usage;
    uint8_t          out_polarity;
    uint16_t         out_duration;
    uint16_t         out_interval;
    uint16_t         out_delay;
    uint16_t         out_num_pulses;
    uint8_t          in_polarity;
    uint16_t         in_min_duration;
    uint16_t         in_max_duration;
    uint16_t         in_max_delay;

    ttip_config_channel()
        : channel()
        , output_descr()
        , input_descr()
        , output_usage()
        , input_usage()
        , out_polarity()
        , out_duration()
        , out_interval()
        , out_delay()
        , out_num_pulses()
        , in_polarity()
        , in_min_duration()
        , in_max_duration()
        , in_max_delay()
    {}

    template<class it>
    ttip_config_channel(const ttip_config_channel<it>& o) {
        channel = o.channel;
        for(unsigned n=0; n<32; ++n) output_descr[n] = o.output_descr[n];
        for(unsigned n=0; n<32; ++n) input_descr[n] = o.input_descr[n];
        output_usage = o.output_usage;
        input_usage = o.input_usage;
        out_polarity = o.out_polarity;
        out_duration = o.out_duration;
        out_interval = o.out_interval;
        out_delay = o.out_delay;
        out_num_pulses = o.out_num_pulses;
        in_polarity = o.in_polarity;
        in_min_duration = o.in_min_duration;
        in_max_duration = o.in_max_duration;
        in_max_delay = o.in_max_delay;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const ttip_config_channel<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.channel;
        s << ", "; write_array(s, 32, x.output_descr);
        s << ", "; write_array(s, 32, x.input_descr);
        s << ", " << x.output_usage;
        s << ", " << x.input_usage;
        s << ", " << x.out_polarity;
        s << ", " << x.out_duration;
        s << ", " << x.out_interval;
        s << ", " << x.out_delay;
        s << ", " << x.out_num_pulses;
        s << ", " << x.in_polarity;
        s << ", " << x.in_min_duration;
        s << ", " << x.in_max_duration;
        s << ", " << x.in_max_delay;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, ttip_config_channel<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.channel;
        s >> ','; read_array(s, 32, x.output_descr);
        s >> ','; read_array(s, 32, x.input_descr);
        s >> ',' >> x.output_usage;
        s >> ',' >> x.input_usage;
        s >> ',' >> x.out_polarity;
        s >> ',' >> x.out_duration;
        s >> ',' >> x.out_interval;
        s >> ',' >> x.out_delay;
        s >> ',' >> x.out_num_pulses;
        s >> ',' >> x.in_polarity;
        s >> ',' >> x.in_min_duration;
        s >> ',' >> x.in_max_duration;
        s >> ',' >> x.in_max_delay;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct ttip_start_stop
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef ttip_start_stop<rebind_it> type;
    };

    typedef it iterator_type;

    ttip_start_stop(it begin, it end, bool dirty=false)
        : channel_mask(begin)
        , start(begin)
        , dummy(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 137, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 64};
    it begin() const { return channel_mask.begin(); }
    it end() const { return dummy.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t channel_mask;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> channel_mask;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t start;
    #else
    binary::field<uint8_t, sc_bit, 32, it> start;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t dummy;
    #else
    binary::field<uint32_t, sc_uint31, 33, it> dummy;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    ttip_start_stop& operator=(const ttip_start_stop<ito>& o) {
        channel_mask = o.channel_mask;
        start = o.start;
        dummy = o.dummy;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct ttip_start_stop<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef ttip_start_stop<rebind_it> type;
    };

    enum { id_main = 137, id_sub = 0};

    uint32_t         channel_mask;
    uint8_t          start;
    uint32_t         dummy;

    ttip_start_stop()
        : channel_mask()
        , start()
        , dummy()
    {}

    template<class it>
    ttip_start_stop(const ttip_start_stop<it>& o) {
        channel_mask = o.channel_mask;
        start = o.start;
        dummy = o.dummy;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const ttip_start_stop<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.channel_mask;
        s << ", " << x.start;
        s << ", " << x.dummy;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, ttip_start_stop<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.channel_mask;
        s >> ',' >> x.start;
        s >> ',' >> x.dummy;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct ttip_timestamp
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef ttip_timestamp<rebind_it> type;
    };

    typedef it iterator_type;

    ttip_timestamp(it begin, it end, bool dirty=false)
        : exttime(begin)
        , is_int_time(begin)
        , channel(begin)
        , input_width(begin)
        , count(begin)
        , flags(begin)
        , dmi_value(begin)
        , frame_angle(begin)
        , line_angle(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 136, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 256};
    it begin() const { return exttime.begin(); }
    it end() const { return line_angle.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint64_t exttime;
    #else
    binary::field<uint64_t, sc_uint64, 0, it> exttime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t is_int_time;
    #else
    binary::field<uint8_t, sc_uint8, 64, it> is_int_time;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t channel;
    #else
    binary::field<uint8_t, sc_uint8, 72, it> channel;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t input_width;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> input_width;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t count;
    #else
    binary::field<uint32_t, sc_uint32, 96, it> count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t flags;
    #else
    binary::field<uint32_t, sc_uint32, 128, it> flags;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t dmi_value;
    #else
    binary::field<int32_t, sc_int32, 160, it> dmi_value;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_angle;
    #else
    binary::field<uint32_t, sc_uint32, 192, it> frame_angle;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_angle;
    #else
    binary::field<uint32_t, sc_uint32, 224, it> line_angle;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    ttip_timestamp& operator=(const ttip_timestamp<ito>& o) {
        exttime = o.exttime;
        is_int_time = o.is_int_time;
        channel = o.channel;
        input_width = o.input_width;
        count = o.count;
        flags = o.flags;
        dmi_value = o.dmi_value;
        frame_angle = o.frame_angle;
        line_angle = o.line_angle;
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct ttip_timestamp<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef ttip_timestamp<rebind_it> type;
    };

    enum { id_main = 136, id_sub = 0};

    uint64_t         exttime;
    uint8_t          is_int_time;
    uint8_t          channel;
    uint16_t         input_width;
    uint32_t         count;
    uint32_t         flags;
    int32_t          dmi_value;
    uint32_t         frame_angle;
    uint32_t         line_angle;

    ttip_timestamp()
        : exttime()
        , is_int_time()
        , channel()
        , input_width()
        , count()
        , flags()
        , dmi_value()
        , frame_angle()
        , line_angle()
    {}

    template<class it>
    ttip_timestamp(const ttip_timestamp<it>& o) {
        exttime = o.exttime;
        is_int_time = o.is_int_time;
        channel = o.channel;
        input_width = o.input_width;
        count = o.count;
        flags = o.flags;
        dmi_value = o.dmi_value;
        frame_angle = o.frame_angle;
        line_angle = o.line_angle;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const ttip_timestamp<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.exttime;
        s << ", " << x.is_int_time;
        s << ", " << x.channel;
        s << ", " << x.input_width;
        s << ", " << x.count;
        s << ", " << x.flags;
        s << ", " << x.dmi_value;
        s << ", " << x.frame_angle;
        s << ", " << x.line_angle;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, ttip_timestamp<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.exttime;
        s >> ',' >> x.is_int_time;
        s >> ',' >> x.channel;
        s >> ',' >> x.input_width;
        s >> ',' >> x.count;
        s >> ',' >> x.flags;
        s >> ',' >> x.dmi_value;
        s >> ',' >> x.frame_angle;
        s >> ',' >> x.line_angle;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct ublox_lea5t_rxm
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef ublox_lea5t_rxm<rebind_it> type;
    };

    typedef it iterator_type;

    ublox_lea5t_rxm(it begin, it end, bool dirty=false)
        : systime(begin)
        , iTOW(begin)
        , week(begin)
        , numSV(begin)
        , sv_info(begin, end, sv_info_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 59999, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 3936};
    it begin() const { return systime.begin(); }
    it end() const { return sv_info.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int32_t iTOW;
    #else
    binary::field<int32_t, sc_int32, 32, it> iTOW;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int16_t week;
    #else
    binary::field<int16_t, sc_int16, 64, it> week;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t numSV;
    #else
    binary::field<uint8_t, sc_uint8, 80, it> numSV;
    #endif //DOXYGEN

    std::size_t sv_info_size;
    enum { sv_info_max_size = 20 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : cpMes(begin, begin_bit)
            , prMes(begin, begin_bit)
            , doMes(begin, begin_bit)
            , sv(begin, begin_bit)
            , mesQI(begin, begin_bit)
            , cno(begin, begin_bit)
            , lli(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        double cpMes;
        #else
        binary::field<double, sc_float64, 0, it> cpMes;
        #endif
        #ifdef DOXYGEN
        double prMes;
        #else
        binary::field<double, sc_float64, 64, it> prMes;
        #endif
        #ifdef DOXYGEN
        float doMes;
        #else
        binary::field<float, sc_float32, 128, it> doMes;
        #endif
        #ifdef DOXYGEN
        uint8_t sv;
        #else
        binary::field<uint8_t, sc_uint8, 160, it> sv;
        #endif
        #ifdef DOXYGEN
        int8_t mesQI;
        #else
        binary::field<int8_t, sc_int8, 168, it> mesQI;
        #endif
        #ifdef DOXYGEN
        int8_t cno;
        #else
        binary::field<int8_t, sc_int8, 176, it> cno;
        #endif
        #ifdef DOXYGEN
        uint8_t lli;
        #else
        binary::field<uint8_t, sc_uint8, 184, it> lli;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition sv_info[20];
    #else
    sequence<ublox_lea5t_rxm, 192, 96, it> sv_info;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    ublox_lea5t_rxm& operator=(const ublox_lea5t_rxm<ito>& o) {
        systime = o.systime;
        iTOW = o.iTOW;
        week = o.week;
        numSV = o.numSV;
        sv_info_size = o.sv_info_size;
        sv_info.clean();
        for(unsigned n=0; n<sv_info_size; ++n){
            sv_info[n].cpMes = o.sv_info[n].cpMes;
            sv_info[n].prMes = o.sv_info[n].prMes;
            sv_info[n].doMes = o.sv_info[n].doMes;
            sv_info[n].sv = o.sv_info[n].sv;
            sv_info[n].mesQI = o.sv_info[n].mesQI;
            sv_info[n].cno = o.sv_info[n].cno;
            sv_info[n].lli = o.sv_info[n].lli;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct ublox_lea5t_rxm<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef ublox_lea5t_rxm<rebind_it> type;
    };

    enum { id_main = 59999, id_sub = 0};

    uint32_t         systime;
    int32_t          iTOW;
    int16_t          week;
    uint8_t          numSV;
    std::size_t sv_info_size;
    enum { sv_info_max_size = 20 };
    struct sequence_definition {
        double           cpMes;
        double           prMes;
        float            doMes;
        uint8_t          sv;
        int8_t           mesQI;
        int8_t           cno;
        uint8_t          lli;
    } sv_info[20];

    ublox_lea5t_rxm()
        : systime()
        , iTOW()
        , week()
        , numSV()
    {}

    template<class it>
    ublox_lea5t_rxm(const ublox_lea5t_rxm<it>& o) {
        systime = o.systime;
        iTOW = o.iTOW;
        week = o.week;
        numSV = o.numSV;
        sv_info_size = o.sv_info.size();
        for(unsigned n=0; n<sv_info_size; ++n){
            sv_info[n].cpMes = o.sv_info[n].cpMes;
            sv_info[n].prMes = o.sv_info[n].prMes;
            sv_info[n].doMes = o.sv_info[n].doMes;
            sv_info[n].sv = o.sv_info[n].sv;
            sv_info[n].mesQI = o.sv_info[n].mesQI;
            sv_info[n].cno = o.sv_info[n].cno;
            sv_info[n].lli = o.sv_info[n].lli;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const ublox_lea5t_rxm<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.iTOW;
        s << ", " << x.week;
        s << ", " << x.numSV;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.sv_info_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.sv_info[n].cpMes
            << ", " << x.sv_info[n].prMes
            << ", " << x.sv_info[n].doMes
            << ", " << x.sv_info[n].sv
            << ", " << x.sv_info[n].mesQI
            << ", " << x.sv_info[n].cno
            << ", " << x.sv_info[n].lli
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, ublox_lea5t_rxm<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.iTOW;
        s >> ',' >> x.week;
        s >> ',' >> x.numSV;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.sv_info_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.sv_info_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.sv_info[x.sv_info_size-1].cpMes)
            >> ',' >> (x.sv_info[x.sv_info_size-1].prMes)
            >> ',' >> (x.sv_info[x.sv_info_size-1].doMes)
            >> ',' >> (x.sv_info[x.sv_info_size-1].sv)
            >> ',' >> (x.sv_info[x.sv_info_size-1].mesQI)
            >> ',' >> (x.sv_info[x.sv_info_size-1].cno)
            >> ',' >> (x.sv_info[x.sv_info_size-1].lli)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct ublox_lea5t_rxm_sfrb
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef ublox_lea5t_rxm_sfrb<rebind_it> type;
    };

    typedef it iterator_type;

    ublox_lea5t_rxm_sfrb(it begin, it end, bool dirty=false)
        : systime(begin)
        , chn(begin)
        , svid(begin)
        , dwrd(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 59998, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1328};
    it begin() const { return systime.begin(); }
    it end() const { return dwrd.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t chn;
    #else
    binary::field<uint8_t, sc_uint8, 32, it> chn;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t svid;
    #else
    binary::field<uint8_t, sc_uint8, 40, it> svid;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t dwrd[40];
    #else
    binary::array<uint32_t, 40, sc_uint32, 48, it> dwrd;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    ublox_lea5t_rxm_sfrb& operator=(const ublox_lea5t_rxm_sfrb<ito>& o) {
        systime = o.systime;
        chn = o.chn;
        svid = o.svid;
        for(unsigned n=0; n<40; ++n) dwrd[n] = o.dwrd[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct ublox_lea5t_rxm_sfrb<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef ublox_lea5t_rxm_sfrb<rebind_it> type;
    };

    enum { id_main = 59998, id_sub = 0};

    uint32_t         systime;
    uint8_t          chn;
    uint8_t          svid;
    uint32_t         dwrd[40];

    ublox_lea5t_rxm_sfrb()
        : systime()
        , chn()
        , svid()
        , dwrd()
    {}

    template<class it>
    ublox_lea5t_rxm_sfrb(const ublox_lea5t_rxm_sfrb<it>& o) {
        systime = o.systime;
        chn = o.chn;
        svid = o.svid;
        for(unsigned n=0; n<40; ++n) dwrd[n] = o.dwrd[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const ublox_lea5t_rxm_sfrb<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.chn;
        s << ", " << x.svid;
        s << ", "; write_array(s, 40, x.dwrd);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, ublox_lea5t_rxm_sfrb<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.chn;
        s >> ',' >> x.svid;
        s >> ','; read_array(s, 40, x.dwrd);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! units information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct units
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef units<rebind_it> type;
    };

    typedef it iterator_type;

    units(it begin, it end, bool dirty=false)
        : range_unit(begin)
        , line_circle_count(begin)
        , frame_circle_count(begin)
        , time_unit(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 2, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 128};
    it begin() const { return range_unit.begin(); }
    it end() const { return time_unit.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_unit;//!<  length of 1 LSB of range in meter 
    #else
    binary::field<float, sc_float32, 0, it> range_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_circle_count;//!<  number of LSBs per full rotation about line axis 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_circle_count;//!<  number of LSBs per full rotation about frame axis 
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit;//!<  duration of 1 LSB of time in seconds 
    #else
    binary::field<float, sc_float32, 96, it> time_unit;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    units& operator=(const units<ito>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct units<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef units<rebind_it> type;
    };

    enum { id_main = 2, id_sub = 0};

    float            range_unit;
    uint32_t         line_circle_count;
    uint32_t         frame_circle_count;
    float            time_unit;

    units()
        : range_unit()
        , line_circle_count()
        , frame_circle_count()
        , time_unit()
    {}

    template<class it>
    units(const units<it>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const units<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range_unit;
        s << ", " << x.line_circle_count;
        s << ", " << x.frame_circle_count;
        s << ", " << x.time_unit;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, units<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range_unit;
        s >> ',' >> x.line_circle_count;
        s >> ',' >> x.frame_circle_count;
        s >> ',' >> x.time_unit;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! units information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct units_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef units_1<rebind_it> type;
    };

    typedef it iterator_type;

    units_1(it begin, it end, bool dirty=false)
        : range_unit(begin)
        , line_circle_count(begin)
        , frame_circle_count(begin)
        , time_unit(begin)
        , amplitude_unit(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 2, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 160};
    it begin() const { return range_unit.begin(); }
    it end() const { return amplitude_unit.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_unit;//!<  length of 1 LSB of range in meter 
    #else
    binary::field<float, sc_float32, 0, it> range_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_circle_count;//!<  number of LSBs per full rotation about line axis 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_circle_count;//!<  number of LSBs per full rotation about frame axis 
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit;//!<  duration of 1 LSB of time in [sec] 
    #else
    binary::field<float, sc_float32, 96, it> time_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_unit;//!<  width of 1 LSB of amplitude and reflectance in dB 
    #else
    binary::field<float, sc_float32, 128, it> amplitude_unit;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    units_1& operator=(const units_1<ito>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
        amplitude_unit = o.amplitude_unit;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct units_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef units_1<rebind_it> type;
    };

    enum { id_main = 2, id_sub = 1};

    float            range_unit;
    uint32_t         line_circle_count;
    uint32_t         frame_circle_count;
    float            time_unit;
    float            amplitude_unit;

    units_1()
        : range_unit()
        , line_circle_count()
        , frame_circle_count()
        , time_unit()
        , amplitude_unit()
    {}

    template<class it>
    units_1(const units_1<it>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
        amplitude_unit = o.amplitude_unit;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const units_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range_unit;
        s << ", " << x.line_circle_count;
        s << ", " << x.frame_circle_count;
        s << ", " << x.time_unit;
        s << ", " << x.amplitude_unit;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, units_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range_unit;
        s >> ',' >> x.line_circle_count;
        s >> ',' >> x.frame_circle_count;
        s >> ',' >> x.time_unit;
        s >> ',' >> x.amplitude_unit;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! units information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct units_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef units_2<rebind_it> type;
    };

    typedef it iterator_type;

    units_2(it begin, it end, bool dirty=false)
        : range_unit(begin)
        , line_circle_count(begin)
        , frame_circle_count(begin)
        , time_unit(begin)
        , amplitude_unit(begin)
        , time_unit_hi_prec(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 2, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 192};
    it begin() const { return range_unit.begin(); }
    it end() const { return time_unit_hi_prec.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_unit;//!<  length of 1 LSB of range in meter 
    #else
    binary::field<float, sc_float32, 0, it> range_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_circle_count;//!<  number of LSBs per full rotation about line axis 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_circle_count;//!<  number of LSBs per full rotation about frame axis 
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit;//!<  duration of 1 LSB of time in [sec] 
    #else
    binary::field<float, sc_float32, 96, it> time_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_unit;//!<  width of 1 LSB of amplitude and reflectance in dB 
    #else
    binary::field<float, sc_float32, 128, it> amplitude_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit_hi_prec;//!<  duration of 1 LSB of high-precision systime in [sec] 
    #else
    binary::field<float, sc_float32, 160, it> time_unit_hi_prec;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    units_2& operator=(const units_2<ito>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
        amplitude_unit = o.amplitude_unit;
        time_unit_hi_prec = o.time_unit_hi_prec;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct units_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef units_2<rebind_it> type;
    };

    enum { id_main = 2, id_sub = 2};

    float            range_unit;
    uint32_t         line_circle_count;
    uint32_t         frame_circle_count;
    float            time_unit;
    float            amplitude_unit;
    float            time_unit_hi_prec;

    units_2()
        : range_unit()
        , line_circle_count()
        , frame_circle_count()
        , time_unit()
        , amplitude_unit()
        , time_unit_hi_prec()
    {}

    template<class it>
    units_2(const units_2<it>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
        amplitude_unit = o.amplitude_unit;
        time_unit_hi_prec = o.time_unit_hi_prec;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const units_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range_unit;
        s << ", " << x.line_circle_count;
        s << ", " << x.frame_circle_count;
        s << ", " << x.time_unit;
        s << ", " << x.amplitude_unit;
        s << ", " << x.time_unit_hi_prec;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, units_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range_unit;
        s >> ',' >> x.line_circle_count;
        s >> ',' >> x.frame_circle_count;
        s >> ',' >> x.time_unit;
        s >> ',' >> x.amplitude_unit;
        s >> ',' >> x.time_unit_hi_prec;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! units information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct units_3
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef units_3<rebind_it> type;
    };

    typedef it iterator_type;

    units_3(it begin, it end, bool dirty=false)
        : range_unit(begin)
        , line_circle_count(begin)
        , frame_circle_count(begin)
        , time_unit(begin)
        , amplitude_unit(begin)
        , time_unit_hi_prec(begin)
        , time_bits_hi_prec(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 2, id_sub = 3};
    #ifndef DOXYGEN
    enum { max_bit_width = 224};
    it begin() const { return range_unit.begin(); }
    it end() const { return time_bits_hi_prec.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_unit;//!<  length of 1 LSB of range in meter 
    #else
    binary::field<float, sc_float32, 0, it> range_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_circle_count;//!<  number of LSBs per full rotation about line axis 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_circle_count;//!<  number of LSBs per full rotation about frame axis 
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit;//!<  duration of 1 LSB of time in [sec] 
    #else
    binary::field<float, sc_float32, 96, it> time_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_unit;//!<  width of 1 LSB of amplitude and reflectance in dB 
    #else
    binary::field<float, sc_float32, 128, it> amplitude_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit_hi_prec;//!<  duration of 1 LSB of high-precision systime in [sec] 
    #else
    binary::field<float, sc_float32, 160, it> time_unit_hi_prec;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t time_bits_hi_prec;//!<  number of valid bits in hi-prec timestamp 
    #else
    binary::field<uint32_t, sc_uint32, 192, it> time_bits_hi_prec;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    units_3& operator=(const units_3<ito>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
        amplitude_unit = o.amplitude_unit;
        time_unit_hi_prec = o.time_unit_hi_prec;
        time_bits_hi_prec = o.time_bits_hi_prec;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct units_3<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef units_3<rebind_it> type;
    };

    enum { id_main = 2, id_sub = 3};

    float            range_unit;
    uint32_t         line_circle_count;
    uint32_t         frame_circle_count;
    float            time_unit;
    float            amplitude_unit;
    float            time_unit_hi_prec;
    uint32_t         time_bits_hi_prec;

    units_3()
        : range_unit()
        , line_circle_count()
        , frame_circle_count()
        , time_unit()
        , amplitude_unit()
        , time_unit_hi_prec()
        , time_bits_hi_prec()
    {}

    template<class it>
    units_3(const units_3<it>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
        amplitude_unit = o.amplitude_unit;
        time_unit_hi_prec = o.time_unit_hi_prec;
        time_bits_hi_prec = o.time_bits_hi_prec;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const units_3<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range_unit;
        s << ", " << x.line_circle_count;
        s << ", " << x.frame_circle_count;
        s << ", " << x.time_unit;
        s << ", " << x.amplitude_unit;
        s << ", " << x.time_unit_hi_prec;
        s << ", " << x.time_bits_hi_prec;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, units_3<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range_unit;
        s >> ',' >> x.line_circle_count;
        s >> ',' >> x.frame_circle_count;
        s >> ',' >> x.time_unit;
        s >> ',' >> x.amplitude_unit;
        s >> ',' >> x.time_unit_hi_prec;
        s >> ',' >> x.time_bits_hi_prec;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! units information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct units_4
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef units_4<rebind_it> type;
    };

    typedef it iterator_type;

    units_4(it begin, it end, bool dirty=false)
        : range_unit(begin)
        , line_circle_count(begin)
        , frame_circle_count(begin)
        , time_unit(begin)
        , amplitude_unit(begin)
        , time_unit_hi_prec(begin)
        , time_bits_hi_prec(begin)
        , time_unit_exttime(begin)
        , epoch_exttime(begin)
        , clock_source(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 2, id_sub = 4};
    #ifndef DOXYGEN
    enum { max_bit_width = 640};
    it begin() const { return range_unit.begin(); }
    it end() const { return clock_source.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float range_unit;//!<  length of 1 LSB of range in meter 
    #else
    binary::field<float, sc_float32, 0, it> range_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t line_circle_count;//!<  number of LSBs per full rotation about line axis 
    #else
    binary::field<uint32_t, sc_uint32, 32, it> line_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t frame_circle_count;//!<  number of LSBs per full rotation about frame axis 
    #else
    binary::field<uint32_t, sc_uint32, 64, it> frame_circle_count;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit;//!<  duration of 1 LSB of time in [sec] 
    #else
    binary::field<float, sc_float32, 96, it> time_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float amplitude_unit;//!<  width of 1 LSB of amplitude and reflectance in dB 
    #else
    binary::field<float, sc_float32, 128, it> amplitude_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit_hi_prec;//!<  duration of 1 LSB of high-precision systime in [sec] 
    #else
    binary::field<float, sc_float32, 160, it> time_unit_hi_prec;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t time_bits_hi_prec;//!<  number of valid bits in hi-prec timestamp 
    #else
    binary::field<uint32_t, sc_uint32, 192, it> time_bits_hi_prec;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float time_unit_exttime;//!<  duration of 1 LSB of exttime in packet laser_shot_utctime_origin_direction 
    #else
    binary::field<float, sc_float32, 224, it> time_unit_exttime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char epoch_exttime[32];//!<  epoch of exttime in UNKNOWN, YYYYMMDDTHH:MM:SS 
    #else
    binary::array<char, 32, sc_char, 256, it> epoch_exttime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char clock_source[16];//!<  UNKNOWN, RTC, GPS, UTC 
    #else
    binary::array<char, 16, sc_char, 512, it> clock_source;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    units_4& operator=(const units_4<ito>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
        amplitude_unit = o.amplitude_unit;
        time_unit_hi_prec = o.time_unit_hi_prec;
        time_bits_hi_prec = o.time_bits_hi_prec;
        time_unit_exttime = o.time_unit_exttime;
        for(unsigned n=0; n<32; ++n) epoch_exttime[n] = o.epoch_exttime[n];
        for(unsigned n=0; n<16; ++n) clock_source[n] = o.clock_source[n];
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct units_4<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef units_4<rebind_it> type;
    };

    enum { id_main = 2, id_sub = 4};

    float            range_unit;
    uint32_t         line_circle_count;
    uint32_t         frame_circle_count;
    float            time_unit;
    float            amplitude_unit;
    float            time_unit_hi_prec;
    uint32_t         time_bits_hi_prec;
    float            time_unit_exttime;
    char             epoch_exttime[32];
    char             clock_source[16];

    units_4()
        : range_unit()
        , line_circle_count()
        , frame_circle_count()
        , time_unit()
        , amplitude_unit()
        , time_unit_hi_prec()
        , time_bits_hi_prec()
        , time_unit_exttime()
        , epoch_exttime()
        , clock_source()
    {}

    template<class it>
    units_4(const units_4<it>& o) {
        range_unit = o.range_unit;
        line_circle_count = o.line_circle_count;
        frame_circle_count = o.frame_circle_count;
        time_unit = o.time_unit;
        amplitude_unit = o.amplitude_unit;
        time_unit_hi_prec = o.time_unit_hi_prec;
        time_bits_hi_prec = o.time_bits_hi_prec;
        time_unit_exttime = o.time_unit_exttime;
        for(unsigned n=0; n<32; ++n) epoch_exttime[n] = o.epoch_exttime[n];
        for(unsigned n=0; n<16; ++n) clock_source[n] = o.clock_source[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const units_4<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.range_unit;
        s << ", " << x.line_circle_count;
        s << ", " << x.frame_circle_count;
        s << ", " << x.time_unit;
        s << ", " << x.amplitude_unit;
        s << ", " << x.time_unit_hi_prec;
        s << ", " << x.time_bits_hi_prec;
        s << ", " << x.time_unit_exttime;
        s << ", "; write_array(s, 32, x.epoch_exttime);
        s << ", "; write_array(s, 16, x.clock_source);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, units_4<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.range_unit;
        s >> ',' >> x.line_circle_count;
        s >> ',' >> x.frame_circle_count;
        s >> ',' >> x.time_unit;
        s >> ',' >> x.amplitude_unit;
        s >> ',' >> x.time_unit_hi_prec;
        s >> ',' >> x.time_bits_hi_prec;
        s >> ',' >> x.time_unit_exttime;
        s >> ','; read_array(s, 32, x.epoch_exttime);
        s >> ','; read_array(s, 16, x.clock_source);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! units information

//! <para>This package belongs to the predefined selectors:</para>
//! <para>attribute, instrument</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct units_IMU
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef units_IMU<rebind_it> type;
    };

    typedef it iterator_type;

    units_IMU(it begin, it end, bool dirty=false)
        : gyro_unit(begin)
        , accl_unit(begin)
        , timestamp_unit(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 60, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 96};
    it begin() const { return gyro_unit.begin(); }
    it end() const { return timestamp_unit.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    float gyro_unit;//!<  in deg/s 
    #else
    binary::field<float, sc_float32, 0, it> gyro_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float accl_unit;//!<  in meter/sec^2 
    #else
    binary::field<float, sc_float32, 32, it> accl_unit;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    float timestamp_unit;//!<  in sec 
    #else
    binary::field<float, sc_float32, 64, it> timestamp_unit;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    units_IMU& operator=(const units_IMU<ito>& o) {
        gyro_unit = o.gyro_unit;
        accl_unit = o.accl_unit;
        timestamp_unit = o.timestamp_unit;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct units_IMU<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef units_IMU<rebind_it> type;
    };

    enum { id_main = 60, id_sub = 0};

    float            gyro_unit;
    float            accl_unit;
    float            timestamp_unit;

    units_IMU()
        : gyro_unit()
        , accl_unit()
        , timestamp_unit()
    {}

    template<class it>
    units_IMU(const units_IMU<it>& o) {
        gyro_unit = o.gyro_unit;
        accl_unit = o.accl_unit;
        timestamp_unit = o.timestamp_unit;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const units_IMU<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.gyro_unit;
        s << ", " << x.accl_unit;
        s << ", " << x.timestamp_unit;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, units_IMU<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.gyro_unit;
        s >> ',' >> x.accl_unit;
        s >> ',' >> x.timestamp_unit;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! spontaneous information and error messages

//! <para>This package belongs to the predefined selectors:</para>
//! <para>notify</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct unsolicited_message
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef unsolicited_message<rebind_it> type;
    };

    typedef it iterator_type;

    unsolicited_message(it begin, it end, bool dirty=false)
        : systime(begin)
        , year(begin)
        , month(begin)
        , day(begin)
        , hour(begin)
        , minute(begin)
        , second(begin)
        , utc_offset(begin)
        , type(begin)
        , intended_followup_actions(begin)
        , id(begin)
        , message(begin)
        , RESERVED_00(begin)
        , RESERVED_01(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 41, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 1736};
    it begin() const { return systime.begin(); }
    it end() const { return RESERVED_01.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  systime of message in units of uints.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t year;//!<  year 
    #else
    binary::field<uint16_t, sc_uint16, 32, it> year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t month;//!<  month  1 .. 12 
    #else
    binary::field<uint8_t, sc_uint8, 48, it> month;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t day;//!<  day    1 .. 31 
    #else
    binary::field<uint8_t, sc_uint8, 56, it> day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hour;//!<  hour   0 .. 23 
    #else
    binary::field<uint8_t, sc_uint8, 64, it> hour;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t minute;//!<  minute 0 .. 59 
    #else
    binary::field<uint8_t, sc_uint8, 72, it> minute;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t second;//!<  second 0 .. 59 (60 if leap second) 
    #else
    binary::field<uint8_t, sc_uint8, 80, it> second;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t utc_offset;//!<  diff. between localtime and UTC 
    #else
    binary::field<int8_t, sc_int8, 88, it> utc_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t type;//!<  (INFO=1,WARNING=2,ERROR=3,FATAL=4) 
    #else
    binary::field<uint8_t, sc_uint8, 96, it> type;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t intended_followup_actions;//!<  bitmapped actions (1 .. shutting down laser power supply                     2 .. stopping current scan                     4 .. aborting current scan                     8 .. initiating shutdown                    16 .. normal operation initiated) 
    #else
    binary::field<uint32_t, sc_uint32, 104, it> intended_followup_actions;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t id;//!<  unique (error) number 
    #else
    binary::field<uint32_t, sc_uint32, 136, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char message[128];//!<  displayable user info 
    #else
    binary::array<char, 128, sc_char, 168, it> message;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_00;
    #else
    binary::field<uint32_t, sc_uint32, 1192, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char RESERVED_01[64];
    #else
    binary::array<char, 64, sc_char, 1224, it> RESERVED_01;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    unsolicited_message& operator=(const unsolicited_message<ito>& o) {
        systime = o.systime;
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        utc_offset = o.utc_offset;
        type = o.type;
        intended_followup_actions = o.intended_followup_actions;
        id = o.id;
        for(unsigned n=0; n<128; ++n) message[n] = o.message[n];
        RESERVED_00 = o.RESERVED_00;
        for(unsigned n=0; n<64; ++n) RESERVED_01[n] = o.RESERVED_01[n];
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct unsolicited_message<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef unsolicited_message<rebind_it> type;
    };

    enum { id_main = 41, id_sub = 0};

    uint32_t         systime;
    uint16_t         year;
    uint8_t          month;
    uint8_t          day;
    uint8_t          hour;
    uint8_t          minute;
    uint8_t          second;
    int8_t           utc_offset;
    uint8_t          type;
    uint32_t         intended_followup_actions;
    uint32_t         id;
    char             message[128];
    uint32_t         RESERVED_00;
    char             RESERVED_01[64];

    unsolicited_message()
        : systime()
        , year()
        , month()
        , day()
        , hour()
        , minute()
        , second()
        , utc_offset()
        , type()
        , intended_followup_actions()
        , id()
        , message()
        , RESERVED_00()
        , RESERVED_01()
    {}

    template<class it>
    unsolicited_message(const unsolicited_message<it>& o) {
        systime = o.systime;
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        utc_offset = o.utc_offset;
        type = o.type;
        intended_followup_actions = o.intended_followup_actions;
        id = o.id;
        for(unsigned n=0; n<128; ++n) message[n] = o.message[n];
        RESERVED_00 = o.RESERVED_00;
        for(unsigned n=0; n<64; ++n) RESERVED_01[n] = o.RESERVED_01[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const unsolicited_message<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.year;
        s << ", " << x.month;
        s << ", " << x.day;
        s << ", " << x.hour;
        s << ", " << x.minute;
        s << ", " << x.second;
        s << ", " << x.utc_offset;
        s << ", " << x.type;
        s << ", " << x.intended_followup_actions;
        s << ", " << x.id;
        s << ", "; write_array(s, 128, x.message);
        s << ", " << x.RESERVED_00;
        s << ", "; write_array(s, 64, x.RESERVED_01);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, unsolicited_message<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.year;
        s >> ',' >> x.month;
        s >> ',' >> x.day;
        s >> ',' >> x.hour;
        s >> ',' >> x.minute;
        s >> ',' >> x.second;
        s >> ',' >> x.utc_offset;
        s >> ',' >> x.type;
        s >> ',' >> x.intended_followup_actions;
        s >> ',' >> x.id;
        s >> ','; read_array(s, 128, x.message);
        s >> ',' >> x.RESERVED_00;
        s >> ','; read_array(s, 64, x.RESERVED_01);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! spontaneous information and error messages

//! <para>This package belongs to the predefined selectors:</para>
//! <para>notify</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct unsolicited_message_1
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef unsolicited_message_1<rebind_it> type;
    };

    typedef it iterator_type;

    unsolicited_message_1(it begin, it end, bool dirty=false)
        : systime(begin)
        , year(begin)
        , month(begin)
        , day(begin)
        , hour(begin)
        , minute(begin)
        , second(begin)
        , utc_offset(begin)
        , type(begin)
        , intended_followup_actions(begin)
        , id(begin)
        , message(begin)
        , RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 41, id_sub = 1};
    #ifndef DOXYGEN
    enum { max_bit_width = 1768};
    it begin() const { return systime.begin(); }
    it end() const { return RESERVED_02.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  systime of message in units of uints.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t year;//!<  year 
    #else
    binary::field<uint16_t, sc_uint16, 32, it> year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t month;//!<  month  1 .. 12 
    #else
    binary::field<uint8_t, sc_uint8, 48, it> month;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t day;//!<  day    1 .. 31 
    #else
    binary::field<uint8_t, sc_uint8, 56, it> day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hour;//!<  hour   0 .. 23 
    #else
    binary::field<uint8_t, sc_uint8, 64, it> hour;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t minute;//!<  minute 0 .. 59 
    #else
    binary::field<uint8_t, sc_uint8, 72, it> minute;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t second;//!<  second 0 .. 59 (60 if leap second) 
    #else
    binary::field<uint8_t, sc_uint8, 80, it> second;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t utc_offset;//!<  diff. between localtime and UTC 
    #else
    binary::field<int8_t, sc_int8, 88, it> utc_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t type;//!<  (INFO=1,WARNING=2,ERROR=3,FATAL=4) 
    #else
    binary::field<uint8_t, sc_uint8, 96, it> type;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t intended_followup_actions;//!<  bitmapped actions (1 .. shutting down laser power supply                     2 .. stopping current scan                     4 .. aborting current scan                     8 .. initiating shutdown                    16 .. normal operation initiated) 
    #else
    binary::field<uint32_t, sc_uint32, 104, it> intended_followup_actions;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t id;//!<  unique (error) number 
    #else
    binary::field<uint32_t, sc_uint32, 136, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char message[128];//!<  displayable user info 
    #else
    binary::array<char, 128, sc_char, 168, it> message;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_00;
    #else
    binary::field<uint32_t, sc_uint32, 1192, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char RESERVED_01[64];
    #else
    binary::array<char, 64, sc_char, 1224, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_02;
    #else
    binary::field<uint32_t, sc_uint32, 1736, it> RESERVED_02;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    unsolicited_message_1& operator=(const unsolicited_message_1<ito>& o) {
        systime = o.systime;
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        utc_offset = o.utc_offset;
        type = o.type;
        intended_followup_actions = o.intended_followup_actions;
        id = o.id;
        for(unsigned n=0; n<128; ++n) message[n] = o.message[n];
        RESERVED_00 = o.RESERVED_00;
        for(unsigned n=0; n<64; ++n) RESERVED_01[n] = o.RESERVED_01[n];
        RESERVED_02 = o.RESERVED_02;
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct unsolicited_message_1<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef unsolicited_message_1<rebind_it> type;
    };

    enum { id_main = 41, id_sub = 1};

    uint32_t         systime;
    uint16_t         year;
    uint8_t          month;
    uint8_t          day;
    uint8_t          hour;
    uint8_t          minute;
    uint8_t          second;
    int8_t           utc_offset;
    uint8_t          type;
    uint32_t         intended_followup_actions;
    uint32_t         id;
    char             message[128];
    uint32_t         RESERVED_00;
    char             RESERVED_01[64];
    uint32_t         RESERVED_02;

    unsolicited_message_1()
        : systime()
        , year()
        , month()
        , day()
        , hour()
        , minute()
        , second()
        , utc_offset()
        , type()
        , intended_followup_actions()
        , id()
        , message()
        , RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
    {}

    template<class it>
    unsolicited_message_1(const unsolicited_message_1<it>& o) {
        systime = o.systime;
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        utc_offset = o.utc_offset;
        type = o.type;
        intended_followup_actions = o.intended_followup_actions;
        id = o.id;
        for(unsigned n=0; n<128; ++n) message[n] = o.message[n];
        RESERVED_00 = o.RESERVED_00;
        for(unsigned n=0; n<64; ++n) RESERVED_01[n] = o.RESERVED_01[n];
        RESERVED_02 = o.RESERVED_02;
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const unsolicited_message_1<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.year;
        s << ", " << x.month;
        s << ", " << x.day;
        s << ", " << x.hour;
        s << ", " << x.minute;
        s << ", " << x.second;
        s << ", " << x.utc_offset;
        s << ", " << x.type;
        s << ", " << x.intended_followup_actions;
        s << ", " << x.id;
        s << ", "; write_array(s, 128, x.message);
        s << ", " << x.RESERVED_00;
        s << ", "; write_array(s, 64, x.RESERVED_01);
        s << ", " << x.RESERVED_02;
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, unsolicited_message_1<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.year;
        s >> ',' >> x.month;
        s >> ',' >> x.day;
        s >> ',' >> x.hour;
        s >> ',' >> x.minute;
        s >> ',' >> x.second;
        s >> ',' >> x.utc_offset;
        s >> ',' >> x.type;
        s >> ',' >> x.intended_followup_actions;
        s >> ',' >> x.id;
        s >> ','; read_array(s, 128, x.message);
        s >> ',' >> x.RESERVED_00;
        s >> ','; read_array(s, 64, x.RESERVED_01);
        s >> ',' >> x.RESERVED_02;
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! spontaneous information and error messages

//! <para>This package belongs to the predefined selectors:</para>
//! <para>notify</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct unsolicited_message_2
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef unsolicited_message_2<rebind_it> type;
    };

    typedef it iterator_type;

    unsolicited_message_2(it begin, it end, bool dirty=false)
        : systime(begin)
        , year(begin)
        , month(begin)
        , day(begin)
        , hour(begin)
        , minute(begin)
        , second(begin)
        , utc_offset(begin)
        , type(begin)
        , intended_followup_actions(begin)
        , id(begin)
        , message(begin)
        , RESERVED_00(begin)
        , RESERVED_01(begin)
        , RESERVED_02(begin)
        , service_name(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 41, id_sub = 2};
    #ifndef DOXYGEN
    enum { max_bit_width = 2024};
    it begin() const { return systime.begin(); }
    it end() const { return service_name.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t systime;//!<  systime of message in units of uints.time_unit 
    #else
    binary::field<uint32_t, sc_uint32, 0, it> systime;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t year;//!<  year 
    #else
    binary::field<uint16_t, sc_uint16, 32, it> year;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t month;//!<  month  1 .. 12 
    #else
    binary::field<uint8_t, sc_uint8, 48, it> month;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t day;//!<  day    1 .. 31 
    #else
    binary::field<uint8_t, sc_uint8, 56, it> day;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t hour;//!<  hour   0 .. 23 
    #else
    binary::field<uint8_t, sc_uint8, 64, it> hour;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t minute;//!<  minute 0 .. 59 
    #else
    binary::field<uint8_t, sc_uint8, 72, it> minute;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t second;//!<  second 0 .. 59 (60 if leap second) 
    #else
    binary::field<uint8_t, sc_uint8, 80, it> second;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    int8_t utc_offset;//!<  diff. between localtime and UTC 
    #else
    binary::field<int8_t, sc_int8, 88, it> utc_offset;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t type;//!<  (INFO=1,WARNING=2,ERROR=3,FATAL=4) 
    #else
    binary::field<uint8_t, sc_uint8, 96, it> type;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t intended_followup_actions;//!<  bitmapped actions (1 .. shutting down laser power supply                     2 .. stopping current scan                     4 .. aborting current scan                     8 .. initiating shutdown                    16 .. normal operation initiated) 
    #else
    binary::field<uint32_t, sc_uint32, 104, it> intended_followup_actions;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t id;//!<  unique (error) number 
    #else
    binary::field<uint32_t, sc_uint32, 136, it> id;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char message[128];//!<  displayable user info 
    #else
    binary::array<char, 128, sc_char, 168, it> message;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_00;
    #else
    binary::field<uint32_t, sc_uint32, 1192, it> RESERVED_00;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char RESERVED_01[64];
    #else
    binary::array<char, 64, sc_char, 1224, it> RESERVED_01;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint32_t RESERVED_02;
    #else
    binary::field<uint32_t, sc_uint32, 1736, it> RESERVED_02;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    char service_name[32];
    #else
    binary::array<char, 32, sc_char, 1768, it> service_name;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    unsolicited_message_2& operator=(const unsolicited_message_2<ito>& o) {
        systime = o.systime;
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        utc_offset = o.utc_offset;
        type = o.type;
        intended_followup_actions = o.intended_followup_actions;
        id = o.id;
        for(unsigned n=0; n<128; ++n) message[n] = o.message[n];
        RESERVED_00 = o.RESERVED_00;
        for(unsigned n=0; n<64; ++n) RESERVED_01[n] = o.RESERVED_01[n];
        RESERVED_02 = o.RESERVED_02;
        for(unsigned n=0; n<32; ++n) service_name[n] = o.service_name[n];
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct unsolicited_message_2<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef unsolicited_message_2<rebind_it> type;
    };

    enum { id_main = 41, id_sub = 2};

    uint32_t         systime;
    uint16_t         year;
    uint8_t          month;
    uint8_t          day;
    uint8_t          hour;
    uint8_t          minute;
    uint8_t          second;
    int8_t           utc_offset;
    uint8_t          type;
    uint32_t         intended_followup_actions;
    uint32_t         id;
    char             message[128];
    uint32_t         RESERVED_00;
    char             RESERVED_01[64];
    uint32_t         RESERVED_02;
    char             service_name[32];

    unsolicited_message_2()
        : systime()
        , year()
        , month()
        , day()
        , hour()
        , minute()
        , second()
        , utc_offset()
        , type()
        , intended_followup_actions()
        , id()
        , message()
        , RESERVED_00()
        , RESERVED_01()
        , RESERVED_02()
        , service_name()
    {}

    template<class it>
    unsolicited_message_2(const unsolicited_message_2<it>& o) {
        systime = o.systime;
        year = o.year;
        month = o.month;
        day = o.day;
        hour = o.hour;
        minute = o.minute;
        second = o.second;
        utc_offset = o.utc_offset;
        type = o.type;
        intended_followup_actions = o.intended_followup_actions;
        id = o.id;
        for(unsigned n=0; n<128; ++n) message[n] = o.message[n];
        RESERVED_00 = o.RESERVED_00;
        for(unsigned n=0; n<64; ++n) RESERVED_01[n] = o.RESERVED_01[n];
        RESERVED_02 = o.RESERVED_02;
        for(unsigned n=0; n<32; ++n) service_name[n] = o.service_name[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const unsolicited_message_2<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.systime;
        s << ", " << x.year;
        s << ", " << x.month;
        s << ", " << x.day;
        s << ", " << x.hour;
        s << ", " << x.minute;
        s << ", " << x.second;
        s << ", " << x.utc_offset;
        s << ", " << x.type;
        s << ", " << x.intended_followup_actions;
        s << ", " << x.id;
        s << ", "; write_array(s, 128, x.message);
        s << ", " << x.RESERVED_00;
        s << ", "; write_array(s, 64, x.RESERVED_01);
        s << ", " << x.RESERVED_02;
        s << ", "; write_array(s, 32, x.service_name);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, unsolicited_message_2<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.systime;
        s >> ',' >> x.year;
        s >> ',' >> x.month;
        s >> ',' >> x.day;
        s >> ',' >> x.hour;
        s >> ',' >> x.minute;
        s >> ',' >> x.second;
        s >> ',' >> x.utc_offset;
        s >> ',' >> x.type;
        s >> ',' >> x.intended_followup_actions;
        s >> ',' >> x.id;
        s >> ','; read_array(s, 128, x.message);
        s >> ',' >> x.RESERVED_00;
        s >> ','; read_array(s, 64, x.RESERVED_01);
        s >> ',' >> x.RESERVED_02;
        s >> ','; read_array(s, 32, x.service_name);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct versions
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef versions<rebind_it> type;
    };

    typedef it iterator_type;

    versions(it begin, it end, bool dirty=false)
        : key(begin)
        , value(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 103, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 768};
    it begin() const { return key.begin(); }
    it end() const { return value.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t key[32];
    #else
    binary::array<uint8_t, 32, sc_uint8, 0, it> key;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t value[64];
    #else
    binary::array<uint8_t, 64, sc_uint8, 256, it> value;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    versions& operator=(const versions<ito>& o) {
        for(unsigned n=0; n<32; ++n) key[n] = o.key[n];
        for(unsigned n=0; n<64; ++n) value[n] = o.value[n];
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct versions<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef versions<rebind_it> type;
    };

    enum { id_main = 103, id_sub = 0};

    uint8_t          key[32];
    uint8_t          value[64];

    versions()
        : key()
        , value()
    {}

    template<class it>
    versions(const versions<it>& o) {
        for(unsigned n=0; n<32; ++n) key[n] = o.key[n];
        for(unsigned n=0; n<64; ++n) value[n] = o.value[n];
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const versions<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", "; write_array(s, 32, x.key);
        s << ", "; write_array(s, 64, x.value);
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, versions<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ','; read_array(s, 32, x.key);
        s >> ','; read_array(s, 64, x.value);
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! empty helper package

//! This package is used for data alignment purposes.
//! <para>This package belongs to the predefined selectors:</para>
//! <para>protocol</para>
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct void_data
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef void_data<rebind_it> type;
    };

    typedef it iterator_type;

    void_data(it begin, it end, bool dirty=false)
        : end_(begin)
    {}
    #endif //DOXYGEN

    enum { id_main = 65535, id_sub = 65535};
    #ifndef DOXYGEN
    enum { max_bit_width = 0};
    it begin() const { return end_; }
    it end() const { return end_; }

    it end_;
    #endif //DOXYGEN
    #ifndef DOXYGEN

    template<class ito>
    void_data& operator=(const void_data<ito>& o) {
        return *this;
    }
    #endif //DOXYGEN
};
#ifndef DOXYGEN
template<>
struct void_data<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef void_data<rebind_it> type;
    };

    enum { id_main = 65535, id_sub = 65535};


    void_data()
    {}

    template<class it>
    void_data(const void_data<it>& o) {
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const void_data<it>& x) {
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, void_data<it>& x) {
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct wfm_dg_hp
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef wfm_dg_hp<rebind_it> type;
    };

    typedef it iterator_type;

    wfm_dg_hp(it begin, it end, bool dirty=false)
        : cnt_ls(begin)
        , mean(begin)
        , stddev(begin)
        , rnggt_start(begin)
        , rnggt_stop(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50002, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 131168};
    it begin() const { return cnt_ls.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_ls;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> cnt_ls;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t mean;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> mean;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t stddev;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> stddev;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t rnggt_start;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> rnggt_start;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t rnggt_stop;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> rnggt_stop;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 8192 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sample(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t sample;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> sample;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[8192];
    #else
    sequence<wfm_dg_hp, 16, 96, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    wfm_dg_hp& operator=(const wfm_dg_hp<ito>& o) {
        cnt_ls = o.cnt_ls;
        mean = o.mean;
        stddev = o.stddev;
        rnggt_start = o.rnggt_start;
        rnggt_stop = o.rnggt_stop;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct wfm_dg_hp<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef wfm_dg_hp<rebind_it> type;
    };

    enum { id_main = 50002, id_sub = 0};

    uint8_t          cnt_ls;
    uint16_t         mean;
    uint16_t         stddev;
    uint16_t         rnggt_start;
    uint16_t         rnggt_stop;
    std::size_t data_size;
    enum { data_max_size = 8192 };
    struct sequence_definition {
        uint16_t         sample;
    } data[8192];

    wfm_dg_hp()
        : cnt_ls()
        , mean()
        , stddev()
        , rnggt_start()
        , rnggt_stop()
    {}

    template<class it>
    wfm_dg_hp(const wfm_dg_hp<it>& o) {
        cnt_ls = o.cnt_ls;
        mean = o.mean;
        stddev = o.stddev;
        rnggt_start = o.rnggt_start;
        rnggt_stop = o.rnggt_stop;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const wfm_dg_hp<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.cnt_ls;
        s << ", " << x.mean;
        s << ", " << x.stddev;
        s << ", " << x.rnggt_start;
        s << ", " << x.rnggt_stop;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sample
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, wfm_dg_hp<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.cnt_ls;
        s >> ',' >> x.mean;
        s >> ',' >> x.stddev;
        s >> ',' >> x.rnggt_start;
        s >> ',' >> x.rnggt_stop;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sample)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct wfm_dg_lp
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef wfm_dg_lp<rebind_it> type;
    };

    typedef it iterator_type;

    wfm_dg_lp(it begin, it end, bool dirty=false)
        : cnt_ls(begin)
        , mean(begin)
        , stddev(begin)
        , rnggt_start(begin)
        , rnggt_stop(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50003, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 131168};
    it begin() const { return cnt_ls.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_ls;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> cnt_ls;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t mean;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> mean;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t stddev;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> stddev;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t rnggt_start;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> rnggt_start;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t rnggt_stop;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> rnggt_stop;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 8192 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sample(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t sample;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> sample;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[8192];
    #else
    sequence<wfm_dg_lp, 16, 96, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    wfm_dg_lp& operator=(const wfm_dg_lp<ito>& o) {
        cnt_ls = o.cnt_ls;
        mean = o.mean;
        stddev = o.stddev;
        rnggt_start = o.rnggt_start;
        rnggt_stop = o.rnggt_stop;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct wfm_dg_lp<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef wfm_dg_lp<rebind_it> type;
    };

    enum { id_main = 50003, id_sub = 0};

    uint8_t          cnt_ls;
    uint16_t         mean;
    uint16_t         stddev;
    uint16_t         rnggt_start;
    uint16_t         rnggt_stop;
    std::size_t data_size;
    enum { data_max_size = 8192 };
    struct sequence_definition {
        uint16_t         sample;
    } data[8192];

    wfm_dg_lp()
        : cnt_ls()
        , mean()
        , stddev()
        , rnggt_start()
        , rnggt_stop()
    {}

    template<class it>
    wfm_dg_lp(const wfm_dg_lp<it>& o) {
        cnt_ls = o.cnt_ls;
        mean = o.mean;
        stddev = o.stddev;
        rnggt_start = o.rnggt_start;
        rnggt_stop = o.rnggt_stop;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const wfm_dg_lp<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.cnt_ls;
        s << ", " << x.mean;
        s << ", " << x.stddev;
        s << ", " << x.rnggt_start;
        s << ", " << x.rnggt_stop;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sample
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, wfm_dg_lp<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.cnt_ls;
        s >> ',' >> x.mean;
        s >> ',' >> x.stddev;
        s >> ',' >> x.rnggt_start;
        s >> ',' >> x.rnggt_stop;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sample)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
#ifdef DOXYGEN
template<class it>
#else
template<class it = void>
#endif
struct wfm_dg_shp
{
    #ifndef DOXYGEN
    template<class rebind_it = void>
    struct rebind {
        typedef wfm_dg_shp<rebind_it> type;
    };

    typedef it iterator_type;

    wfm_dg_shp(it begin, it end, bool dirty=false)
        : cnt_ls(begin)
        , phase(begin)
        , mean(begin)
        , stddev(begin)
        , rnggt_start(begin)
        , num_samples(begin)
        , data(begin, end, data_size, dirty)
    {}
    #endif //DOXYGEN

    enum { id_main = 50004, id_sub = 0};
    #ifndef DOXYGEN
    enum { max_bit_width = 131168};
    it begin() const { return cnt_ls.begin(); }
    it end() const { return data.end(); }

    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t cnt_ls;
    #else
    binary::field<uint8_t, sc_uint8, 0, it> cnt_ls;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint8_t phase;
    #else
    binary::field<uint8_t, sc_uint8, 8, it> phase;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t mean;
    #else
    binary::field<uint16_t, sc_uint16, 32, it> mean;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t stddev;
    #else
    binary::field<uint16_t, sc_uint16, 48, it> stddev;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t rnggt_start;
    #else
    binary::field<uint16_t, sc_uint16, 64, it> rnggt_start;
    #endif //DOXYGEN
    #ifdef DOXYGEN
    uint16_t num_samples;
    #else
    binary::field<uint16_t, sc_uint16, 80, it> num_samples;
    #endif //DOXYGEN

    std::size_t data_size;
    enum { data_max_size = 8192 };
    struct sequence_definition
    {
        #ifndef DOXYGEN
        sequence_definition(it begin, unsigned begin_bit)
            : sample(begin, begin_bit)
        {}
        #endif //DOXYGEN

        #ifdef DOXYGEN
        uint16_t sample;
        #else
        binary::field<uint16_t, sc_uint16, 0, it> sample;
        #endif
    };
    #ifdef DOXYGEN
    sequence_definition data[8192];
    #else
    sequence<wfm_dg_shp, 16, 96, it> data;
    #endif
    #ifndef DOXYGEN

    template<class ito>
    wfm_dg_shp& operator=(const wfm_dg_shp<ito>& o) {
        cnt_ls = o.cnt_ls;
        phase = o.phase;
        mean = o.mean;
        stddev = o.stddev;
        rnggt_start = o.rnggt_start;
        num_samples = o.num_samples;
        data_size = o.data_size;
        data.clean();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
        return *this;
    }
    #endif //DOXYGEN
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<>
struct wfm_dg_shp<void>
{
    template<class rebind_it = void>
    struct rebind {
        typedef wfm_dg_shp<rebind_it> type;
    };

    enum { id_main = 50004, id_sub = 0};

    uint8_t          cnt_ls;
    uint8_t          phase;
    uint16_t         mean;
    uint16_t         stddev;
    uint16_t         rnggt_start;
    uint16_t         num_samples;
    std::size_t data_size;
    enum { data_max_size = 8192 };
    struct sequence_definition {
        uint16_t         sample;
    } data[8192];

    wfm_dg_shp()
        : cnt_ls()
        , phase()
        , mean()
        , stddev()
        , rnggt_start()
        , num_samples()
    {}

    template<class it>
    wfm_dg_shp(const wfm_dg_shp<it>& o) {
        cnt_ls = o.cnt_ls;
        phase = o.phase;
        mean = o.mean;
        stddev = o.stddev;
        rnggt_start = o.rnggt_start;
        num_samples = o.num_samples;
        data_size = o.data.size();
        for(unsigned n=0; n<data_size; ++n){
            data[n].sample = o.data[n].sample;
        }
    }
};
#endif //DOXYGEN
#ifndef DOXYGEN
template<class it>
std::ostream& operator<<(std::ostream& s, const wfm_dg_shp<it>& x) {
    package_ostream_entry ok(s);
    if (ok) {
        s << ", " << x.cnt_ls;
        s << ", " << x.phase;
        s << ", " << x.mean;
        s << ", " << x.stddev;
        s << ", " << x.rnggt_start;
        s << ", " << x.num_samples;

        s << ", "; if (!is_rxp_braceless(s)) s << "[";
        for (std::size_t n=0; n<x.data_size; ++n) {
            if (n>0) {s << ", ";} if (!is_rxp_braceless(s)) {s << "{";}
            s
            << "" << x.data[n].sample
            ; if (!is_rxp_braceless(s)) s << "}";
        }
        if (!is_rxp_braceless(s)) s << "]";
    }
    return s;
}

template<class it>
std::istream& operator>>(std::istream& s, wfm_dg_shp<it>& x) {
    package_istream_entry ok(s);
    if (ok) {
        s >> ',' >> x.cnt_ls;
        s >> ',' >> x.phase;
        s >> ',' >> x.mean;
        s >> ',' >> x.stddev;
        s >> ',' >> x.rnggt_start;
        s >> ',' >> x.num_samples;

        if(!is_rxp_braceless(s)) {s >> ','; s >> '['; s >> std::ws; }
        x.data_size = 0;
        while(s.good() && (s.peek() == ',' || s.peek() == '{')) {
            ++x.data_size;
            if (!is_rxp_braceless(s)) {s >> '{';} else {s >> ',';}
            s      >> (x.data[x.data_size-1].sample)
            ;
            if (!is_rxp_braceless(s)) {
                s >> '}';
                if (s.peek() == ',') s.ignore(1);
                s >> std::ws;
            }
        }
        if (!is_rxp_braceless(s)) {s >> ']';}
    }
    return s;
}
#endif //DOXYGEN
//-----------------------------------------------------------------------------
//! The base for packet dispatcher classes.
//
//! An instance of this class implements package dispatching.
//! Raw packages are fed to the class via the dispatch member function.
//! The raw package will be decoded and a virtual function corresponding
//! to its type will be called. The overloaded function will receive the
//! decoded package as a paramter. Each packet has several fields which
//! are separately documented. The actual implementation of packets differs
//! from how they appear in the documentation. Instead of the shown packets
//! the handler funtions receive a proxy of the packet, that acts as if it
//! was the real packet. This means that one can use the various fields in
//! read (and write, where apropriate) expressions, but one cannot e.g. take
//! the address of a field or make a reference to it. If you need to know the
//! real implementation, please look at the source code.
//!
//! The "it" template paramater specifies an iterator to a raw package,
//! which in principle can be a random access pointer to unsigned of various
//! bitsizes. In practice the iterator always shall be taken from the one
//! defined in the buffer class.
//!
//! Package dispatching can be fine controlled by setting the selector, which
//! is a bitset, indexed by the package id. The package id to use for indexing
//! is one of the enum values defined in struct package_id. A couple of predefined
//! sets are available. Please note, that while it is possible to create arbitrary
//! selector combinations, care should be taken to always include the mandatory
//! header packet.
//!
class basic_packets
{
public:
    typedef decoder_rxpmarker::const_iterator iterator_type; //!< embedded iterator type definition
    selector_type selector; //!< package dispatch selection

    basic_packets()
        : selector(select_all)
        , sequel(0)
        , package_probes(false)
        , dispatch_end_requested(false)
    {}
    virtual ~basic_packets()
    {}

    //! dispatch a raw packet
    //
    //! This function invokes the dispatch process. It is fed with a buffer taken from
    //! the decoder_rxpmarker. The dispatcher first infers the type of the raw packet from
    //! its embeded id and a lookup table which has been provided from the instrument in the
    //! header packet. Then the dispatcher uses the major and minor packet id numbers to
    //! map the packet to a handler function. A received packet with a higher minor number
    //! is compatible to any packet of the same major but smaller minor number. The dispatcher
    //! will use such packets in place of these smaller numbered packets.
    //!
    //! The dispatching process is subject to a selector filter which has a flag for each
    //! packet.
    bool dispatch(const iterator_type& begin, const iterator_type& end);

protected:

    virtual bool on_dispatch(const iterator_type& begin, const iterator_type& end);
    virtual void on_id(const package_id& arg, const basic_package<iterator_type>& pkg);
    //!\param arg  IMU raw data
    virtual void on_IMU_data(const IMU_data<iterator_type>& arg);
    //!\param arg  specifies the sensitive axes of the sensors at frame_angle = 0
    virtual void on_S10DOF_calib(const S10DOF_calib<iterator_type>& arg);
    //!\param arg  specifies the sensitive axes of the sensors at frame_angle = 0
    virtual void on_S10DOF_calib_1(const S10DOF_calib_1<iterator_type>& arg);
    //!\param arg  raw data of 10 deg of freedom sensors
    virtual void on_S10DOF_data(const S10DOF_data<iterator_type>& arg);
    //!\param arg  raw data of 10 deg of freedom sensors
    virtual void on_S10DOF_data_1(const S10DOF_data_1<iterator_type>& arg);
    //!\param arg  specifies the units for the package S10DOF_data
    virtual void on_S10DOF_units(const S10DOF_units<iterator_type>& arg);
    //!\param arg  environmental information
    virtual void on_atmosphere(const atmosphere<iterator_type>& arg);
    //!\param arg  extended environmental information
    virtual void on_atmosphere_1(const atmosphere_1<iterator_type>& arg);
    //!\param arg  extended environmental information
    virtual void on_atmosphere_2(const atmosphere_2<iterator_type>& arg);
    //!\param arg  extended environmental information
    virtual void on_atmosphere_3(const atmosphere_3<iterator_type>& arg);
    //!\param arg  extended environmental information
    virtual void on_atmosphere_4(const atmosphere_4<iterator_type>& arg);
    //!\param arg  laser beam description
    virtual void on_beam_geometry(const beam_geometry<iterator_type>& arg);
    //!\param arg  modelling biaxial shift of cog of range measurement in the near range
    virtual void on_biaxial_geometry(const biaxial_geometry<iterator_type>& arg);
    //!\param arg  external synchronization input
    virtual void on_counter_sync(const counter_sync<iterator_type>& arg);
    //!\param arg  external synchronization input
    virtual void on_counter_sync_2angles_hr(const counter_sync_2angles_hr<iterator_type>& arg);
    //!\param arg  geometrical parameters of external devices
    virtual void on_device_mounting(const device_mounting<iterator_type>& arg);
    //!\param arg  extents of various data fields
    virtual void on_extents(const extents<iterator_type>& arg);
    //!\param arg  extents of various data fields
    virtual void on_extents_1(const extents_1<iterator_type>& arg);
    //!\param arg  start of a scan frame in down direction.
    virtual void on_frame_start_dn(const frame_start_dn<iterator_type>& arg);
    //!\param arg  Start of a scan frame in up direction.
    virtual void on_frame_start_up(const frame_start_up<iterator_type>& arg);
    //!\param arg  end of a scan frame
    virtual void on_frame_stop(const frame_stop<iterator_type>& arg);
    //!\param arg  gravity information  in SOCS
    virtual void on_gravity_socs(const gravity_socs<iterator_type>& arg);
    //!\param arg  The mandatory header package.
    virtual void on_header(const header<iterator_type>& arg);
    //!\param arg  Extension header
    virtual void on_header_ext(const header_ext<iterator_type>& arg);
    //!\param arg  power supply unit (24 Bytes)
    virtual void on_hk_bat(const hk_bat<iterator_type>& arg);
    //!\param arg  power supply unit (24 Bytes)
    virtual void on_hk_bat_1(const hk_bat_1<iterator_type>& arg);
    //!\param arg  power supply unit (24 Bytes)
    virtual void on_hk_bat_2(const hk_bat_2<iterator_type>& arg);
    //!\param arg  control unit, i.e., mother board, including storage levels, info on attached equipment (60 Bytes)
    virtual void on_hk_ctr(const hk_ctr<iterator_type>& arg);
    //!\param arg  control unit, i.e., mother board, including storage levels, info on attached equipment (60 Bytes)
    virtual void on_hk_ctr_1(const hk_ctr_1<iterator_type>& arg);
    //!\param arg  GPS data
    virtual void on_hk_gps(const hk_gps<iterator_type>& arg);
    //!\param arg  GPS data
    virtual void on_hk_gps_hr(const hk_gps_hr<iterator_type>& arg);
    //!\param arg  GPS data
    virtual void on_hk_gps_ts(const hk_gps_ts<iterator_type>& arg);
    //!\param arg  GPS data
    virtual void on_hk_gps_ts_status(const hk_gps_ts_status<iterator_type>& arg);
    //!\param arg  GPS data
    virtual void on_hk_gps_ts_status_dop(const hk_gps_ts_status_dop<iterator_type>& arg);
    //!\param arg  GPS data
    virtual void on_hk_gps_ts_status_dop_ucs(const hk_gps_ts_status_dop_ucs<iterator_type>& arg);
    //!\param arg  inclination sensor
    virtual void on_hk_incl(const hk_incl<iterator_type>& arg);
    //!\param arg  inclination sensor
    virtual void on_hk_incl_4axes(const hk_incl_4axes<iterator_type>& arg);
    //!\param arg  protective housing data
    virtual void on_hk_ph_data(const hk_ph_data<iterator_type>& arg);
    //!\param arg  protective housing data
    virtual void on_hk_ph_data_1(const hk_ph_data_1<iterator_type>& arg);
    //!\param arg  protective housing units
    virtual void on_hk_ph_units(const hk_ph_units<iterator_type>& arg);
    //!\param arg  protective housing units
    virtual void on_hk_ph_units_1(const hk_ph_units_1<iterator_type>& arg);
    //!\param arg  power supply unit (24 Bytes)
    virtual void on_hk_pwr(const hk_pwr<iterator_type>& arg);
    //!\param arg  power supply unit (24 Bytes)
    virtual void on_hk_pwr_1(const hk_pwr_1<iterator_type>& arg);
    //!\param arg  built in real time clock of scanning device, local time
    virtual void on_hk_rtc(const hk_rtc<iterator_type>& arg);
    //!\param arg  real time clock, local time (10 Bytes)
    virtual void on_hk_rtc_sys(const hk_rtc_sys<iterator_type>& arg);
    //!\param arg  static inclination sensor
    virtual void on_inclination_static(const inclination_static<iterator_type>& arg);
    //!\param arg  start of a line scan in down direction
    virtual void on_line_start_dn(const line_start_dn<iterator_type>& arg);
    //!\param arg  start of the 1 segment of a scan line
    virtual void on_line_start_segment_1(const line_start_segment_1<iterator_type>& arg);
    //!\param arg  start of the 2 segment of a scan line
    virtual void on_line_start_segment_2(const line_start_segment_2<iterator_type>& arg);
    //!\param arg  start of the 3 segment of a scan line
    virtual void on_line_start_segment_3(const line_start_segment_3<iterator_type>& arg);
    //!\param arg  start of a line scan in up direction
    virtual void on_line_start_up(const line_start_up<iterator_type>& arg);
    //!\param arg  end of line scan
    virtual void on_line_stop(const line_stop<iterator_type>& arg);
    //!\param arg  measurement has started
    virtual void on_meas_start(const meas_start<iterator_type>& arg);
    //!\param arg  measurement has stopped
    virtual void on_meas_stop(const meas_stop<iterator_type>& arg);
    //!\param arg  current setting of subdivider for monitoring data stream
    virtual void on_monitoring_info(const monitoring_info<iterator_type>& arg);
    //!\param arg  default parameters for MTA processing
    virtual void on_mta_settings(const mta_settings<iterator_type>& arg);
    //!\param arg  default parameters for MTA processing
    virtual void on_mta_settings_1(const mta_settings_1<iterator_type>& arg);
    //!\param arg  default parameters for MTA processing
    virtual void on_mta_settings_2(const mta_settings_2<iterator_type>& arg);
    //!\param arg  default parameters for MTA processing
    virtual void on_mta_settings_3(const mta_settings_3<iterator_type>& arg);
    //!\param arg  pulse per second, external time synchronisation
    virtual void on_pps_sync(const pps_sync<iterator_type>& arg);
    //!\param arg  pulse per second, external time synchronisation
    virtual void on_pps_sync_ext(const pps_sync_ext<iterator_type>& arg);
    //!\param arg  pulse per second, external time synchronisation
    virtual void on_pps_sync_hr(const pps_sync_hr<iterator_type>& arg);
    //!\param arg  pulse per second, external time synchronisation
    virtual void on_pps_sync_hr_ext(const pps_sync_hr_ext<iterator_type>& arg);
    //!\param arg  external pwm signal input
    virtual void on_pwm_sync(const pwm_sync<iterator_type>& arg);
    //!\param arg  description of receiver
    virtual void on_receiver_geometry(const receiver_geometry<iterator_type>& arg);
    //!\param arg  scan pattern description
    virtual void on_scan_rect_fov(const scan_rect_fov<iterator_type>& arg);
    //!\param arg  scan pattern description
    virtual void on_scan_rect_fov_1(const scan_rect_fov_1<iterator_type>& arg);
    //!\param arg  scan pattern description
    virtual void on_scan_segments_fov(const scan_segments_fov<iterator_type>& arg);
    //!\param arg  scan pattern for mirror less scanners, e.g BDF
    virtual void on_scan_trail_fov(const scan_trail_fov<iterator_type>& arg);
    //!\param arg  scanner pose (position and orientation
    virtual void on_scanner_pose(const scanner_pose<iterator_type>& arg);
    //!\param arg  scanner pose (position and orientation
    virtual void on_scanner_pose_hr(const scanner_pose_hr<iterator_type>& arg);
    //!\param arg  scanner pose (position and orientation
    virtual void on_scanner_pose_hr_1(const scanner_pose_hr_1<iterator_type>& arg);
    //!\param arg  scanner pose in user coordinate system (ucs);
    virtual void on_scanner_pose_ucs(const scanner_pose_ucs<iterator_type>& arg);
    //!\param arg  scanner pose in user coordinate system (ucs);
    virtual void on_scanner_pose_ucs_1(const scanner_pose_ucs_1<iterator_type>& arg);
    //!\param arg  units information
    virtual void on_units(const units<iterator_type>& arg);
    //!\param arg  units information
    virtual void on_units_1(const units_1<iterator_type>& arg);
    //!\param arg  units information
    virtual void on_units_2(const units_2<iterator_type>& arg);
    //!\param arg  units information
    virtual void on_units_3(const units_3<iterator_type>& arg);
    //!\param arg  units information
    virtual void on_units_4(const units_4<iterator_type>& arg);
    //!\param arg  units information
    virtual void on_units_IMU(const units_IMU<iterator_type>& arg);
    //!\param arg  spontaneous information and error messages
    virtual void on_unsolicited_message(const unsolicited_message<iterator_type>& arg);
    //!\param arg  spontaneous information and error messages
    virtual void on_unsolicited_message_1(const unsolicited_message_1<iterator_type>& arg);
    //!\param arg  spontaneous information and error messages
    virtual void on_unsolicited_message_2(const unsolicited_message_2<iterator_type>& arg);
    //!\param arg  empty helper package
    virtual void on_void_data(const void_data<iterator_type>& arg);
    #ifndef DOXYGEN
    virtual void on_alert(const alert<iterator_type>& arg);
    virtual void on_arange_table(const arange_table<iterator_type>& arg);
    virtual void on_avg_fine_ref_dg(const avg_fine_ref_dg<iterator_type>& arg);
    virtual void on_blob_uint32(const blob_uint32<iterator_type>& arg);
    virtual void on_blob_uint8(const blob_uint8<iterator_type>& arg);
    virtual void on_calib_2D_table(const calib_2D_table<iterator_type>& arg);
    virtual void on_calib_table(const calib_table<iterator_type>& arg);
    virtual void on_calib_waveform(const calib_waveform<iterator_type>& arg);
    virtual void on_calib_waveform_1(const calib_waveform_1<iterator_type>& arg);
    virtual void on_calib_waveform_L2(const calib_waveform_L2<iterator_type>& arg);
    virtual void on_calib_waveform_L2_1(const calib_waveform_L2_1<iterator_type>& arg);
    virtual void on_calib_wfm_sbl_header(const calib_wfm_sbl_header<iterator_type>& arg);
    virtual void on_cc_slice(const cc_slice<iterator_type>& arg);
    virtual void on_channel_combination_table(const channel_combination_table<iterator_type>& arg);
    virtual void on_context_end(const context_end<iterator_type>& arg);
    virtual void on_crc32_check(const crc32_check<iterator_type>& arg);
    virtual void on_crc32_header(const crc32_header<iterator_type>& arg);
    virtual void on_cs_trans(const cs_trans<iterator_type>& arg);
    virtual void on_datagram_separator(const datagram_separator<iterator_type>& arg);
    virtual void on_debug_hw_dg(const debug_hw_dg<iterator_type>& arg);
    virtual void on_debug_sw_dg(const debug_sw_dg<iterator_type>& arg);
    virtual void on_device_geometry(const device_geometry<iterator_type>& arg);
    virtual void on_device_geometry_1(const device_geometry_1<iterator_type>& arg);
    virtual void on_device_geometry_2(const device_geometry_2<iterator_type>& arg);
    virtual void on_device_geometry_3(const device_geometry_3<iterator_type>& arg);
    virtual void on_device_geometry_4(const device_geometry_4<iterator_type>& arg);
    virtual void on_device_geometry_5(const device_geometry_5<iterator_type>& arg);
    virtual void on_device_geometry_6(const device_geometry_6<iterator_type>& arg);
    virtual void on_device_geometry_7(const device_geometry_7<iterator_type>& arg);
    virtual void on_device_geometry_passive_channel(const device_geometry_passive_channel<iterator_type>& arg);
    virtual void on_dyntrig(const dyntrig<iterator_type>& arg);
    virtual void on_echo(const echo<iterator_type>& arg);
    virtual void on_echo_1(const echo_1<iterator_type>& arg);
    virtual void on_external_gnss_cfg(const external_gnss_cfg<iterator_type>& arg);
    virtual void on_external_gnss_cfg_ext(const external_gnss_cfg_ext<iterator_type>& arg);
    virtual void on_firmware(const firmware<iterator_type>& arg);
    virtual void on_firmware_1(const firmware_1<iterator_type>& arg);
    virtual void on_firmware_2(const firmware_2<iterator_type>& arg);
    virtual void on_firmware_3(const firmware_3<iterator_type>& arg);
    virtual void on_fp_samples(const fp_samples<iterator_type>& arg);
    virtual void on_fp_table(const fp_table<iterator_type>& arg);
    virtual void on_fp_trace2ampl(const fp_trace2ampl<iterator_type>& arg);
    virtual void on_fp_wghts(const fp_wghts<iterator_type>& arg);
    virtual void on_frame_start(const frame_start<iterator_type>& arg);
    virtual void on_generic_end(const generic_end<iterator_type>& arg);
    virtual void on_header_device(const header_device<iterator_type>& arg);
    virtual void on_hk_cam(const hk_cam<iterator_type>& arg);
    virtual void on_hk_extended_external(const hk_extended_external<iterator_type>& arg);
    virtual void on_hk_extended_internal(const hk_extended_internal<iterator_type>& arg);
    virtual void on_hk_float64_param(const hk_float64_param<iterator_type>& arg);
    virtual void on_hk_float_param(const hk_float_param<iterator_type>& arg);
    virtual void on_hk_group_header(const hk_group_header<iterator_type>& arg);
    virtual void on_hk_monitor(const hk_monitor<iterator_type>& arg);
    virtual void on_hk_param_header(const hk_param_header<iterator_type>& arg);
    virtual void on_hk_param_header_1(const hk_param_header_1<iterator_type>& arg);
    virtual void on_hk_rad(const hk_rad<iterator_type>& arg);
    virtual void on_hk_rng(const hk_rng<iterator_type>& arg);
    virtual void on_hk_rng_1(const hk_rng_1<iterator_type>& arg);
    virtual void on_hk_rng_2(const hk_rng_2<iterator_type>& arg);
    virtual void on_hk_rng_3(const hk_rng_3<iterator_type>& arg);
    virtual void on_hk_rng_4(const hk_rng_4<iterator_type>& arg);
    virtual void on_hk_rng_5(const hk_rng_5<iterator_type>& arg);
    virtual void on_hk_rng_6(const hk_rng_6<iterator_type>& arg);
    virtual void on_hk_rng_7(const hk_rng_7<iterator_type>& arg);
    virtual void on_hk_rng_8(const hk_rng_8<iterator_type>& arg);
    virtual void on_hk_rng_9(const hk_rng_9<iterator_type>& arg);
    virtual void on_hk_rngx(const hk_rngx<iterator_type>& arg);
    virtual void on_hk_scn(const hk_scn<iterator_type>& arg);
    virtual void on_hk_scn_1(const hk_scn_1<iterator_type>& arg);
    virtual void on_hk_scn_2(const hk_scn_2<iterator_type>& arg);
    virtual void on_hk_string_param(const hk_string_param<iterator_type>& arg);
    virtual void on_hk_time(const hk_time<iterator_type>& arg);
    virtual void on_hk_uint64_param(const hk_uint64_param<iterator_type>& arg);
    virtual void on_ht_dbg_data(const ht_dbg_data<iterator_type>& arg);
    virtual void on_inclination(const inclination<iterator_type>& arg);
    virtual void on_inclination_4axes(const inclination_4axes<iterator_type>& arg);
    virtual void on_inclination_device(const inclination_device<iterator_type>& arg);
    virtual void on_inclination_device_4axes(const inclination_device_4axes<iterator_type>& arg);
    virtual void on_inclination_device_4axes_offset(const inclination_device_4axes_offset<iterator_type>& arg);
    virtual void on_laser_echo(const laser_echo<iterator_type>& arg);
    virtual void on_laser_echo_qual(const laser_echo_qual<iterator_type>& arg);
    virtual void on_laser_echo_sw(const laser_echo_sw<iterator_type>& arg);
    virtual void on_laser_shot(const laser_shot<iterator_type>& arg);
    virtual void on_laser_shot_1angle(const laser_shot_1angle<iterator_type>& arg);
    virtual void on_laser_shot_2angles(const laser_shot_2angles<iterator_type>& arg);
    virtual void on_laser_shot_2angles_hr(const laser_shot_2angles_hr<iterator_type>& arg);
    virtual void on_laser_shot_2angles_rad(const laser_shot_2angles_rad<iterator_type>& arg);
    virtual void on_laser_shot_3angles(const laser_shot_3angles<iterator_type>& arg);
    virtual void on_laser_shot_6angles(const laser_shot_6angles<iterator_type>& arg);
    virtual void on_laser_shot_6angles_hr(const laser_shot_6angles_hr<iterator_type>& arg);
    virtual void on_laser_shot_rad(const laser_shot_rad<iterator_type>& arg);
    virtual void on_laser_shot_utctime_origin_direction(const laser_shot_utctime_origin_direction<iterator_type>& arg);
    virtual void on_line_start(const line_start<iterator_type>& arg);
    virtual void on_m_sequence_mta(const m_sequence_mta<iterator_type>& arg);
    virtual void on_magnetic_field(const magnetic_field<iterator_type>& arg);
    virtual void on_notch_filter(const notch_filter<iterator_type>& arg);
    virtual void on_notch_filter_modification_parameters(const notch_filter_modification_parameters<iterator_type>& arg);
    virtual void on_nrange_table(const nrange_table<iterator_type>& arg);
    virtual void on_operating_time(const operating_time<iterator_type>& arg);
    virtual void on_packed_frame_echo(const packed_frame_echo<iterator_type>& arg);
    virtual void on_packed_frame_echo_hr(const packed_frame_echo_hr<iterator_type>& arg);
    virtual void on_packed_frame_echo_hr_1(const packed_frame_echo_hr_1<iterator_type>& arg);
    virtual void on_packed_frame_laser_shot_2angles(const packed_frame_laser_shot_2angles<iterator_type>& arg);
    virtual void on_packed_frame_laser_shot_2angles_hr(const packed_frame_laser_shot_2angles_hr<iterator_type>& arg);
    virtual void on_packed_frame_laser_shot_2angles_rad(const packed_frame_laser_shot_2angles_rad<iterator_type>& arg);
    virtual void on_packed_key_echo(const packed_key_echo<iterator_type>& arg);
    virtual void on_packed_key_echo_hr(const packed_key_echo_hr<iterator_type>& arg);
    virtual void on_packed_key_echo_hr_1(const packed_key_echo_hr_1<iterator_type>& arg);
    virtual void on_packed_key_laser_shot_2angles(const packed_key_laser_shot_2angles<iterator_type>& arg);
    virtual void on_packed_key_laser_shot_2angles_hr(const packed_key_laser_shot_2angles_hr<iterator_type>& arg);
    virtual void on_packed_key_laser_shot_2angles_hr_mta(const packed_key_laser_shot_2angles_hr_mta<iterator_type>& arg);
    virtual void on_packed_key_laser_shot_2angles_rad(const packed_key_laser_shot_2angles_rad<iterator_type>& arg);
    virtual void on_packed_sdf(const packed_sdf<iterator_type>& arg);
    virtual void on_packed_shot_echos_hr(const packed_shot_echos_hr<iterator_type>& arg);
    virtual void on_packed_shot_echos_sbl_hr(const packed_shot_echos_sbl_hr<iterator_type>& arg);
    virtual void on_pulse_model_expsum(const pulse_model_expsum<iterator_type>& arg);
    virtual void on_pulse_position_modulation(const pulse_position_modulation<iterator_type>& arg);
    virtual void on_pulse_position_modulation_1(const pulse_position_modulation_1<iterator_type>& arg);
    virtual void on_range_calc(const range_calc<iterator_type>& arg);
    virtual void on_range_finder_debug_acq(const range_finder_debug_acq<iterator_type>& arg);
    virtual void on_range_finder_debug_acq_1(const range_finder_debug_acq_1<iterator_type>& arg);
    virtual void on_range_finder_debug_calc(const range_finder_debug_calc<iterator_type>& arg);
    virtual void on_range_finder_debug_calc_1(const range_finder_debug_calc_1<iterator_type>& arg);
    virtual void on_range_finder_debug_laser(const range_finder_debug_laser<iterator_type>& arg);
    virtual void on_range_finder_debug_laser_1(const range_finder_debug_laser_1<iterator_type>& arg);
    virtual void on_range_finder_debug_rcv(const range_finder_debug_rcv<iterator_type>& arg);
    virtual void on_range_finder_program(const range_finder_program<iterator_type>& arg);
    virtual void on_range_finder_program_1(const range_finder_program_1<iterator_type>& arg);
    virtual void on_range_finder_program_2(const range_finder_program_2<iterator_type>& arg);
    virtual void on_range_finder_settings(const range_finder_settings<iterator_type>& arg);
    virtual void on_reftab_table(const reftab_table<iterator_type>& arg);
    virtual void on_rel_refl_table(const rel_refl_table<iterator_type>& arg);
    virtual void on_rxp_parameters(const rxp_parameters<iterator_type>& arg);
    virtual void on_sbl_dg_channel(const sbl_dg_channel<iterator_type>& arg);
    virtual void on_sbl_dg_channel_1(const sbl_dg_channel_1<iterator_type>& arg);
    virtual void on_sbl_dg_channel_2(const sbl_dg_channel_2<iterator_type>& arg);
    virtual void on_sbl_dg_channel_data(const sbl_dg_channel_data<iterator_type>& arg);
    virtual void on_sbl_dg_channel_data_compressed(const sbl_dg_channel_data_compressed<iterator_type>& arg);
    virtual void on_sbl_dg_channel_expsum(const sbl_dg_channel_expsum<iterator_type>& arg);
    virtual void on_sbl_dg_channel_expsum_1(const sbl_dg_channel_expsum_1<iterator_type>& arg);
    virtual void on_sbl_dg_channel_fp(const sbl_dg_channel_fp<iterator_type>& arg);
    virtual void on_sbl_dg_channel_header(const sbl_dg_channel_header<iterator_type>& arg);
    virtual void on_sbl_dg_channel_header_1(const sbl_dg_channel_header_1<iterator_type>& arg);
    virtual void on_sbl_dg_channel_logamp(const sbl_dg_channel_logamp<iterator_type>& arg);
    virtual void on_sbl_dg_data(const sbl_dg_data<iterator_type>& arg);
    virtual void on_sbl_dg_data_compressed(const sbl_dg_data_compressed<iterator_type>& arg);
    virtual void on_sbl_dg_data_compressed_hr(const sbl_dg_data_compressed_hr<iterator_type>& arg);
    virtual void on_sbl_dg_data_hr(const sbl_dg_data_hr<iterator_type>& arg);
    virtual void on_sbl_dg_filter(const sbl_dg_filter<iterator_type>& arg);
    virtual void on_sbl_dg_header(const sbl_dg_header<iterator_type>& arg);
    virtual void on_sbl_dg_header_hr(const sbl_dg_header_hr<iterator_type>& arg);
    virtual void on_sbl_dg_parameters(const sbl_dg_parameters<iterator_type>& arg);
    virtual void on_slt_dg(const slt_dg<iterator_type>& arg);
    virtual void on_slt_dg_1(const slt_dg_1<iterator_type>& arg);
    virtual void on_slt_dg_2(const slt_dg_2<iterator_type>& arg);
    virtual void on_slt_dg_3(const slt_dg_3<iterator_type>& arg);
    virtual void on_slt_dg_4(const slt_dg_4<iterator_type>& arg);
    virtual void on_tgt_dg(const tgt_dg<iterator_type>& arg);
    virtual void on_timed_blob(const timed_blob<iterator_type>& arg);
    virtual void on_trigger_debug_dyntrig_table(const trigger_debug_dyntrig_table<iterator_type>& arg);
    virtual void on_trigger_debug_stattrig_table(const trigger_debug_stattrig_table<iterator_type>& arg);
    virtual void on_ttip_config(const ttip_config<iterator_type>& arg);
    virtual void on_ttip_config_channel(const ttip_config_channel<iterator_type>& arg);
    virtual void on_ttip_start_stop(const ttip_start_stop<iterator_type>& arg);
    virtual void on_ttip_timestamp(const ttip_timestamp<iterator_type>& arg);
    virtual void on_ublox_lea5t_rxm(const ublox_lea5t_rxm<iterator_type>& arg);
    virtual void on_ublox_lea5t_rxm_sfrb(const ublox_lea5t_rxm_sfrb<iterator_type>& arg);
    virtual void on_versions(const versions<iterator_type>& arg);
    virtual void on_wfm_dg_hp(const wfm_dg_hp<iterator_type>& arg);
    virtual void on_wfm_dg_lp(const wfm_dg_lp<iterator_type>& arg);
    virtual void on_wfm_dg_shp(const wfm_dg_shp<iterator_type>& arg);
    #endif //DOXYGEN
    //! This function will be called for packets unknown to this version of the library.
    //!\param id_main the main id
    //!\param id_sub the sub id
    virtual void on_unknown(unsigned id_main, unsigned id_sub, const iterator_type& begin, const iterator_type& end);

    //! By default packets are dispatched to the most derived packet version known
    //! to the library and to all ancestors. If you dont want this behaviour you
    //! need to call this function.
    //!
    void dont_handle_parent() {
        dispatch_parent = false;
    }
    //! This function will cause the dispatch function to return with a value of true.
    void request_dispatch_end() {
        dispatch_end_requested = true;
    }

    lookup_table lookup;
public:
    package_id   id;
    uint32_t     sequel;

protected:

    bool package_probes;

private:

    bool dispatch_parent;
    bool dispatch_end_requested;
};
//-----------------------------------------------------------------------------
//! convert to string representation
//
//! This class converts a package into a string representation.
//! By default all packets are converted. The selector can be used
//! to filter out the intended subset of packets. Dont forget to
//! specify the header packet in the selector!
class ostream_packets
    : public basic_packets
{
public:
    typedef basic_packets::iterator_type iterator_type; //!< embedded iterator type definition

    //! construct with stream reference
    //
    //!\param out a reference to an out stream
    ostream_packets(std::ostream& out)
        : out(&out)
    {}
    virtual ~ostream_packets()
    {}

#ifndef DOXYGEN
protected:
    ostream_packets() : out(0) {}
    #endif //DOXYGEN

    #ifndef DOXYGEN
    void on_id(const package_id& arg, const basic_package<iterator_type>& pkg);
    virtual void on_IMU_data(const IMU_data<iterator_type>& arg);
    virtual void on_S10DOF_calib(const S10DOF_calib<iterator_type>& arg);
    virtual void on_S10DOF_calib_1(const S10DOF_calib_1<iterator_type>& arg);
    virtual void on_S10DOF_data(const S10DOF_data<iterator_type>& arg);
    virtual void on_S10DOF_data_1(const S10DOF_data_1<iterator_type>& arg);
    virtual void on_S10DOF_units(const S10DOF_units<iterator_type>& arg);
    virtual void on_alert(const alert<iterator_type>& arg);
    virtual void on_arange_table(const arange_table<iterator_type>& arg);
    virtual void on_atmosphere(const atmosphere<iterator_type>& arg);
    virtual void on_atmosphere_1(const atmosphere_1<iterator_type>& arg);
    virtual void on_atmosphere_2(const atmosphere_2<iterator_type>& arg);
    virtual void on_atmosphere_3(const atmosphere_3<iterator_type>& arg);
    virtual void on_atmosphere_4(const atmosphere_4<iterator_type>& arg);
    virtual void on_avg_fine_ref_dg(const avg_fine_ref_dg<iterator_type>& arg);
    virtual void on_beam_geometry(const beam_geometry<iterator_type>& arg);
    virtual void on_biaxial_geometry(const biaxial_geometry<iterator_type>& arg);
    virtual void on_blob_uint32(const blob_uint32<iterator_type>& arg);
    virtual void on_blob_uint8(const blob_uint8<iterator_type>& arg);
    virtual void on_calib_2D_table(const calib_2D_table<iterator_type>& arg);
    virtual void on_calib_table(const calib_table<iterator_type>& arg);
    virtual void on_calib_waveform(const calib_waveform<iterator_type>& arg);
    virtual void on_calib_waveform_1(const calib_waveform_1<iterator_type>& arg);
    virtual void on_calib_waveform_L2(const calib_waveform_L2<iterator_type>& arg);
    virtual void on_calib_waveform_L2_1(const calib_waveform_L2_1<iterator_type>& arg);
    virtual void on_calib_wfm_sbl_header(const calib_wfm_sbl_header<iterator_type>& arg);
    virtual void on_cc_slice(const cc_slice<iterator_type>& arg);
    virtual void on_channel_combination_table(const channel_combination_table<iterator_type>& arg);
    virtual void on_context_end(const context_end<iterator_type>& arg);
    virtual void on_counter_sync(const counter_sync<iterator_type>& arg);
    virtual void on_counter_sync_2angles_hr(const counter_sync_2angles_hr<iterator_type>& arg);
    virtual void on_crc32_check(const crc32_check<iterator_type>& arg);
    virtual void on_crc32_header(const crc32_header<iterator_type>& arg);
    virtual void on_cs_trans(const cs_trans<iterator_type>& arg);
    virtual void on_datagram_separator(const datagram_separator<iterator_type>& arg);
    virtual void on_debug_hw_dg(const debug_hw_dg<iterator_type>& arg);
    virtual void on_debug_sw_dg(const debug_sw_dg<iterator_type>& arg);
    virtual void on_device_geometry(const device_geometry<iterator_type>& arg);
    virtual void on_device_geometry_1(const device_geometry_1<iterator_type>& arg);
    virtual void on_device_geometry_2(const device_geometry_2<iterator_type>& arg);
    virtual void on_device_geometry_3(const device_geometry_3<iterator_type>& arg);
    virtual void on_device_geometry_4(const device_geometry_4<iterator_type>& arg);
    virtual void on_device_geometry_5(const device_geometry_5<iterator_type>& arg);
    virtual void on_device_geometry_6(const device_geometry_6<iterator_type>& arg);
    virtual void on_device_geometry_7(const device_geometry_7<iterator_type>& arg);
    virtual void on_device_geometry_passive_channel(const device_geometry_passive_channel<iterator_type>& arg);
    virtual void on_device_mounting(const device_mounting<iterator_type>& arg);
    virtual void on_dyntrig(const dyntrig<iterator_type>& arg);
    virtual void on_echo(const echo<iterator_type>& arg);
    virtual void on_echo_1(const echo_1<iterator_type>& arg);
    virtual void on_extents(const extents<iterator_type>& arg);
    virtual void on_extents_1(const extents_1<iterator_type>& arg);
    virtual void on_external_gnss_cfg(const external_gnss_cfg<iterator_type>& arg);
    virtual void on_external_gnss_cfg_ext(const external_gnss_cfg_ext<iterator_type>& arg);
    virtual void on_firmware(const firmware<iterator_type>& arg);
    virtual void on_firmware_1(const firmware_1<iterator_type>& arg);
    virtual void on_firmware_2(const firmware_2<iterator_type>& arg);
    virtual void on_firmware_3(const firmware_3<iterator_type>& arg);
    virtual void on_fp_samples(const fp_samples<iterator_type>& arg);
    virtual void on_fp_table(const fp_table<iterator_type>& arg);
    virtual void on_fp_trace2ampl(const fp_trace2ampl<iterator_type>& arg);
    virtual void on_fp_wghts(const fp_wghts<iterator_type>& arg);
    virtual void on_frame_start(const frame_start<iterator_type>& arg);
    virtual void on_frame_start_dn(const frame_start_dn<iterator_type>& arg);
    virtual void on_frame_start_up(const frame_start_up<iterator_type>& arg);
    virtual void on_frame_stop(const frame_stop<iterator_type>& arg);
    virtual void on_generic_end(const generic_end<iterator_type>& arg);
    virtual void on_gravity_socs(const gravity_socs<iterator_type>& arg);
    virtual void on_header(const header<iterator_type>& arg);
    virtual void on_header_device(const header_device<iterator_type>& arg);
    virtual void on_header_ext(const header_ext<iterator_type>& arg);
    virtual void on_hk_bat(const hk_bat<iterator_type>& arg);
    virtual void on_hk_bat_1(const hk_bat_1<iterator_type>& arg);
    virtual void on_hk_bat_2(const hk_bat_2<iterator_type>& arg);
    virtual void on_hk_cam(const hk_cam<iterator_type>& arg);
    virtual void on_hk_ctr(const hk_ctr<iterator_type>& arg);
    virtual void on_hk_ctr_1(const hk_ctr_1<iterator_type>& arg);
    virtual void on_hk_extended_external(const hk_extended_external<iterator_type>& arg);
    virtual void on_hk_extended_internal(const hk_extended_internal<iterator_type>& arg);
    virtual void on_hk_float64_param(const hk_float64_param<iterator_type>& arg);
    virtual void on_hk_float_param(const hk_float_param<iterator_type>& arg);
    virtual void on_hk_gps(const hk_gps<iterator_type>& arg);
    virtual void on_hk_gps_hr(const hk_gps_hr<iterator_type>& arg);
    virtual void on_hk_gps_ts(const hk_gps_ts<iterator_type>& arg);
    virtual void on_hk_gps_ts_status(const hk_gps_ts_status<iterator_type>& arg);
    virtual void on_hk_gps_ts_status_dop(const hk_gps_ts_status_dop<iterator_type>& arg);
    virtual void on_hk_gps_ts_status_dop_ucs(const hk_gps_ts_status_dop_ucs<iterator_type>& arg);
    virtual void on_hk_group_header(const hk_group_header<iterator_type>& arg);
    virtual void on_hk_incl(const hk_incl<iterator_type>& arg);
    virtual void on_hk_incl_4axes(const hk_incl_4axes<iterator_type>& arg);
    virtual void on_hk_monitor(const hk_monitor<iterator_type>& arg);
    virtual void on_hk_param_header(const hk_param_header<iterator_type>& arg);
    virtual void on_hk_param_header_1(const hk_param_header_1<iterator_type>& arg);
    virtual void on_hk_ph_data(const hk_ph_data<iterator_type>& arg);
    virtual void on_hk_ph_data_1(const hk_ph_data_1<iterator_type>& arg);
    virtual void on_hk_ph_units(const hk_ph_units<iterator_type>& arg);
    virtual void on_hk_ph_units_1(const hk_ph_units_1<iterator_type>& arg);
    virtual void on_hk_pwr(const hk_pwr<iterator_type>& arg);
    virtual void on_hk_pwr_1(const hk_pwr_1<iterator_type>& arg);
    virtual void on_hk_rad(const hk_rad<iterator_type>& arg);
    virtual void on_hk_rng(const hk_rng<iterator_type>& arg);
    virtual void on_hk_rng_1(const hk_rng_1<iterator_type>& arg);
    virtual void on_hk_rng_2(const hk_rng_2<iterator_type>& arg);
    virtual void on_hk_rng_3(const hk_rng_3<iterator_type>& arg);
    virtual void on_hk_rng_4(const hk_rng_4<iterator_type>& arg);
    virtual void on_hk_rng_5(const hk_rng_5<iterator_type>& arg);
    virtual void on_hk_rng_6(const hk_rng_6<iterator_type>& arg);
    virtual void on_hk_rng_7(const hk_rng_7<iterator_type>& arg);
    virtual void on_hk_rng_8(const hk_rng_8<iterator_type>& arg);
    virtual void on_hk_rng_9(const hk_rng_9<iterator_type>& arg);
    virtual void on_hk_rngx(const hk_rngx<iterator_type>& arg);
    virtual void on_hk_rtc(const hk_rtc<iterator_type>& arg);
    virtual void on_hk_rtc_sys(const hk_rtc_sys<iterator_type>& arg);
    virtual void on_hk_scn(const hk_scn<iterator_type>& arg);
    virtual void on_hk_scn_1(const hk_scn_1<iterator_type>& arg);
    virtual void on_hk_scn_2(const hk_scn_2<iterator_type>& arg);
    virtual void on_hk_string_param(const hk_string_param<iterator_type>& arg);
    virtual void on_hk_time(const hk_time<iterator_type>& arg);
    virtual void on_hk_uint64_param(const hk_uint64_param<iterator_type>& arg);
    virtual void on_ht_dbg_data(const ht_dbg_data<iterator_type>& arg);
    virtual void on_inclination(const inclination<iterator_type>& arg);
    virtual void on_inclination_4axes(const inclination_4axes<iterator_type>& arg);
    virtual void on_inclination_device(const inclination_device<iterator_type>& arg);
    virtual void on_inclination_device_4axes(const inclination_device_4axes<iterator_type>& arg);
    virtual void on_inclination_device_4axes_offset(const inclination_device_4axes_offset<iterator_type>& arg);
    virtual void on_inclination_static(const inclination_static<iterator_type>& arg);
    virtual void on_laser_echo(const laser_echo<iterator_type>& arg);
    virtual void on_laser_echo_qual(const laser_echo_qual<iterator_type>& arg);
    virtual void on_laser_echo_sw(const laser_echo_sw<iterator_type>& arg);
    virtual void on_laser_shot(const laser_shot<iterator_type>& arg);
    virtual void on_laser_shot_1angle(const laser_shot_1angle<iterator_type>& arg);
    virtual void on_laser_shot_2angles(const laser_shot_2angles<iterator_type>& arg);
    virtual void on_laser_shot_2angles_hr(const laser_shot_2angles_hr<iterator_type>& arg);
    virtual void on_laser_shot_2angles_rad(const laser_shot_2angles_rad<iterator_type>& arg);
    virtual void on_laser_shot_3angles(const laser_shot_3angles<iterator_type>& arg);
    virtual void on_laser_shot_6angles(const laser_shot_6angles<iterator_type>& arg);
    virtual void on_laser_shot_6angles_hr(const laser_shot_6angles_hr<iterator_type>& arg);
    virtual void on_laser_shot_rad(const laser_shot_rad<iterator_type>& arg);
    virtual void on_laser_shot_utctime_origin_direction(const laser_shot_utctime_origin_direction<iterator_type>& arg);
    virtual void on_line_start(const line_start<iterator_type>& arg);
    virtual void on_line_start_dn(const line_start_dn<iterator_type>& arg);
    virtual void on_line_start_segment_1(const line_start_segment_1<iterator_type>& arg);
    virtual void on_line_start_segment_2(const line_start_segment_2<iterator_type>& arg);
    virtual void on_line_start_segment_3(const line_start_segment_3<iterator_type>& arg);
    virtual void on_line_start_up(const line_start_up<iterator_type>& arg);
    virtual void on_line_stop(const line_stop<iterator_type>& arg);
    virtual void on_m_sequence_mta(const m_sequence_mta<iterator_type>& arg);
    virtual void on_magnetic_field(const magnetic_field<iterator_type>& arg);
    virtual void on_meas_start(const meas_start<iterator_type>& arg);
    virtual void on_meas_stop(const meas_stop<iterator_type>& arg);
    virtual void on_monitoring_info(const monitoring_info<iterator_type>& arg);
    virtual void on_mta_settings(const mta_settings<iterator_type>& arg);
    virtual void on_mta_settings_1(const mta_settings_1<iterator_type>& arg);
    virtual void on_mta_settings_2(const mta_settings_2<iterator_type>& arg);
    virtual void on_mta_settings_3(const mta_settings_3<iterator_type>& arg);
    virtual void on_notch_filter(const notch_filter<iterator_type>& arg);
    virtual void on_notch_filter_modification_parameters(const notch_filter_modification_parameters<iterator_type>& arg);
    virtual void on_nrange_table(const nrange_table<iterator_type>& arg);
    virtual void on_operating_time(const operating_time<iterator_type>& arg);
    virtual void on_packed_frame_echo(const packed_frame_echo<iterator_type>& arg);
    virtual void on_packed_frame_echo_hr(const packed_frame_echo_hr<iterator_type>& arg);
    virtual void on_packed_frame_echo_hr_1(const packed_frame_echo_hr_1<iterator_type>& arg);
    virtual void on_packed_frame_laser_shot_2angles(const packed_frame_laser_shot_2angles<iterator_type>& arg);
    virtual void on_packed_frame_laser_shot_2angles_hr(const packed_frame_laser_shot_2angles_hr<iterator_type>& arg);
    virtual void on_packed_frame_laser_shot_2angles_rad(const packed_frame_laser_shot_2angles_rad<iterator_type>& arg);
    virtual void on_packed_key_echo(const packed_key_echo<iterator_type>& arg);
    virtual void on_packed_key_echo_hr(const packed_key_echo_hr<iterator_type>& arg);
    virtual void on_packed_key_echo_hr_1(const packed_key_echo_hr_1<iterator_type>& arg);
    virtual void on_packed_key_laser_shot_2angles(const packed_key_laser_shot_2angles<iterator_type>& arg);
    virtual void on_packed_key_laser_shot_2angles_hr(const packed_key_laser_shot_2angles_hr<iterator_type>& arg);
    virtual void on_packed_key_laser_shot_2angles_hr_mta(const packed_key_laser_shot_2angles_hr_mta<iterator_type>& arg);
    virtual void on_packed_key_laser_shot_2angles_rad(const packed_key_laser_shot_2angles_rad<iterator_type>& arg);
    virtual void on_packed_sdf(const packed_sdf<iterator_type>& arg);
    virtual void on_packed_shot_echos_hr(const packed_shot_echos_hr<iterator_type>& arg);
    virtual void on_packed_shot_echos_sbl_hr(const packed_shot_echos_sbl_hr<iterator_type>& arg);
    virtual void on_pps_sync(const pps_sync<iterator_type>& arg);
    virtual void on_pps_sync_ext(const pps_sync_ext<iterator_type>& arg);
    virtual void on_pps_sync_hr(const pps_sync_hr<iterator_type>& arg);
    virtual void on_pps_sync_hr_ext(const pps_sync_hr_ext<iterator_type>& arg);
    virtual void on_pulse_model_expsum(const pulse_model_expsum<iterator_type>& arg);
    virtual void on_pulse_position_modulation(const pulse_position_modulation<iterator_type>& arg);
    virtual void on_pulse_position_modulation_1(const pulse_position_modulation_1<iterator_type>& arg);
    virtual void on_pwm_sync(const pwm_sync<iterator_type>& arg);
    virtual void on_range_calc(const range_calc<iterator_type>& arg);
    virtual void on_range_finder_debug_acq(const range_finder_debug_acq<iterator_type>& arg);
    virtual void on_range_finder_debug_acq_1(const range_finder_debug_acq_1<iterator_type>& arg);
    virtual void on_range_finder_debug_calc(const range_finder_debug_calc<iterator_type>& arg);
    virtual void on_range_finder_debug_calc_1(const range_finder_debug_calc_1<iterator_type>& arg);
    virtual void on_range_finder_debug_laser(const range_finder_debug_laser<iterator_type>& arg);
    virtual void on_range_finder_debug_laser_1(const range_finder_debug_laser_1<iterator_type>& arg);
    virtual void on_range_finder_debug_rcv(const range_finder_debug_rcv<iterator_type>& arg);
    virtual void on_range_finder_program(const range_finder_program<iterator_type>& arg);
    virtual void on_range_finder_program_1(const range_finder_program_1<iterator_type>& arg);
    virtual void on_range_finder_program_2(const range_finder_program_2<iterator_type>& arg);
    virtual void on_range_finder_settings(const range_finder_settings<iterator_type>& arg);
    virtual void on_receiver_geometry(const receiver_geometry<iterator_type>& arg);
    virtual void on_reftab_table(const reftab_table<iterator_type>& arg);
    virtual void on_rel_refl_table(const rel_refl_table<iterator_type>& arg);
    virtual void on_rxp_parameters(const rxp_parameters<iterator_type>& arg);
    virtual void on_sbl_dg_channel(const sbl_dg_channel<iterator_type>& arg);
    virtual void on_sbl_dg_channel_1(const sbl_dg_channel_1<iterator_type>& arg);
    virtual void on_sbl_dg_channel_2(const sbl_dg_channel_2<iterator_type>& arg);
    virtual void on_sbl_dg_channel_data(const sbl_dg_channel_data<iterator_type>& arg);
    virtual void on_sbl_dg_channel_data_compressed(const sbl_dg_channel_data_compressed<iterator_type>& arg);
    virtual void on_sbl_dg_channel_expsum(const sbl_dg_channel_expsum<iterator_type>& arg);
    virtual void on_sbl_dg_channel_expsum_1(const sbl_dg_channel_expsum_1<iterator_type>& arg);
    virtual void on_sbl_dg_channel_fp(const sbl_dg_channel_fp<iterator_type>& arg);
    virtual void on_sbl_dg_channel_header(const sbl_dg_channel_header<iterator_type>& arg);
    virtual void on_sbl_dg_channel_header_1(const sbl_dg_channel_header_1<iterator_type>& arg);
    virtual void on_sbl_dg_channel_logamp(const sbl_dg_channel_logamp<iterator_type>& arg);
    virtual void on_sbl_dg_data(const sbl_dg_data<iterator_type>& arg);
    virtual void on_sbl_dg_data_compressed(const sbl_dg_data_compressed<iterator_type>& arg);
    virtual void on_sbl_dg_data_compressed_hr(const sbl_dg_data_compressed_hr<iterator_type>& arg);
    virtual void on_sbl_dg_data_hr(const sbl_dg_data_hr<iterator_type>& arg);
    virtual void on_sbl_dg_filter(const sbl_dg_filter<iterator_type>& arg);
    virtual void on_sbl_dg_header(const sbl_dg_header<iterator_type>& arg);
    virtual void on_sbl_dg_header_hr(const sbl_dg_header_hr<iterator_type>& arg);
    virtual void on_sbl_dg_parameters(const sbl_dg_parameters<iterator_type>& arg);
    virtual void on_scan_rect_fov(const scan_rect_fov<iterator_type>& arg);
    virtual void on_scan_rect_fov_1(const scan_rect_fov_1<iterator_type>& arg);
    virtual void on_scan_segments_fov(const scan_segments_fov<iterator_type>& arg);
    virtual void on_scan_trail_fov(const scan_trail_fov<iterator_type>& arg);
    virtual void on_scanner_pose(const scanner_pose<iterator_type>& arg);
    virtual void on_scanner_pose_hr(const scanner_pose_hr<iterator_type>& arg);
    virtual void on_scanner_pose_hr_1(const scanner_pose_hr_1<iterator_type>& arg);
    virtual void on_scanner_pose_ucs(const scanner_pose_ucs<iterator_type>& arg);
    virtual void on_scanner_pose_ucs_1(const scanner_pose_ucs_1<iterator_type>& arg);
    virtual void on_slt_dg(const slt_dg<iterator_type>& arg);
    virtual void on_slt_dg_1(const slt_dg_1<iterator_type>& arg);
    virtual void on_slt_dg_2(const slt_dg_2<iterator_type>& arg);
    virtual void on_slt_dg_3(const slt_dg_3<iterator_type>& arg);
    virtual void on_slt_dg_4(const slt_dg_4<iterator_type>& arg);
    virtual void on_tgt_dg(const tgt_dg<iterator_type>& arg);
    virtual void on_timed_blob(const timed_blob<iterator_type>& arg);
    virtual void on_trigger_debug_dyntrig_table(const trigger_debug_dyntrig_table<iterator_type>& arg);
    virtual void on_trigger_debug_stattrig_table(const trigger_debug_stattrig_table<iterator_type>& arg);
    virtual void on_ttip_config(const ttip_config<iterator_type>& arg);
    virtual void on_ttip_config_channel(const ttip_config_channel<iterator_type>& arg);
    virtual void on_ttip_start_stop(const ttip_start_stop<iterator_type>& arg);
    virtual void on_ttip_timestamp(const ttip_timestamp<iterator_type>& arg);
    virtual void on_ublox_lea5t_rxm(const ublox_lea5t_rxm<iterator_type>& arg);
    virtual void on_ublox_lea5t_rxm_sfrb(const ublox_lea5t_rxm_sfrb<iterator_type>& arg);
    virtual void on_units(const units<iterator_type>& arg);
    virtual void on_units_1(const units_1<iterator_type>& arg);
    virtual void on_units_2(const units_2<iterator_type>& arg);
    virtual void on_units_3(const units_3<iterator_type>& arg);
    virtual void on_units_4(const units_4<iterator_type>& arg);
    virtual void on_units_IMU(const units_IMU<iterator_type>& arg);
    virtual void on_unsolicited_message(const unsolicited_message<iterator_type>& arg);
    virtual void on_unsolicited_message_1(const unsolicited_message_1<iterator_type>& arg);
    virtual void on_unsolicited_message_2(const unsolicited_message_2<iterator_type>& arg);
    virtual void on_versions(const versions<iterator_type>& arg);
    virtual void on_void_data(const void_data<iterator_type>& arg);
    virtual void on_wfm_dg_hp(const wfm_dg_hp<iterator_type>& arg);
    virtual void on_wfm_dg_lp(const wfm_dg_lp<iterator_type>& arg);
    virtual void on_wfm_dg_shp(const wfm_dg_shp<iterator_type>& arg);
    virtual void on_unknown(unsigned id_main, unsigned id_sub, const iterator_type& begin, const iterator_type& end);

    std::ostream* out;
#endif //DOXYGEN
};
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
class encoder_packets
    : public basic_packets
{
public:
    typedef basic_packets::iterator_type iterator_type;
    typedef encoder_rxpmarker::iterator encoder_iterator_type;

    encoder_packets(encoder_rxpmarker& encoder_)
        : encoder(&encoder_)
    { encoder->put(encoder_buffer); }
    virtual ~encoder_packets()
    {}

protected:
    encoder_packets() : encoder(0) {}
    typedef encoder_rxpmarker::iterator it;
    typedef basic_packets::iterator_type cit;

    virtual void on_IMU_data(const IMU_data<cit>& arg);
    virtual void on_S10DOF_calib(const S10DOF_calib<cit>& arg);
    virtual void on_S10DOF_calib_1(const S10DOF_calib_1<cit>& arg);
    virtual void on_S10DOF_data(const S10DOF_data<cit>& arg);
    virtual void on_S10DOF_data_1(const S10DOF_data_1<cit>& arg);
    virtual void on_S10DOF_units(const S10DOF_units<cit>& arg);
    virtual void on_alert(const alert<cit>& arg);
    virtual void on_arange_table(const arange_table<cit>& arg);
    virtual void on_atmosphere(const atmosphere<cit>& arg);
    virtual void on_atmosphere_1(const atmosphere_1<cit>& arg);
    virtual void on_atmosphere_2(const atmosphere_2<cit>& arg);
    virtual void on_atmosphere_3(const atmosphere_3<cit>& arg);
    virtual void on_atmosphere_4(const atmosphere_4<cit>& arg);
    virtual void on_avg_fine_ref_dg(const avg_fine_ref_dg<cit>& arg);
    virtual void on_beam_geometry(const beam_geometry<cit>& arg);
    virtual void on_biaxial_geometry(const biaxial_geometry<cit>& arg);
    virtual void on_blob_uint32(const blob_uint32<cit>& arg);
    virtual void on_blob_uint8(const blob_uint8<cit>& arg);
    virtual void on_calib_2D_table(const calib_2D_table<cit>& arg);
    virtual void on_calib_table(const calib_table<cit>& arg);
    virtual void on_calib_waveform(const calib_waveform<cit>& arg);
    virtual void on_calib_waveform_1(const calib_waveform_1<cit>& arg);
    virtual void on_calib_waveform_L2(const calib_waveform_L2<cit>& arg);
    virtual void on_calib_waveform_L2_1(const calib_waveform_L2_1<cit>& arg);
    virtual void on_calib_wfm_sbl_header(const calib_wfm_sbl_header<cit>& arg);
    virtual void on_cc_slice(const cc_slice<cit>& arg);
    virtual void on_channel_combination_table(const channel_combination_table<cit>& arg);
    virtual void on_context_end(const context_end<cit>& arg);
    virtual void on_counter_sync(const counter_sync<cit>& arg);
    virtual void on_counter_sync_2angles_hr(const counter_sync_2angles_hr<cit>& arg);
    virtual void on_crc32_check(const crc32_check<cit>& arg);
    virtual void on_crc32_header(const crc32_header<cit>& arg);
    virtual void on_cs_trans(const cs_trans<cit>& arg);
    virtual void on_datagram_separator(const datagram_separator<cit>& arg);
    virtual void on_debug_hw_dg(const debug_hw_dg<cit>& arg);
    virtual void on_debug_sw_dg(const debug_sw_dg<cit>& arg);
    virtual void on_device_geometry(const device_geometry<cit>& arg);
    virtual void on_device_geometry_1(const device_geometry_1<cit>& arg);
    virtual void on_device_geometry_2(const device_geometry_2<cit>& arg);
    virtual void on_device_geometry_3(const device_geometry_3<cit>& arg);
    virtual void on_device_geometry_4(const device_geometry_4<cit>& arg);
    virtual void on_device_geometry_5(const device_geometry_5<cit>& arg);
    virtual void on_device_geometry_6(const device_geometry_6<cit>& arg);
    virtual void on_device_geometry_7(const device_geometry_7<cit>& arg);
    virtual void on_device_geometry_passive_channel(const device_geometry_passive_channel<cit>& arg);
    virtual void on_device_mounting(const device_mounting<cit>& arg);
    virtual void on_dyntrig(const dyntrig<cit>& arg);
    virtual void on_echo(const echo<cit>& arg);
    virtual void on_echo_1(const echo_1<cit>& arg);
    virtual void on_extents(const extents<cit>& arg);
    virtual void on_extents_1(const extents_1<cit>& arg);
    virtual void on_external_gnss_cfg(const external_gnss_cfg<cit>& arg);
    virtual void on_external_gnss_cfg_ext(const external_gnss_cfg_ext<cit>& arg);
    virtual void on_firmware(const firmware<cit>& arg);
    virtual void on_firmware_1(const firmware_1<cit>& arg);
    virtual void on_firmware_2(const firmware_2<cit>& arg);
    virtual void on_firmware_3(const firmware_3<cit>& arg);
    virtual void on_fp_samples(const fp_samples<cit>& arg);
    virtual void on_fp_table(const fp_table<cit>& arg);
    virtual void on_fp_trace2ampl(const fp_trace2ampl<cit>& arg);
    virtual void on_fp_wghts(const fp_wghts<cit>& arg);
    virtual void on_frame_start(const frame_start<cit>& arg);
    virtual void on_frame_start_dn(const frame_start_dn<cit>& arg);
    virtual void on_frame_start_up(const frame_start_up<cit>& arg);
    virtual void on_frame_stop(const frame_stop<cit>& arg);
    virtual void on_generic_end(const generic_end<cit>& arg);
    virtual void on_gravity_socs(const gravity_socs<cit>& arg);
    virtual void on_header(const header<cit>& arg);
    virtual void on_header_device(const header_device<cit>& arg);
    virtual void on_header_ext(const header_ext<cit>& arg);
    virtual void on_hk_bat(const hk_bat<cit>& arg);
    virtual void on_hk_bat_1(const hk_bat_1<cit>& arg);
    virtual void on_hk_bat_2(const hk_bat_2<cit>& arg);
    virtual void on_hk_cam(const hk_cam<cit>& arg);
    virtual void on_hk_ctr(const hk_ctr<cit>& arg);
    virtual void on_hk_ctr_1(const hk_ctr_1<cit>& arg);
    virtual void on_hk_extended_external(const hk_extended_external<cit>& arg);
    virtual void on_hk_extended_internal(const hk_extended_internal<cit>& arg);
    virtual void on_hk_float64_param(const hk_float64_param<cit>& arg);
    virtual void on_hk_float_param(const hk_float_param<cit>& arg);
    virtual void on_hk_gps(const hk_gps<cit>& arg);
    virtual void on_hk_gps_hr(const hk_gps_hr<cit>& arg);
    virtual void on_hk_gps_ts(const hk_gps_ts<cit>& arg);
    virtual void on_hk_gps_ts_status(const hk_gps_ts_status<cit>& arg);
    virtual void on_hk_gps_ts_status_dop(const hk_gps_ts_status_dop<cit>& arg);
    virtual void on_hk_gps_ts_status_dop_ucs(const hk_gps_ts_status_dop_ucs<cit>& arg);
    virtual void on_hk_group_header(const hk_group_header<cit>& arg);
    virtual void on_hk_incl(const hk_incl<cit>& arg);
    virtual void on_hk_incl_4axes(const hk_incl_4axes<cit>& arg);
    virtual void on_hk_monitor(const hk_monitor<cit>& arg);
    virtual void on_hk_param_header(const hk_param_header<cit>& arg);
    virtual void on_hk_param_header_1(const hk_param_header_1<cit>& arg);
    virtual void on_hk_ph_data(const hk_ph_data<cit>& arg);
    virtual void on_hk_ph_data_1(const hk_ph_data_1<cit>& arg);
    virtual void on_hk_ph_units(const hk_ph_units<cit>& arg);
    virtual void on_hk_ph_units_1(const hk_ph_units_1<cit>& arg);
    virtual void on_hk_pwr(const hk_pwr<cit>& arg);
    virtual void on_hk_pwr_1(const hk_pwr_1<cit>& arg);
    virtual void on_hk_rad(const hk_rad<cit>& arg);
    virtual void on_hk_rng(const hk_rng<cit>& arg);
    virtual void on_hk_rng_1(const hk_rng_1<cit>& arg);
    virtual void on_hk_rng_2(const hk_rng_2<cit>& arg);
    virtual void on_hk_rng_3(const hk_rng_3<cit>& arg);
    virtual void on_hk_rng_4(const hk_rng_4<cit>& arg);
    virtual void on_hk_rng_5(const hk_rng_5<cit>& arg);
    virtual void on_hk_rng_6(const hk_rng_6<cit>& arg);
    virtual void on_hk_rng_7(const hk_rng_7<cit>& arg);
    virtual void on_hk_rng_8(const hk_rng_8<cit>& arg);
    virtual void on_hk_rng_9(const hk_rng_9<cit>& arg);
    virtual void on_hk_rngx(const hk_rngx<cit>& arg);
    virtual void on_hk_rtc(const hk_rtc<cit>& arg);
    virtual void on_hk_rtc_sys(const hk_rtc_sys<cit>& arg);
    virtual void on_hk_scn(const hk_scn<cit>& arg);
    virtual void on_hk_scn_1(const hk_scn_1<cit>& arg);
    virtual void on_hk_scn_2(const hk_scn_2<cit>& arg);
    virtual void on_hk_string_param(const hk_string_param<cit>& arg);
    virtual void on_hk_time(const hk_time<cit>& arg);
    virtual void on_hk_uint64_param(const hk_uint64_param<cit>& arg);
    virtual void on_ht_dbg_data(const ht_dbg_data<cit>& arg);
    virtual void on_inclination(const inclination<cit>& arg);
    virtual void on_inclination_4axes(const inclination_4axes<cit>& arg);
    virtual void on_inclination_device(const inclination_device<cit>& arg);
    virtual void on_inclination_device_4axes(const inclination_device_4axes<cit>& arg);
    virtual void on_inclination_device_4axes_offset(const inclination_device_4axes_offset<cit>& arg);
    virtual void on_inclination_static(const inclination_static<cit>& arg);
    virtual void on_laser_echo(const laser_echo<cit>& arg);
    virtual void on_laser_echo_qual(const laser_echo_qual<cit>& arg);
    virtual void on_laser_echo_sw(const laser_echo_sw<cit>& arg);
    virtual void on_laser_shot(const laser_shot<cit>& arg);
    virtual void on_laser_shot_1angle(const laser_shot_1angle<cit>& arg);
    virtual void on_laser_shot_2angles(const laser_shot_2angles<cit>& arg);
    virtual void on_laser_shot_2angles_hr(const laser_shot_2angles_hr<cit>& arg);
    virtual void on_laser_shot_2angles_rad(const laser_shot_2angles_rad<cit>& arg);
    virtual void on_laser_shot_3angles(const laser_shot_3angles<cit>& arg);
    virtual void on_laser_shot_6angles(const laser_shot_6angles<cit>& arg);
    virtual void on_laser_shot_6angles_hr(const laser_shot_6angles_hr<cit>& arg);
    virtual void on_laser_shot_rad(const laser_shot_rad<cit>& arg);
    virtual void on_laser_shot_utctime_origin_direction(const laser_shot_utctime_origin_direction<cit>& arg);
    virtual void on_line_start(const line_start<cit>& arg);
    virtual void on_line_start_dn(const line_start_dn<cit>& arg);
    virtual void on_line_start_segment_1(const line_start_segment_1<cit>& arg);
    virtual void on_line_start_segment_2(const line_start_segment_2<cit>& arg);
    virtual void on_line_start_segment_3(const line_start_segment_3<cit>& arg);
    virtual void on_line_start_up(const line_start_up<cit>& arg);
    virtual void on_line_stop(const line_stop<cit>& arg);
    virtual void on_m_sequence_mta(const m_sequence_mta<cit>& arg);
    virtual void on_magnetic_field(const magnetic_field<cit>& arg);
    virtual void on_meas_start(const meas_start<cit>& arg);
    virtual void on_meas_stop(const meas_stop<cit>& arg);
    virtual void on_monitoring_info(const monitoring_info<cit>& arg);
    virtual void on_mta_settings(const mta_settings<cit>& arg);
    virtual void on_mta_settings_1(const mta_settings_1<cit>& arg);
    virtual void on_mta_settings_2(const mta_settings_2<cit>& arg);
    virtual void on_mta_settings_3(const mta_settings_3<cit>& arg);
    virtual void on_notch_filter(const notch_filter<cit>& arg);
    virtual void on_notch_filter_modification_parameters(const notch_filter_modification_parameters<cit>& arg);
    virtual void on_nrange_table(const nrange_table<cit>& arg);
    virtual void on_operating_time(const operating_time<cit>& arg);
    virtual void on_packed_frame_echo(const packed_frame_echo<cit>& arg);
    virtual void on_packed_frame_echo_hr(const packed_frame_echo_hr<cit>& arg);
    virtual void on_packed_frame_echo_hr_1(const packed_frame_echo_hr_1<cit>& arg);
    virtual void on_packed_frame_laser_shot_2angles(const packed_frame_laser_shot_2angles<cit>& arg);
    virtual void on_packed_frame_laser_shot_2angles_hr(const packed_frame_laser_shot_2angles_hr<cit>& arg);
    virtual void on_packed_frame_laser_shot_2angles_rad(const packed_frame_laser_shot_2angles_rad<cit>& arg);
    virtual void on_packed_key_echo(const packed_key_echo<cit>& arg);
    virtual void on_packed_key_echo_hr(const packed_key_echo_hr<cit>& arg);
    virtual void on_packed_key_echo_hr_1(const packed_key_echo_hr_1<cit>& arg);
    virtual void on_packed_key_laser_shot_2angles(const packed_key_laser_shot_2angles<cit>& arg);
    virtual void on_packed_key_laser_shot_2angles_hr(const packed_key_laser_shot_2angles_hr<cit>& arg);
    virtual void on_packed_key_laser_shot_2angles_hr_mta(const packed_key_laser_shot_2angles_hr_mta<cit>& arg);
    virtual void on_packed_key_laser_shot_2angles_rad(const packed_key_laser_shot_2angles_rad<cit>& arg);
    virtual void on_packed_sdf(const packed_sdf<cit>& arg);
    virtual void on_packed_shot_echos_hr(const packed_shot_echos_hr<cit>& arg);
    virtual void on_packed_shot_echos_sbl_hr(const packed_shot_echos_sbl_hr<cit>& arg);
    virtual void on_pps_sync(const pps_sync<cit>& arg);
    virtual void on_pps_sync_ext(const pps_sync_ext<cit>& arg);
    virtual void on_pps_sync_hr(const pps_sync_hr<cit>& arg);
    virtual void on_pps_sync_hr_ext(const pps_sync_hr_ext<cit>& arg);
    virtual void on_pulse_model_expsum(const pulse_model_expsum<cit>& arg);
    virtual void on_pulse_position_modulation(const pulse_position_modulation<cit>& arg);
    virtual void on_pulse_position_modulation_1(const pulse_position_modulation_1<cit>& arg);
    virtual void on_pwm_sync(const pwm_sync<cit>& arg);
    virtual void on_range_calc(const range_calc<cit>& arg);
    virtual void on_range_finder_debug_acq(const range_finder_debug_acq<cit>& arg);
    virtual void on_range_finder_debug_acq_1(const range_finder_debug_acq_1<cit>& arg);
    virtual void on_range_finder_debug_calc(const range_finder_debug_calc<cit>& arg);
    virtual void on_range_finder_debug_calc_1(const range_finder_debug_calc_1<cit>& arg);
    virtual void on_range_finder_debug_laser(const range_finder_debug_laser<cit>& arg);
    virtual void on_range_finder_debug_laser_1(const range_finder_debug_laser_1<cit>& arg);
    virtual void on_range_finder_debug_rcv(const range_finder_debug_rcv<cit>& arg);
    virtual void on_range_finder_program(const range_finder_program<cit>& arg);
    virtual void on_range_finder_program_1(const range_finder_program_1<cit>& arg);
    virtual void on_range_finder_program_2(const range_finder_program_2<cit>& arg);
    virtual void on_range_finder_settings(const range_finder_settings<cit>& arg);
    virtual void on_receiver_geometry(const receiver_geometry<cit>& arg);
    virtual void on_reftab_table(const reftab_table<cit>& arg);
    virtual void on_rel_refl_table(const rel_refl_table<cit>& arg);
    virtual void on_rxp_parameters(const rxp_parameters<cit>& arg);
    virtual void on_sbl_dg_channel(const sbl_dg_channel<cit>& arg);
    virtual void on_sbl_dg_channel_1(const sbl_dg_channel_1<cit>& arg);
    virtual void on_sbl_dg_channel_2(const sbl_dg_channel_2<cit>& arg);
    virtual void on_sbl_dg_channel_data(const sbl_dg_channel_data<cit>& arg);
    virtual void on_sbl_dg_channel_data_compressed(const sbl_dg_channel_data_compressed<cit>& arg);
    virtual void on_sbl_dg_channel_expsum(const sbl_dg_channel_expsum<cit>& arg);
    virtual void on_sbl_dg_channel_expsum_1(const sbl_dg_channel_expsum_1<cit>& arg);
    virtual void on_sbl_dg_channel_fp(const sbl_dg_channel_fp<cit>& arg);
    virtual void on_sbl_dg_channel_header(const sbl_dg_channel_header<cit>& arg);
    virtual void on_sbl_dg_channel_header_1(const sbl_dg_channel_header_1<cit>& arg);
    virtual void on_sbl_dg_channel_logamp(const sbl_dg_channel_logamp<cit>& arg);
    virtual void on_sbl_dg_data(const sbl_dg_data<cit>& arg);
    virtual void on_sbl_dg_data_compressed(const sbl_dg_data_compressed<cit>& arg);
    virtual void on_sbl_dg_data_compressed_hr(const sbl_dg_data_compressed_hr<cit>& arg);
    virtual void on_sbl_dg_data_hr(const sbl_dg_data_hr<cit>& arg);
    virtual void on_sbl_dg_filter(const sbl_dg_filter<cit>& arg);
    virtual void on_sbl_dg_header(const sbl_dg_header<cit>& arg);
    virtual void on_sbl_dg_header_hr(const sbl_dg_header_hr<cit>& arg);
    virtual void on_sbl_dg_parameters(const sbl_dg_parameters<cit>& arg);
    virtual void on_scan_rect_fov(const scan_rect_fov<cit>& arg);
    virtual void on_scan_rect_fov_1(const scan_rect_fov_1<cit>& arg);
    virtual void on_scan_segments_fov(const scan_segments_fov<cit>& arg);
    virtual void on_scan_trail_fov(const scan_trail_fov<cit>& arg);
    virtual void on_scanner_pose(const scanner_pose<cit>& arg);
    virtual void on_scanner_pose_hr(const scanner_pose_hr<cit>& arg);
    virtual void on_scanner_pose_hr_1(const scanner_pose_hr_1<cit>& arg);
    virtual void on_scanner_pose_ucs(const scanner_pose_ucs<cit>& arg);
    virtual void on_scanner_pose_ucs_1(const scanner_pose_ucs_1<cit>& arg);
    virtual void on_slt_dg(const slt_dg<cit>& arg);
    virtual void on_slt_dg_1(const slt_dg_1<cit>& arg);
    virtual void on_slt_dg_2(const slt_dg_2<cit>& arg);
    virtual void on_slt_dg_3(const slt_dg_3<cit>& arg);
    virtual void on_slt_dg_4(const slt_dg_4<cit>& arg);
    virtual void on_tgt_dg(const tgt_dg<cit>& arg);
    virtual void on_timed_blob(const timed_blob<cit>& arg);
    virtual void on_trigger_debug_dyntrig_table(const trigger_debug_dyntrig_table<cit>& arg);
    virtual void on_trigger_debug_stattrig_table(const trigger_debug_stattrig_table<cit>& arg);
    virtual void on_ttip_config(const ttip_config<cit>& arg);
    virtual void on_ttip_config_channel(const ttip_config_channel<cit>& arg);
    virtual void on_ttip_start_stop(const ttip_start_stop<cit>& arg);
    virtual void on_ttip_timestamp(const ttip_timestamp<cit>& arg);
    virtual void on_ublox_lea5t_rxm(const ublox_lea5t_rxm<cit>& arg);
    virtual void on_ublox_lea5t_rxm_sfrb(const ublox_lea5t_rxm_sfrb<cit>& arg);
    virtual void on_units(const units<cit>& arg);
    virtual void on_units_1(const units_1<cit>& arg);
    virtual void on_units_2(const units_2<cit>& arg);
    virtual void on_units_3(const units_3<cit>& arg);
    virtual void on_units_4(const units_4<cit>& arg);
    virtual void on_units_IMU(const units_IMU<cit>& arg);
    virtual void on_unsolicited_message(const unsolicited_message<cit>& arg);
    virtual void on_unsolicited_message_1(const unsolicited_message_1<cit>& arg);
    virtual void on_unsolicited_message_2(const unsolicited_message_2<cit>& arg);
    virtual void on_versions(const versions<cit>& arg);
    virtual void on_void_data(const void_data<cit>& arg);
    virtual void on_wfm_dg_hp(const wfm_dg_hp<cit>& arg);
    virtual void on_wfm_dg_lp(const wfm_dg_lp<cit>& arg);
    virtual void on_wfm_dg_shp(const wfm_dg_shp<cit>& arg);

public:
    encoder_rxpmarker* encoder;
    buffer encoder_buffer;
    lookup_table encoder_lookup;
};
#endif //DOXYGEN
#ifndef DOXYGEN

template<class pkg_type>
struct encoder_package
    : public buffer_package<pkg_type>
{
    explicit encoder_package(encoder_packets* ep)
        : buffer_package<pkg_type>(ep->encoder_lookup, ep->encoder_buffer)
        , ep_(ep)
    {
    }

    void commit()
    {
        buffer_package<pkg_type>::resize();
        ep_->encoder->put(ep_->encoder_buffer);
    }

    template<class src_pkg_type>
    encoder_package& operator= (const src_pkg_type& y)
    {
        pkg_type& x(*this);
        x = y;
        return *this;
    }

private:
    encoder_packets* ep_;
};
#endif //DOXYGEN
//-----------------------------------------------------------------------------
#ifndef DOXYGEN
template<class charT, class traits, class B>
bool ridataspec_read(std::vector<B>& buffer, unsigned id_main, unsigned id_sub, std::basic_istream<charT, traits>& in) {
    package_id::type type = package_id(id_main, id_sub);
    switch(type) {
        case package_id::IMU_data: {
            buffer.resize(IMU_data<B*>::max_bit_width/(8*sizeof(B))+1);
            IMU_data<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::S10DOF_calib: {
            buffer.resize(S10DOF_calib<B*>::max_bit_width/(8*sizeof(B))+1);
            S10DOF_calib<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::S10DOF_calib_1: {
            buffer.resize(S10DOF_calib_1<B*>::max_bit_width/(8*sizeof(B))+1);
            S10DOF_calib_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::S10DOF_data: {
            buffer.resize(S10DOF_data<B*>::max_bit_width/(8*sizeof(B))+1);
            S10DOF_data<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::S10DOF_data_1: {
            buffer.resize(S10DOF_data_1<B*>::max_bit_width/(8*sizeof(B))+1);
            S10DOF_data_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::S10DOF_units: {
            buffer.resize(S10DOF_units<B*>::max_bit_width/(8*sizeof(B))+1);
            S10DOF_units<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::alert: {
            buffer.resize(alert<B*>::max_bit_width/(8*sizeof(B))+1);
            alert<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::arange_table: {
            buffer.resize(arange_table<B*>::max_bit_width/(8*sizeof(B))+1);
            arange_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::atmosphere: {
            buffer.resize(atmosphere<B*>::max_bit_width/(8*sizeof(B))+1);
            atmosphere<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::atmosphere_1: {
            buffer.resize(atmosphere_1<B*>::max_bit_width/(8*sizeof(B))+1);
            atmosphere_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::atmosphere_2: {
            buffer.resize(atmosphere_2<B*>::max_bit_width/(8*sizeof(B))+1);
            atmosphere_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::atmosphere_3: {
            buffer.resize(atmosphere_3<B*>::max_bit_width/(8*sizeof(B))+1);
            atmosphere_3<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::atmosphere_4: {
            buffer.resize(atmosphere_4<B*>::max_bit_width/(8*sizeof(B))+1);
            atmosphere_4<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::avg_fine_ref_dg: {
            buffer.resize(avg_fine_ref_dg<B*>::max_bit_width/(8*sizeof(B))+1);
            avg_fine_ref_dg<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::beam_geometry: {
            buffer.resize(beam_geometry<B*>::max_bit_width/(8*sizeof(B))+1);
            beam_geometry<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::biaxial_geometry: {
            buffer.resize(biaxial_geometry<B*>::max_bit_width/(8*sizeof(B))+1);
            biaxial_geometry<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::blob_uint32: {
            buffer.resize(blob_uint32<B*>::max_bit_width/(8*sizeof(B))+1);
            blob_uint32<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::blob_uint8: {
            buffer.resize(blob_uint8<B*>::max_bit_width/(8*sizeof(B))+1);
            blob_uint8<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::calib_2D_table: {
            buffer.resize(calib_2D_table<B*>::max_bit_width/(8*sizeof(B))+1);
            calib_2D_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::calib_table: {
            buffer.resize(calib_table<B*>::max_bit_width/(8*sizeof(B))+1);
            calib_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::calib_waveform: {
            buffer.resize(calib_waveform<B*>::max_bit_width/(8*sizeof(B))+1);
            calib_waveform<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::calib_waveform_1: {
            buffer.resize(calib_waveform_1<B*>::max_bit_width/(8*sizeof(B))+1);
            calib_waveform_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::calib_waveform_L2: {
            buffer.resize(calib_waveform_L2<B*>::max_bit_width/(8*sizeof(B))+1);
            calib_waveform_L2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::calib_waveform_L2_1: {
            buffer.resize(calib_waveform_L2_1<B*>::max_bit_width/(8*sizeof(B))+1);
            calib_waveform_L2_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::calib_wfm_sbl_header: {
            buffer.resize(calib_wfm_sbl_header<B*>::max_bit_width/(8*sizeof(B))+1);
            calib_wfm_sbl_header<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::cc_slice: {
            buffer.resize(cc_slice<B*>::max_bit_width/(8*sizeof(B))+1);
            cc_slice<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::channel_combination_table: {
            buffer.resize(channel_combination_table<B*>::max_bit_width/(8*sizeof(B))+1);
            channel_combination_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::context_end: {
            buffer.resize(context_end<B*>::max_bit_width/(8*sizeof(B))+1);
            context_end<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::counter_sync: {
            buffer.resize(counter_sync<B*>::max_bit_width/(8*sizeof(B))+1);
            counter_sync<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::counter_sync_2angles_hr: {
            buffer.resize(counter_sync_2angles_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            counter_sync_2angles_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::crc32_check: {
            buffer.resize(crc32_check<B*>::max_bit_width/(8*sizeof(B))+1);
            crc32_check<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::crc32_header: {
            buffer.resize(crc32_header<B*>::max_bit_width/(8*sizeof(B))+1);
            crc32_header<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::cs_trans: {
            buffer.resize(cs_trans<B*>::max_bit_width/(8*sizeof(B))+1);
            cs_trans<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::datagram_separator: {
            buffer.resize(datagram_separator<B*>::max_bit_width/(8*sizeof(B))+1);
            datagram_separator<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::debug_hw_dg: {
            buffer.resize(debug_hw_dg<B*>::max_bit_width/(8*sizeof(B))+1);
            debug_hw_dg<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::debug_sw_dg: {
            buffer.resize(debug_sw_dg<B*>::max_bit_width/(8*sizeof(B))+1);
            debug_sw_dg<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_geometry: {
            buffer.resize(device_geometry<B*>::max_bit_width/(8*sizeof(B))+1);
            device_geometry<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_geometry_1: {
            buffer.resize(device_geometry_1<B*>::max_bit_width/(8*sizeof(B))+1);
            device_geometry_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_geometry_2: {
            buffer.resize(device_geometry_2<B*>::max_bit_width/(8*sizeof(B))+1);
            device_geometry_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_geometry_3: {
            buffer.resize(device_geometry_3<B*>::max_bit_width/(8*sizeof(B))+1);
            device_geometry_3<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_geometry_4: {
            buffer.resize(device_geometry_4<B*>::max_bit_width/(8*sizeof(B))+1);
            device_geometry_4<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_geometry_5: {
            buffer.resize(device_geometry_5<B*>::max_bit_width/(8*sizeof(B))+1);
            device_geometry_5<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_geometry_6: {
            buffer.resize(device_geometry_6<B*>::max_bit_width/(8*sizeof(B))+1);
            device_geometry_6<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_geometry_7: {
            buffer.resize(device_geometry_7<B*>::max_bit_width/(8*sizeof(B))+1);
            device_geometry_7<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_geometry_passive_channel: {
            buffer.resize(device_geometry_passive_channel<B*>::max_bit_width/(8*sizeof(B))+1);
            device_geometry_passive_channel<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::device_mounting: {
            buffer.resize(device_mounting<B*>::max_bit_width/(8*sizeof(B))+1);
            device_mounting<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::dyntrig: {
            buffer.resize(dyntrig<B*>::max_bit_width/(8*sizeof(B))+1);
            dyntrig<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::echo: {
            buffer.resize(echo<B*>::max_bit_width/(8*sizeof(B))+1);
            echo<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::echo_1: {
            buffer.resize(echo_1<B*>::max_bit_width/(8*sizeof(B))+1);
            echo_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::extents: {
            buffer.resize(extents<B*>::max_bit_width/(8*sizeof(B))+1);
            extents<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::extents_1: {
            buffer.resize(extents_1<B*>::max_bit_width/(8*sizeof(B))+1);
            extents_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::external_gnss_cfg: {
            buffer.resize(external_gnss_cfg<B*>::max_bit_width/(8*sizeof(B))+1);
            external_gnss_cfg<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::external_gnss_cfg_ext: {
            buffer.resize(external_gnss_cfg_ext<B*>::max_bit_width/(8*sizeof(B))+1);
            external_gnss_cfg_ext<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::firmware: {
            buffer.resize(firmware<B*>::max_bit_width/(8*sizeof(B))+1);
            firmware<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::firmware_1: {
            buffer.resize(firmware_1<B*>::max_bit_width/(8*sizeof(B))+1);
            firmware_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::firmware_2: {
            buffer.resize(firmware_2<B*>::max_bit_width/(8*sizeof(B))+1);
            firmware_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::firmware_3: {
            buffer.resize(firmware_3<B*>::max_bit_width/(8*sizeof(B))+1);
            firmware_3<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::fp_samples: {
            buffer.resize(fp_samples<B*>::max_bit_width/(8*sizeof(B))+1);
            fp_samples<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::fp_table: {
            buffer.resize(fp_table<B*>::max_bit_width/(8*sizeof(B))+1);
            fp_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::fp_trace2ampl: {
            buffer.resize(fp_trace2ampl<B*>::max_bit_width/(8*sizeof(B))+1);
            fp_trace2ampl<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::fp_wghts: {
            buffer.resize(fp_wghts<B*>::max_bit_width/(8*sizeof(B))+1);
            fp_wghts<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::frame_start: {
            buffer.resize(frame_start<B*>::max_bit_width/(8*sizeof(B))+1);
            frame_start<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::frame_start_dn: {
            buffer.resize(frame_start_dn<B*>::max_bit_width/(8*sizeof(B))+1);
            frame_start_dn<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::frame_start_up: {
            buffer.resize(frame_start_up<B*>::max_bit_width/(8*sizeof(B))+1);
            frame_start_up<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::frame_stop: {
            buffer.resize(frame_stop<B*>::max_bit_width/(8*sizeof(B))+1);
            frame_stop<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::generic_end: {
            buffer.resize(generic_end<B*>::max_bit_width/(8*sizeof(B))+1);
            generic_end<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::gravity_socs: {
            buffer.resize(gravity_socs<B*>::max_bit_width/(8*sizeof(B))+1);
            gravity_socs<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::header: {
            buffer.resize(header<B*>::max_bit_width/(8*sizeof(B))+1);
            header<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::header_device: {
            buffer.resize(header_device<B*>::max_bit_width/(8*sizeof(B))+1);
            header_device<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::header_ext: {
            buffer.resize(header_ext<B*>::max_bit_width/(8*sizeof(B))+1);
            header_ext<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_bat: {
            buffer.resize(hk_bat<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_bat<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_bat_1: {
            buffer.resize(hk_bat_1<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_bat_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_bat_2: {
            buffer.resize(hk_bat_2<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_bat_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_cam: {
            buffer.resize(hk_cam<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_cam<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_ctr: {
            buffer.resize(hk_ctr<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_ctr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_ctr_1: {
            buffer.resize(hk_ctr_1<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_ctr_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_extended_external: {
            buffer.resize(hk_extended_external<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_extended_external<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_extended_internal: {
            buffer.resize(hk_extended_internal<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_extended_internal<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_float64_param: {
            buffer.resize(hk_float64_param<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_float64_param<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_float_param: {
            buffer.resize(hk_float_param<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_float_param<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_gps: {
            buffer.resize(hk_gps<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_gps<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_gps_hr: {
            buffer.resize(hk_gps_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_gps_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_gps_ts: {
            buffer.resize(hk_gps_ts<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_gps_ts<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_gps_ts_status: {
            buffer.resize(hk_gps_ts_status<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_gps_ts_status<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_gps_ts_status_dop: {
            buffer.resize(hk_gps_ts_status_dop<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_gps_ts_status_dop<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_gps_ts_status_dop_ucs: {
            buffer.resize(hk_gps_ts_status_dop_ucs<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_gps_ts_status_dop_ucs<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_group_header: {
            buffer.resize(hk_group_header<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_group_header<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_incl: {
            buffer.resize(hk_incl<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_incl<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_incl_4axes: {
            buffer.resize(hk_incl_4axes<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_incl_4axes<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_monitor: {
            buffer.resize(hk_monitor<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_monitor<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_param_header: {
            buffer.resize(hk_param_header<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_param_header<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_param_header_1: {
            buffer.resize(hk_param_header_1<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_param_header_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_ph_data: {
            buffer.resize(hk_ph_data<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_ph_data<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_ph_data_1: {
            buffer.resize(hk_ph_data_1<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_ph_data_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_ph_units: {
            buffer.resize(hk_ph_units<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_ph_units<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_ph_units_1: {
            buffer.resize(hk_ph_units_1<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_ph_units_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_pwr: {
            buffer.resize(hk_pwr<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_pwr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_pwr_1: {
            buffer.resize(hk_pwr_1<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_pwr_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rad: {
            buffer.resize(hk_rad<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rad<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng: {
            buffer.resize(hk_rng<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng_1: {
            buffer.resize(hk_rng_1<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng_2: {
            buffer.resize(hk_rng_2<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng_3: {
            buffer.resize(hk_rng_3<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng_3<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng_4: {
            buffer.resize(hk_rng_4<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng_4<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng_5: {
            buffer.resize(hk_rng_5<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng_5<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng_6: {
            buffer.resize(hk_rng_6<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng_6<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng_7: {
            buffer.resize(hk_rng_7<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng_7<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng_8: {
            buffer.resize(hk_rng_8<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng_8<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rng_9: {
            buffer.resize(hk_rng_9<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rng_9<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rngx: {
            buffer.resize(hk_rngx<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rngx<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rtc: {
            buffer.resize(hk_rtc<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rtc<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_rtc_sys: {
            buffer.resize(hk_rtc_sys<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_rtc_sys<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_scn: {
            buffer.resize(hk_scn<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_scn<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_scn_1: {
            buffer.resize(hk_scn_1<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_scn_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_scn_2: {
            buffer.resize(hk_scn_2<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_scn_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_string_param: {
            buffer.resize(hk_string_param<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_string_param<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_time: {
            buffer.resize(hk_time<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_time<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::hk_uint64_param: {
            buffer.resize(hk_uint64_param<B*>::max_bit_width/(8*sizeof(B))+1);
            hk_uint64_param<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::ht_dbg_data: {
            buffer.resize(ht_dbg_data<B*>::max_bit_width/(8*sizeof(B))+1);
            ht_dbg_data<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::inclination: {
            buffer.resize(inclination<B*>::max_bit_width/(8*sizeof(B))+1);
            inclination<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::inclination_4axes: {
            buffer.resize(inclination_4axes<B*>::max_bit_width/(8*sizeof(B))+1);
            inclination_4axes<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::inclination_device: {
            buffer.resize(inclination_device<B*>::max_bit_width/(8*sizeof(B))+1);
            inclination_device<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::inclination_device_4axes: {
            buffer.resize(inclination_device_4axes<B*>::max_bit_width/(8*sizeof(B))+1);
            inclination_device_4axes<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::inclination_device_4axes_offset: {
            buffer.resize(inclination_device_4axes_offset<B*>::max_bit_width/(8*sizeof(B))+1);
            inclination_device_4axes_offset<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::inclination_static: {
            buffer.resize(inclination_static<B*>::max_bit_width/(8*sizeof(B))+1);
            inclination_static<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_echo: {
            buffer.resize(laser_echo<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_echo<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_echo_qual: {
            buffer.resize(laser_echo_qual<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_echo_qual<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_echo_sw: {
            buffer.resize(laser_echo_sw<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_echo_sw<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot: {
            buffer.resize(laser_shot<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot_1angle: {
            buffer.resize(laser_shot_1angle<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot_1angle<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot_2angles: {
            buffer.resize(laser_shot_2angles<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot_2angles<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot_2angles_hr: {
            buffer.resize(laser_shot_2angles_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot_2angles_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot_2angles_rad: {
            buffer.resize(laser_shot_2angles_rad<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot_2angles_rad<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot_3angles: {
            buffer.resize(laser_shot_3angles<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot_3angles<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot_6angles: {
            buffer.resize(laser_shot_6angles<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot_6angles<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot_6angles_hr: {
            buffer.resize(laser_shot_6angles_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot_6angles_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot_rad: {
            buffer.resize(laser_shot_rad<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot_rad<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::laser_shot_utctime_origin_direction: {
            buffer.resize(laser_shot_utctime_origin_direction<B*>::max_bit_width/(8*sizeof(B))+1);
            laser_shot_utctime_origin_direction<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::line_start: {
            buffer.resize(line_start<B*>::max_bit_width/(8*sizeof(B))+1);
            line_start<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::line_start_dn: {
            buffer.resize(line_start_dn<B*>::max_bit_width/(8*sizeof(B))+1);
            line_start_dn<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::line_start_segment_1: {
            buffer.resize(line_start_segment_1<B*>::max_bit_width/(8*sizeof(B))+1);
            line_start_segment_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::line_start_segment_2: {
            buffer.resize(line_start_segment_2<B*>::max_bit_width/(8*sizeof(B))+1);
            line_start_segment_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::line_start_segment_3: {
            buffer.resize(line_start_segment_3<B*>::max_bit_width/(8*sizeof(B))+1);
            line_start_segment_3<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::line_start_up: {
            buffer.resize(line_start_up<B*>::max_bit_width/(8*sizeof(B))+1);
            line_start_up<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::line_stop: {
            buffer.resize(line_stop<B*>::max_bit_width/(8*sizeof(B))+1);
            line_stop<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::m_sequence_mta: {
            buffer.resize(m_sequence_mta<B*>::max_bit_width/(8*sizeof(B))+1);
            m_sequence_mta<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::magnetic_field: {
            buffer.resize(magnetic_field<B*>::max_bit_width/(8*sizeof(B))+1);
            magnetic_field<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::meas_start: {
            buffer.resize(meas_start<B*>::max_bit_width/(8*sizeof(B))+1);
            meas_start<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::meas_stop: {
            buffer.resize(meas_stop<B*>::max_bit_width/(8*sizeof(B))+1);
            meas_stop<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::monitoring_info: {
            buffer.resize(monitoring_info<B*>::max_bit_width/(8*sizeof(B))+1);
            monitoring_info<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::mta_settings: {
            buffer.resize(mta_settings<B*>::max_bit_width/(8*sizeof(B))+1);
            mta_settings<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::mta_settings_1: {
            buffer.resize(mta_settings_1<B*>::max_bit_width/(8*sizeof(B))+1);
            mta_settings_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::mta_settings_2: {
            buffer.resize(mta_settings_2<B*>::max_bit_width/(8*sizeof(B))+1);
            mta_settings_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::mta_settings_3: {
            buffer.resize(mta_settings_3<B*>::max_bit_width/(8*sizeof(B))+1);
            mta_settings_3<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::notch_filter: {
            buffer.resize(notch_filter<B*>::max_bit_width/(8*sizeof(B))+1);
            notch_filter<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::notch_filter_modification_parameters: {
            buffer.resize(notch_filter_modification_parameters<B*>::max_bit_width/(8*sizeof(B))+1);
            notch_filter_modification_parameters<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::nrange_table: {
            buffer.resize(nrange_table<B*>::max_bit_width/(8*sizeof(B))+1);
            nrange_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::operating_time: {
            buffer.resize(operating_time<B*>::max_bit_width/(8*sizeof(B))+1);
            operating_time<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_frame_echo: {
            buffer.resize(packed_frame_echo<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_frame_echo<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_frame_echo_hr: {
            buffer.resize(packed_frame_echo_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_frame_echo_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_frame_echo_hr_1: {
            buffer.resize(packed_frame_echo_hr_1<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_frame_echo_hr_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_frame_laser_shot_2angles: {
            buffer.resize(packed_frame_laser_shot_2angles<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_frame_laser_shot_2angles<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_frame_laser_shot_2angles_hr: {
            buffer.resize(packed_frame_laser_shot_2angles_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_frame_laser_shot_2angles_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_frame_laser_shot_2angles_rad: {
            buffer.resize(packed_frame_laser_shot_2angles_rad<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_frame_laser_shot_2angles_rad<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_key_echo: {
            buffer.resize(packed_key_echo<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_key_echo<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_key_echo_hr: {
            buffer.resize(packed_key_echo_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_key_echo_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_key_echo_hr_1: {
            buffer.resize(packed_key_echo_hr_1<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_key_echo_hr_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_key_laser_shot_2angles: {
            buffer.resize(packed_key_laser_shot_2angles<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_key_laser_shot_2angles<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_key_laser_shot_2angles_hr: {
            buffer.resize(packed_key_laser_shot_2angles_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_key_laser_shot_2angles_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_key_laser_shot_2angles_hr_mta: {
            buffer.resize(packed_key_laser_shot_2angles_hr_mta<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_key_laser_shot_2angles_hr_mta<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_key_laser_shot_2angles_rad: {
            buffer.resize(packed_key_laser_shot_2angles_rad<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_key_laser_shot_2angles_rad<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_sdf: {
            buffer.resize(packed_sdf<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_sdf<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_shot_echos_hr: {
            buffer.resize(packed_shot_echos_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_shot_echos_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::packed_shot_echos_sbl_hr: {
            buffer.resize(packed_shot_echos_sbl_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            packed_shot_echos_sbl_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::pps_sync: {
            buffer.resize(pps_sync<B*>::max_bit_width/(8*sizeof(B))+1);
            pps_sync<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::pps_sync_ext: {
            buffer.resize(pps_sync_ext<B*>::max_bit_width/(8*sizeof(B))+1);
            pps_sync_ext<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::pps_sync_hr: {
            buffer.resize(pps_sync_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            pps_sync_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::pps_sync_hr_ext: {
            buffer.resize(pps_sync_hr_ext<B*>::max_bit_width/(8*sizeof(B))+1);
            pps_sync_hr_ext<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::pulse_model_expsum: {
            buffer.resize(pulse_model_expsum<B*>::max_bit_width/(8*sizeof(B))+1);
            pulse_model_expsum<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::pulse_position_modulation: {
            buffer.resize(pulse_position_modulation<B*>::max_bit_width/(8*sizeof(B))+1);
            pulse_position_modulation<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::pulse_position_modulation_1: {
            buffer.resize(pulse_position_modulation_1<B*>::max_bit_width/(8*sizeof(B))+1);
            pulse_position_modulation_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::pwm_sync: {
            buffer.resize(pwm_sync<B*>::max_bit_width/(8*sizeof(B))+1);
            pwm_sync<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_calc: {
            buffer.resize(range_calc<B*>::max_bit_width/(8*sizeof(B))+1);
            range_calc<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_debug_acq: {
            buffer.resize(range_finder_debug_acq<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_debug_acq<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_debug_acq_1: {
            buffer.resize(range_finder_debug_acq_1<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_debug_acq_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_debug_calc: {
            buffer.resize(range_finder_debug_calc<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_debug_calc<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_debug_calc_1: {
            buffer.resize(range_finder_debug_calc_1<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_debug_calc_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_debug_laser: {
            buffer.resize(range_finder_debug_laser<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_debug_laser<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_debug_laser_1: {
            buffer.resize(range_finder_debug_laser_1<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_debug_laser_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_debug_rcv: {
            buffer.resize(range_finder_debug_rcv<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_debug_rcv<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_program: {
            buffer.resize(range_finder_program<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_program<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_program_1: {
            buffer.resize(range_finder_program_1<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_program_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_program_2: {
            buffer.resize(range_finder_program_2<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_program_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::range_finder_settings: {
            buffer.resize(range_finder_settings<B*>::max_bit_width/(8*sizeof(B))+1);
            range_finder_settings<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::receiver_geometry: {
            buffer.resize(receiver_geometry<B*>::max_bit_width/(8*sizeof(B))+1);
            receiver_geometry<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::reftab_table: {
            buffer.resize(reftab_table<B*>::max_bit_width/(8*sizeof(B))+1);
            reftab_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::rel_refl_table: {
            buffer.resize(rel_refl_table<B*>::max_bit_width/(8*sizeof(B))+1);
            rel_refl_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::rxp_parameters: {
            buffer.resize(rxp_parameters<B*>::max_bit_width/(8*sizeof(B))+1);
            rxp_parameters<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel: {
            buffer.resize(sbl_dg_channel<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_1: {
            buffer.resize(sbl_dg_channel_1<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_2: {
            buffer.resize(sbl_dg_channel_2<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_data: {
            buffer.resize(sbl_dg_channel_data<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_data<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_data_compressed: {
            buffer.resize(sbl_dg_channel_data_compressed<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_data_compressed<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_expsum: {
            buffer.resize(sbl_dg_channel_expsum<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_expsum<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_expsum_1: {
            buffer.resize(sbl_dg_channel_expsum_1<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_expsum_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_fp: {
            buffer.resize(sbl_dg_channel_fp<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_fp<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_header: {
            buffer.resize(sbl_dg_channel_header<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_header<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_header_1: {
            buffer.resize(sbl_dg_channel_header_1<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_header_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_channel_logamp: {
            buffer.resize(sbl_dg_channel_logamp<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_channel_logamp<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_data: {
            buffer.resize(sbl_dg_data<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_data<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_data_compressed: {
            buffer.resize(sbl_dg_data_compressed<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_data_compressed<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_data_compressed_hr: {
            buffer.resize(sbl_dg_data_compressed_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_data_compressed_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_data_hr: {
            buffer.resize(sbl_dg_data_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_data_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_filter: {
            buffer.resize(sbl_dg_filter<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_filter<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_header: {
            buffer.resize(sbl_dg_header<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_header<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_header_hr: {
            buffer.resize(sbl_dg_header_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_header_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::sbl_dg_parameters: {
            buffer.resize(sbl_dg_parameters<B*>::max_bit_width/(8*sizeof(B))+1);
            sbl_dg_parameters<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::scan_rect_fov: {
            buffer.resize(scan_rect_fov<B*>::max_bit_width/(8*sizeof(B))+1);
            scan_rect_fov<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::scan_rect_fov_1: {
            buffer.resize(scan_rect_fov_1<B*>::max_bit_width/(8*sizeof(B))+1);
            scan_rect_fov_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::scan_segments_fov: {
            buffer.resize(scan_segments_fov<B*>::max_bit_width/(8*sizeof(B))+1);
            scan_segments_fov<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::scan_trail_fov: {
            buffer.resize(scan_trail_fov<B*>::max_bit_width/(8*sizeof(B))+1);
            scan_trail_fov<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::scanner_pose: {
            buffer.resize(scanner_pose<B*>::max_bit_width/(8*sizeof(B))+1);
            scanner_pose<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::scanner_pose_hr: {
            buffer.resize(scanner_pose_hr<B*>::max_bit_width/(8*sizeof(B))+1);
            scanner_pose_hr<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::scanner_pose_hr_1: {
            buffer.resize(scanner_pose_hr_1<B*>::max_bit_width/(8*sizeof(B))+1);
            scanner_pose_hr_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::scanner_pose_ucs: {
            buffer.resize(scanner_pose_ucs<B*>::max_bit_width/(8*sizeof(B))+1);
            scanner_pose_ucs<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::scanner_pose_ucs_1: {
            buffer.resize(scanner_pose_ucs_1<B*>::max_bit_width/(8*sizeof(B))+1);
            scanner_pose_ucs_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::slt_dg: {
            buffer.resize(slt_dg<B*>::max_bit_width/(8*sizeof(B))+1);
            slt_dg<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::slt_dg_1: {
            buffer.resize(slt_dg_1<B*>::max_bit_width/(8*sizeof(B))+1);
            slt_dg_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::slt_dg_2: {
            buffer.resize(slt_dg_2<B*>::max_bit_width/(8*sizeof(B))+1);
            slt_dg_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::slt_dg_3: {
            buffer.resize(slt_dg_3<B*>::max_bit_width/(8*sizeof(B))+1);
            slt_dg_3<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::slt_dg_4: {
            buffer.resize(slt_dg_4<B*>::max_bit_width/(8*sizeof(B))+1);
            slt_dg_4<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::tgt_dg: {
            buffer.resize(tgt_dg<B*>::max_bit_width/(8*sizeof(B))+1);
            tgt_dg<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::timed_blob: {
            buffer.resize(timed_blob<B*>::max_bit_width/(8*sizeof(B))+1);
            timed_blob<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::trigger_debug_dyntrig_table: {
            buffer.resize(trigger_debug_dyntrig_table<B*>::max_bit_width/(8*sizeof(B))+1);
            trigger_debug_dyntrig_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::trigger_debug_stattrig_table: {
            buffer.resize(trigger_debug_stattrig_table<B*>::max_bit_width/(8*sizeof(B))+1);
            trigger_debug_stattrig_table<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::ttip_config: {
            buffer.resize(ttip_config<B*>::max_bit_width/(8*sizeof(B))+1);
            ttip_config<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::ttip_config_channel: {
            buffer.resize(ttip_config_channel<B*>::max_bit_width/(8*sizeof(B))+1);
            ttip_config_channel<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::ttip_start_stop: {
            buffer.resize(ttip_start_stop<B*>::max_bit_width/(8*sizeof(B))+1);
            ttip_start_stop<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::ttip_timestamp: {
            buffer.resize(ttip_timestamp<B*>::max_bit_width/(8*sizeof(B))+1);
            ttip_timestamp<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::ublox_lea5t_rxm: {
            buffer.resize(ublox_lea5t_rxm<B*>::max_bit_width/(8*sizeof(B))+1);
            ublox_lea5t_rxm<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::ublox_lea5t_rxm_sfrb: {
            buffer.resize(ublox_lea5t_rxm_sfrb<B*>::max_bit_width/(8*sizeof(B))+1);
            ublox_lea5t_rxm_sfrb<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::units: {
            buffer.resize(units<B*>::max_bit_width/(8*sizeof(B))+1);
            units<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::units_1: {
            buffer.resize(units_1<B*>::max_bit_width/(8*sizeof(B))+1);
            units_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::units_2: {
            buffer.resize(units_2<B*>::max_bit_width/(8*sizeof(B))+1);
            units_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::units_3: {
            buffer.resize(units_3<B*>::max_bit_width/(8*sizeof(B))+1);
            units_3<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::units_4: {
            buffer.resize(units_4<B*>::max_bit_width/(8*sizeof(B))+1);
            units_4<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::units_IMU: {
            buffer.resize(units_IMU<B*>::max_bit_width/(8*sizeof(B))+1);
            units_IMU<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::unsolicited_message: {
            buffer.resize(unsolicited_message<B*>::max_bit_width/(8*sizeof(B))+1);
            unsolicited_message<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::unsolicited_message_1: {
            buffer.resize(unsolicited_message_1<B*>::max_bit_width/(8*sizeof(B))+1);
            unsolicited_message_1<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::unsolicited_message_2: {
            buffer.resize(unsolicited_message_2<B*>::max_bit_width/(8*sizeof(B))+1);
            unsolicited_message_2<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::versions: {
            buffer.resize(versions<B*>::max_bit_width/(8*sizeof(B))+1);
            versions<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::void_data: {
            buffer.resize(void_data<B*>::max_bit_width/(8*sizeof(B))+1);
            void_data<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::wfm_dg_hp: {
            buffer.resize(wfm_dg_hp<B*>::max_bit_width/(8*sizeof(B))+1);
            wfm_dg_hp<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::wfm_dg_lp: {
            buffer.resize(wfm_dg_lp<B*>::max_bit_width/(8*sizeof(B))+1);
            wfm_dg_lp<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        case package_id::wfm_dg_shp: {
            buffer.resize(wfm_dg_shp<B*>::max_bit_width/(8*sizeof(B))+1);
            wfm_dg_shp<B*> arg(&buffer[0], &buffer[0]+buffer.size());
            in >> arg;
            buffer.resize(arg.end()-&buffer[0]);
        } break;
        default : {
            package_istream_entry ok(in);
            if (ok) {
                std::ios_base::fmtflags f = in.flags();
                in.setf(std::ios_base::hex, std::ios_base::basefield);
                B t;
                while(in.good() && in.peek() == ',') {
                    in >> ',' >> t;
                    buffer.push_back(t);
                }
                in.flags(f);
            }
        }
    }

    return in.good();
}
#endif
#ifndef DOXYGEN
template<class charT, class traits, class B>
bool ridataspec_write(B* begin, B* end, unsigned id_main, unsigned id_sub, std::basic_ostream<charT, traits>& out) {
    package_id::type type = package_id(id_main, id_sub);
    switch(type) {
        case package_id::IMU_data: {
            IMU_data<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::S10DOF_calib: {
            S10DOF_calib<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::S10DOF_calib_1: {
            S10DOF_calib_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::S10DOF_data: {
            S10DOF_data<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::S10DOF_data_1: {
            S10DOF_data_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::S10DOF_units: {
            S10DOF_units<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::alert: {
            alert<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::arange_table: {
            arange_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::atmosphere: {
            atmosphere<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::atmosphere_1: {
            atmosphere_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::atmosphere_2: {
            atmosphere_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::atmosphere_3: {
            atmosphere_3<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::atmosphere_4: {
            atmosphere_4<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::avg_fine_ref_dg: {
            avg_fine_ref_dg<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::beam_geometry: {
            beam_geometry<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::biaxial_geometry: {
            biaxial_geometry<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::blob_uint32: {
            blob_uint32<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::blob_uint8: {
            blob_uint8<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::calib_2D_table: {
            calib_2D_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::calib_table: {
            calib_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::calib_waveform: {
            calib_waveform<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::calib_waveform_1: {
            calib_waveform_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::calib_waveform_L2: {
            calib_waveform_L2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::calib_waveform_L2_1: {
            calib_waveform_L2_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::calib_wfm_sbl_header: {
            calib_wfm_sbl_header<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::cc_slice: {
            cc_slice<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::channel_combination_table: {
            channel_combination_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::context_end: {
            context_end<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::counter_sync: {
            counter_sync<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::counter_sync_2angles_hr: {
            counter_sync_2angles_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::crc32_check: {
            crc32_check<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::crc32_header: {
            crc32_header<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::cs_trans: {
            cs_trans<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::datagram_separator: {
            datagram_separator<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::debug_hw_dg: {
            debug_hw_dg<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::debug_sw_dg: {
            debug_sw_dg<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_geometry: {
            device_geometry<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_geometry_1: {
            device_geometry_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_geometry_2: {
            device_geometry_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_geometry_3: {
            device_geometry_3<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_geometry_4: {
            device_geometry_4<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_geometry_5: {
            device_geometry_5<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_geometry_6: {
            device_geometry_6<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_geometry_7: {
            device_geometry_7<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_geometry_passive_channel: {
            device_geometry_passive_channel<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::device_mounting: {
            device_mounting<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::dyntrig: {
            dyntrig<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::echo: {
            echo<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::echo_1: {
            echo_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::extents: {
            extents<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::extents_1: {
            extents_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::external_gnss_cfg: {
            external_gnss_cfg<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::external_gnss_cfg_ext: {
            external_gnss_cfg_ext<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::firmware: {
            firmware<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::firmware_1: {
            firmware_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::firmware_2: {
            firmware_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::firmware_3: {
            firmware_3<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::fp_samples: {
            fp_samples<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::fp_table: {
            fp_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::fp_trace2ampl: {
            fp_trace2ampl<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::fp_wghts: {
            fp_wghts<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::frame_start: {
            frame_start<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::frame_start_dn: {
            frame_start_dn<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::frame_start_up: {
            frame_start_up<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::frame_stop: {
            frame_stop<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::generic_end: {
            generic_end<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::gravity_socs: {
            gravity_socs<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::header: {
            header<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::header_device: {
            header_device<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::header_ext: {
            header_ext<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_bat: {
            hk_bat<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_bat_1: {
            hk_bat_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_bat_2: {
            hk_bat_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_cam: {
            hk_cam<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_ctr: {
            hk_ctr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_ctr_1: {
            hk_ctr_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_extended_external: {
            hk_extended_external<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_extended_internal: {
            hk_extended_internal<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_float64_param: {
            hk_float64_param<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_float_param: {
            hk_float_param<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_gps: {
            hk_gps<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_gps_hr: {
            hk_gps_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_gps_ts: {
            hk_gps_ts<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_gps_ts_status: {
            hk_gps_ts_status<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_gps_ts_status_dop: {
            hk_gps_ts_status_dop<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_gps_ts_status_dop_ucs: {
            hk_gps_ts_status_dop_ucs<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_group_header: {
            hk_group_header<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_incl: {
            hk_incl<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_incl_4axes: {
            hk_incl_4axes<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_monitor: {
            hk_monitor<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_param_header: {
            hk_param_header<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_param_header_1: {
            hk_param_header_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_ph_data: {
            hk_ph_data<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_ph_data_1: {
            hk_ph_data_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_ph_units: {
            hk_ph_units<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_ph_units_1: {
            hk_ph_units_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_pwr: {
            hk_pwr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_pwr_1: {
            hk_pwr_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rad: {
            hk_rad<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng: {
            hk_rng<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng_1: {
            hk_rng_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng_2: {
            hk_rng_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng_3: {
            hk_rng_3<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng_4: {
            hk_rng_4<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng_5: {
            hk_rng_5<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng_6: {
            hk_rng_6<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng_7: {
            hk_rng_7<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng_8: {
            hk_rng_8<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rng_9: {
            hk_rng_9<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rngx: {
            hk_rngx<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rtc: {
            hk_rtc<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_rtc_sys: {
            hk_rtc_sys<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_scn: {
            hk_scn<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_scn_1: {
            hk_scn_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_scn_2: {
            hk_scn_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_string_param: {
            hk_string_param<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_time: {
            hk_time<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::hk_uint64_param: {
            hk_uint64_param<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::ht_dbg_data: {
            ht_dbg_data<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::inclination: {
            inclination<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::inclination_4axes: {
            inclination_4axes<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::inclination_device: {
            inclination_device<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::inclination_device_4axes: {
            inclination_device_4axes<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::inclination_device_4axes_offset: {
            inclination_device_4axes_offset<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::inclination_static: {
            inclination_static<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_echo: {
            laser_echo<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_echo_qual: {
            laser_echo_qual<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_echo_sw: {
            laser_echo_sw<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot: {
            laser_shot<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot_1angle: {
            laser_shot_1angle<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot_2angles: {
            laser_shot_2angles<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot_2angles_hr: {
            laser_shot_2angles_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot_2angles_rad: {
            laser_shot_2angles_rad<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot_3angles: {
            laser_shot_3angles<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot_6angles: {
            laser_shot_6angles<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot_6angles_hr: {
            laser_shot_6angles_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot_rad: {
            laser_shot_rad<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::laser_shot_utctime_origin_direction: {
            laser_shot_utctime_origin_direction<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::line_start: {
            line_start<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::line_start_dn: {
            line_start_dn<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::line_start_segment_1: {
            line_start_segment_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::line_start_segment_2: {
            line_start_segment_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::line_start_segment_3: {
            line_start_segment_3<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::line_start_up: {
            line_start_up<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::line_stop: {
            line_stop<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::m_sequence_mta: {
            m_sequence_mta<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::magnetic_field: {
            magnetic_field<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::meas_start: {
            meas_start<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::meas_stop: {
            meas_stop<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::monitoring_info: {
            monitoring_info<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::mta_settings: {
            mta_settings<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::mta_settings_1: {
            mta_settings_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::mta_settings_2: {
            mta_settings_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::mta_settings_3: {
            mta_settings_3<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::notch_filter: {
            notch_filter<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::notch_filter_modification_parameters: {
            notch_filter_modification_parameters<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::nrange_table: {
            nrange_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::operating_time: {
            operating_time<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_frame_echo: {
            packed_frame_echo<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_frame_echo_hr: {
            packed_frame_echo_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_frame_echo_hr_1: {
            packed_frame_echo_hr_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_frame_laser_shot_2angles: {
            packed_frame_laser_shot_2angles<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_frame_laser_shot_2angles_hr: {
            packed_frame_laser_shot_2angles_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_frame_laser_shot_2angles_rad: {
            packed_frame_laser_shot_2angles_rad<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_key_echo: {
            packed_key_echo<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_key_echo_hr: {
            packed_key_echo_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_key_echo_hr_1: {
            packed_key_echo_hr_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_key_laser_shot_2angles: {
            packed_key_laser_shot_2angles<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_key_laser_shot_2angles_hr: {
            packed_key_laser_shot_2angles_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_key_laser_shot_2angles_hr_mta: {
            packed_key_laser_shot_2angles_hr_mta<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_key_laser_shot_2angles_rad: {
            packed_key_laser_shot_2angles_rad<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_sdf: {
            packed_sdf<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_shot_echos_hr: {
            packed_shot_echos_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::packed_shot_echos_sbl_hr: {
            packed_shot_echos_sbl_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::pps_sync: {
            pps_sync<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::pps_sync_ext: {
            pps_sync_ext<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::pps_sync_hr: {
            pps_sync_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::pps_sync_hr_ext: {
            pps_sync_hr_ext<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::pulse_model_expsum: {
            pulse_model_expsum<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::pulse_position_modulation: {
            pulse_position_modulation<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::pulse_position_modulation_1: {
            pulse_position_modulation_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::pwm_sync: {
            pwm_sync<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_calc: {
            range_calc<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_debug_acq: {
            range_finder_debug_acq<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_debug_acq_1: {
            range_finder_debug_acq_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_debug_calc: {
            range_finder_debug_calc<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_debug_calc_1: {
            range_finder_debug_calc_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_debug_laser: {
            range_finder_debug_laser<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_debug_laser_1: {
            range_finder_debug_laser_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_debug_rcv: {
            range_finder_debug_rcv<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_program: {
            range_finder_program<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_program_1: {
            range_finder_program_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_program_2: {
            range_finder_program_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::range_finder_settings: {
            range_finder_settings<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::receiver_geometry: {
            receiver_geometry<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::reftab_table: {
            reftab_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::rel_refl_table: {
            rel_refl_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::rxp_parameters: {
            rxp_parameters<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel: {
            sbl_dg_channel<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_1: {
            sbl_dg_channel_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_2: {
            sbl_dg_channel_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_data: {
            sbl_dg_channel_data<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_data_compressed: {
            sbl_dg_channel_data_compressed<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_expsum: {
            sbl_dg_channel_expsum<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_expsum_1: {
            sbl_dg_channel_expsum_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_fp: {
            sbl_dg_channel_fp<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_header: {
            sbl_dg_channel_header<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_header_1: {
            sbl_dg_channel_header_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_channel_logamp: {
            sbl_dg_channel_logamp<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_data: {
            sbl_dg_data<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_data_compressed: {
            sbl_dg_data_compressed<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_data_compressed_hr: {
            sbl_dg_data_compressed_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_data_hr: {
            sbl_dg_data_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_filter: {
            sbl_dg_filter<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_header: {
            sbl_dg_header<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_header_hr: {
            sbl_dg_header_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::sbl_dg_parameters: {
            sbl_dg_parameters<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::scan_rect_fov: {
            scan_rect_fov<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::scan_rect_fov_1: {
            scan_rect_fov_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::scan_segments_fov: {
            scan_segments_fov<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::scan_trail_fov: {
            scan_trail_fov<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::scanner_pose: {
            scanner_pose<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::scanner_pose_hr: {
            scanner_pose_hr<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::scanner_pose_hr_1: {
            scanner_pose_hr_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::scanner_pose_ucs: {
            scanner_pose_ucs<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::scanner_pose_ucs_1: {
            scanner_pose_ucs_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::slt_dg: {
            slt_dg<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::slt_dg_1: {
            slt_dg_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::slt_dg_2: {
            slt_dg_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::slt_dg_3: {
            slt_dg_3<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::slt_dg_4: {
            slt_dg_4<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::tgt_dg: {
            tgt_dg<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::timed_blob: {
            timed_blob<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::trigger_debug_dyntrig_table: {
            trigger_debug_dyntrig_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::trigger_debug_stattrig_table: {
            trigger_debug_stattrig_table<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::ttip_config: {
            ttip_config<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::ttip_config_channel: {
            ttip_config_channel<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::ttip_start_stop: {
            ttip_start_stop<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::ttip_timestamp: {
            ttip_timestamp<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::ublox_lea5t_rxm: {
            ublox_lea5t_rxm<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::ublox_lea5t_rxm_sfrb: {
            ublox_lea5t_rxm_sfrb<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::units: {
            units<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::units_1: {
            units_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::units_2: {
            units_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::units_3: {
            units_3<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::units_4: {
            units_4<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::units_IMU: {
            units_IMU<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::unsolicited_message: {
            unsolicited_message<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::unsolicited_message_1: {
            unsolicited_message_1<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::unsolicited_message_2: {
            unsolicited_message_2<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::versions: {
            versions<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::void_data: {
            void_data<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::wfm_dg_hp: {
            wfm_dg_hp<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::wfm_dg_lp: {
            wfm_dg_lp<B*> arg(begin, end, true);
            out << arg;
        } break;
        case package_id::wfm_dg_shp: {
            wfm_dg_shp<B*> arg(begin, end, true);
            out << arg;
        } break;
        default : {
            std::ios_base::fmtflags f = out.flags();
            out.setf(std::ios_base::showbase);
            out.setf(std::ios_base::hex, std::ios_base::basefield);
            for (B* it = begin; it != end; ++it)
                out << ", " << *it;
            out.flags(f);
        }
    }

    return out.good();
}
#endif

//! INTERNAL ONLY
#define basic_scanner ostream_packets


} // namespace scanlib

#endif /*__cplusplus*/
#endif /* RIDATASPEC_HPP*/
